/*
 * DynamicCanvasPanel.java
 *
 * Created on 8. August 2008, 18:43
 */
package de.naoth.rc.components;

import de.naoth.rc.drawings.Arrow;
import de.naoth.rc.drawings.Drawable;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Composite;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsConfiguration;
import java.awt.Image;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.font.FontRenderContext;
import java.awt.font.GlyphVector;
import java.awt.geom.AffineTransform;
import java.awt.geom.Point2D;
import java.awt.image.BufferedImage;
import java.awt.image.BufferedImageOp;
import java.awt.image.ImageObserver;
import java.awt.image.RenderedImage;
import java.awt.image.renderable.RenderableImage;
import java.text.AttributedCharacterIterator;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Map;

/**
 *
 * @author  Heinrich Mellmann
 */
public class DynamicCanvasPanel extends javax.swing.JPanel 
                                implements MouseMotionListener, 
                                           MouseListener, 
                                           MouseWheelListener,
                                           KeyListener
{

  private double offsetX;
  private double offsetY;
  private double scale;
  private double rotation;
  private boolean mirrorXAxis = true;
  private boolean showCoordinates = true; 
  private double dragOffsetX;
  private double dragOffsetY;
  private boolean antializing;
  
  private final List<Drawable> drawingList = Collections.synchronizedList(new ArrayList<Drawable>());

  public DynamicCanvasPanel()
  {
    this(true);
  }

  /** Creates new form DynamicCanvasPanel */
  public DynamicCanvasPanel(boolean interactive)
  {
    initComponents();

    if (interactive)
    {
      this.addMouseMotionListener(this);
      this.addMouseListener(this);
      this.addMouseWheelListener(this);
      this.addKeyListener(this);
    }
    this.setOpaque(true);

    this.offsetX = 0.0;
    this.offsetY = 0.0;
    this.scale = 1.0;

    this.antializing = false;
    this.rotation = 0.0;
  }

  /** This method is called from within the constructor to
   * initialize the form.
   * WARNING: Do NOT modify this code. The content of this method is
   * always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

  int oldWidth = 0;
  int oldHeight = 0;
  private void formComponentResized(java.awt.event.ComponentEvent evt)//GEN-FIRST:event_formComponentResized
  {//GEN-HEADEREND:event_formComponentResized
      if(oldWidth != 0 && oldHeight != 0)
      {
          double sw = ((double)this.getWidth()) / ((double)oldWidth);
          double sh = ((double)this.getHeight()) / ((double)oldHeight);
          
          double s = (Math.abs(sh-1.0) < Math.abs(sw-1.0))? sw: sh;
          
          this.scale *= s;
          this.offsetX = (int)( ((double)this.offsetX) * s +0.5);
          this.offsetY = (int)( ((double)this.offsetY) * s +0.5);
      }
      
      oldWidth = this.getWidth();
      oldHeight = this.getHeight();
      
      this.repaint();
  }//GEN-LAST:event_formComponentResized

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
  public void addDrawing(Drawable drawing)
  {
    this.drawingList.add(drawing);
  }

  public void removeDrawing(Drawable drawing)
  {
    this.drawingList.remove(drawing);
  }

  @Override
  public String getToolTipText(MouseEvent e)
  {
      Point.Double p = canvasCoordinatesToInternal(new Point.Double(e.getX(), e.getY()));
      String s = String.format("%.0f;%.0f", p.x, p.y);
      return s;
  }

  @Override
  public Point getToolTipLocation(MouseEvent e)
  {
    Point p = e.getPoint();
    p.y += 15;
    return p;
  }
  
  @Override
  protected void paintComponent(Graphics g)
  {
    super.paintComponent(g);
    Graphics2D g2d = (Graphics2D) g;
    paintDrawings(g2d, offsetX, offsetY, rotation, scale);
  }
  
  private class myGraphics extends Graphics2D {
      
      public int max_width = 0;
      public int max_height = 0;
      public int left = 0;
      public int right = 0;
      public int top = 0;
      public int bottom = 0;

        @Override
        public void draw(Shape s) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public boolean drawImage(Image img, AffineTransform xform, ImageObserver obs) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawImage(BufferedImage img, BufferedImageOp op, int x, int y) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawRenderedImage(RenderedImage img, AffineTransform xform) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawRenderableImage(RenderableImage img, AffineTransform xform) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawString(String str, int x, int y) {
            // TODO: drawString
        }

        @Override
        public void drawString(String str, float x, float y) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawString(AttributedCharacterIterator iterator, int x, int y) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawString(AttributedCharacterIterator iterator, float x, float y) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawGlyphVector(GlyphVector g, float x, float y) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void fill(Shape s) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public boolean hit(Rectangle rect, Shape s, boolean onStroke) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public GraphicsConfiguration getDeviceConfiguration() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void setComposite(Composite comp) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void setPaint(Paint paint) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void setStroke(Stroke s) {
        }

        @Override
        public void setRenderingHint(RenderingHints.Key hintKey, Object hintValue) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public Object getRenderingHint(RenderingHints.Key hintKey) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void setRenderingHints(Map<?, ?> hints) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void addRenderingHints(Map<?, ?> hints) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public RenderingHints getRenderingHints() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void translate(int x, int y) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void translate(double tx, double ty) {
            // TODO:translate
        }

        @Override
        public void rotate(double theta) {
            // TODO: rotate
        }

        @Override
        public void rotate(double theta, double x, double y) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void scale(double sx, double sy) {
            // TODO: scale
        }

        @Override
        public void shear(double shx, double shy) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void transform(AffineTransform Tx) {
            // TODO: transform ?!?
        }

        @Override
        public void setTransform(AffineTransform Tx) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public AffineTransform getTransform() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public Paint getPaint() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public Composite getComposite() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void setBackground(Color color) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public Color getBackground() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public Stroke getStroke() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void clip(Shape s) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public FontRenderContext getFontRenderContext() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public Graphics create() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public Color getColor() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void setColor(Color c) {/*ignore*/}

        @Override
        public void setPaintMode() {}

        @Override
        public void setXORMode(Color c1) {
        }

        @Override
        public Font getFont() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void setFont(Font font) {
        }

        @Override
        public FontMetrics getFontMetrics(Font f) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public Rectangle getClipBounds() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void clipRect(int x, int y, int width, int height) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void setClip(int x, int y, int width, int height) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public Shape getClip() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void setClip(Shape clip) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void copyArea(int x, int y, int width, int height, int dx, int dy) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawLine(int x1, int y1, int x2, int y2) {
            if(x1 < left) { left = x1; }
            if(x2 < left) { left = x2; }
            if(y1 < top) { top = y1; }
            if(y2 < top) { top = y2; }
            // TODO
        }

        @Override
        public void fillRect(int x, int y, int width, int height) {
            if(x < left) { left = x; }
            if(y < top) { top = y; }
            if(x+width > right) { right = x+width; }
            if(y+height > bottom) { bottom = y+height; }
            if(max_width < width) { max_width = width; }
            if(max_height < height) { height = height; }
        }

        @Override
        public void clearRect(int x, int y, int width, int height) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void fillRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawOval(int x, int y, int width, int height) {
            if(x < left) { left = x; }
            if(y < top) { top = y; }
            // TODO: drawOval
        }

        @Override
        public void fillOval(int x, int y, int width, int height) {
            if(x < left) { left = x; }
            if(y < top) { top = y; }
            // TODO: fillOval
        }

        @Override
        public void drawArc(int x, int y, int width, int height, int startAngle, int arcAngle) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void fillArc(int x, int y, int width, int height, int startAngle, int arcAngle) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawPolyline(int[] xPoints, int[] yPoints, int nPoints) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void drawPolygon(int[] xPoints, int[] yPoints, int nPoints) {
            // TODO: drawPolygon
        }

        @Override
        public void fillPolygon(int[] xPoints, int[] yPoints, int nPoints) {
            // TODO: fillPolygon
        }

        @Override
        public boolean drawImage(Image img, int x, int y, ImageObserver observer) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public boolean drawImage(Image img, int x, int y, int width, int height, ImageObserver observer) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public boolean drawImage(Image img, int x, int y, Color bgcolor, ImageObserver observer) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public boolean drawImage(Image img, int x, int y, int width, int height, Color bgcolor, ImageObserver observer) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, ImageObserver observer) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public boolean drawImage(Image img, int dx1, int dy1, int dx2, int dy2, int sx1, int sy1, int sx2, int sy2, Color bgcolor, ImageObserver observer) {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public void dispose() {
            throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
        }

        @Override
        public String toString() {
            return String.format("left: %d; right: %d; top: %d; bottom: %d", left, right, top, bottom);
        }
  }
  
  public void getTest() {
      myGraphics t = new myGraphics();
      paintDrawings(t, offsetX, offsetY, rotation, scale);
      // calculate scale and "add" a 10px margin
        double scale_x = ((double)this.getWidth()-10)/(t.right - t.left);
        double scale_y = ((double)this.getHeight()-10)/(t.bottom - t.top);
        setScale(scale_x < scale_y ? scale_x : scale_y);
        setOffsetX(getWidth()/2.);
        setOffsetY(getHeight()/2.);
        repaint();
  }
  
  public void paintDrawings(Graphics2D g2d, double x, double y, double r, double s) 
  {
    if (this.antializing)
    {
      g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
      g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
      g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BICUBIC);
      g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
    }

    // transform the coordinate system to the mathematical one ;)
    g2d.translate(x, y);
    if(mirrorXAxis) {
      g2d.transform(new AffineTransform(1,0,0,-1,0,0));
    }
    g2d.rotate(r);
    g2d.scale(s, s);

    synchronized(drawingList)
    {
        for (Drawable object : drawingList) {
          if(object != null) {
              object.draw(g2d);
          }
        }
    }
    
    // transform the drawing-pane back (nessesary to draw the other components corect)
    g2d.scale(1.0/s, 1.0/s);
    g2d.rotate(-r);
    if(mirrorXAxis) {
      g2d.transform(new AffineTransform(1,0,0,-1,0,0));
    }
    g2d.translate(-x, -y);
    
    if(this.showCoordinates) {
        drawCoordinateSystem(g2d, this.getSize().width-30, this.getSize().height-30);
    }
  }
  
  void drawCoordinateSystem(Graphics2D g2d, int x, int y)
  {
    AffineTransform tx = new AffineTransform();
    tx.translate(x, y);
    if(mirrorXAxis) {
        tx.scale(1.0f, -1.0f);
    }
    tx.rotate(rotation);
    
    Point2D p0 = tx.transform(new Point.Double(-20, -20), null);
    Point2D p1 = tx.transform(new Point.Double(0, -20), null);
    Point2D p2 = tx.transform(new Point.Double(-20, 0), null);
    Point2D p3 = tx.transform(new Point.Double(10, -20), null);
    Point2D p4 = tx.transform(new Point.Double(-20, 10), null);
    
    g2d.setStroke(new BasicStroke(2.0f));
    g2d.setColor(Color.red);
    g2d.drawString("X", (int)p3.getX(), (int)p3.getY());
    //g2d.drawLine((int)p0.getX(), (int)p0.getY(), (int)p1.getX(), (int)p1.getY());
    Arrow.drawArrow(g2d, (int)p0.getX(), (int)p0.getY(), (int)p1.getX(), (int)p1.getY(), 2.0f);
    
    g2d.setColor(Color.black);
    g2d.drawString("Y", (int)p4.getX(), (int)p4.getY());
    //g2d.drawLine((int)p0.getX(), (int)p0.getY(), (int)p2.getX(), (int)p2.getY());
    Arrow.drawArrow(g2d, (int)p0.getX(), (int)p0.getY(), (int)p2.getX(), (int)p2.getY(), 2.0f);
  }
  
  public Point.Double canvasCoordinatesToInternal(Point.Double p)
  {
    AffineTransform tx = new AffineTransform();
    tx.rotate(-rotation);
    tx.scale(1.0/scale, 1.0/scale);
    if(mirrorXAxis) {
        tx.scale(1.0f, -1.0f);
    }
    tx.translate(-offsetX, -offsetY);

    Point.Double result = new Point.Double();
    tx.transform(p, result);
    return result;
  }

  // <editor-fold defaultstate="collapsed" desc="Handling Mouse Events">
  @Override
  public void mouseWheelMoved(MouseWheelEvent e)
  {
    double newScale = scale - scale * e.getWheelRotation() * 0.1;
    if (newScale < 15)
    {
      double newOffsetX = (offsetX - e.getX()) * newScale / scale + e.getX();
      double newOffsetY = (offsetY - e.getY()) * newScale / scale + e.getY();

      dragOffsetX += newOffsetX - offsetX;
      dragOffsetY += newOffsetY - offsetY;

      offsetX = newOffsetX;
      offsetY = newOffsetY;
      scale = newScale;
      repaint();
    }//end if
  }//end mouseWheelMoved

  @Override
  public void mouseDragged(MouseEvent e)
  {
    this.offsetX = this.dragOffsetX + e.getX();
    this.offsetY = this.dragOffsetY + e.getY();
    this.repaint();
  }

  @Override
  public void mousePressed(MouseEvent e)
  {
    this.dragOffsetX = offsetX - e.getX();
    this.dragOffsetY = offsetY - e.getY();
  }

  @Override
  public void mouseReleased(MouseEvent e)
  {
  }

  @Override
  public void mouseEntered(MouseEvent e)
  {
  }

  @Override
  public void mouseExited(MouseEvent e)
  {
  }

  @Override
  public void mouseMoved(MouseEvent e)
  {
  }

  @Override
  public void mouseClicked(MouseEvent e)
  {
  }

    @Override
    public void keyTyped(KeyEvent ke) {
    }

    @Override
    public void keyPressed(KeyEvent ke) {
        int k = ke.getKeyCode();
        if(ke.getKeyCode() == KeyEvent.VK_PLUS) {
            scale += scale * 0.1;
            repaint();
        } else if(ke.getKeyCode() == KeyEvent.VK_MINUS) {
            scale -= scale * 0.1;
            repaint();
        } else if(ke.getKeyCode() == KeyEvent.VK_A) {
            this.offsetX -= 50;
            repaint();
        } else if(ke.getKeyCode() == KeyEvent.VK_D) {
            this.offsetX += 50;
            repaint();
        } else if(ke.getKeyCode() == KeyEvent.VK_S) {
            this.offsetY += 50;
            repaint();
        } else if(ke.getKeyCode() == KeyEvent.VK_W) {
            this.offsetY -= 50;
            repaint();
        } else if(ke.getKeyCode() == KeyEvent.VK_E) {
            this.rotation += Math.PI*0.5;
            repaint();
        } else if(ke.getKeyCode() == KeyEvent.VK_Q) {
            this.rotation -= Math.PI*0.5;
            repaint();
        } 
    }

    @Override
    public void keyReleased(KeyEvent ke) {
    }
  
  

  // </editor-fold>
  // <editor-fold defaultstate="collapsed" desc="Getter and Setter">
  public void setOffsetX(double offsetX)
  {
    this.offsetX = offsetX;
  }

  public void setOffsetY(double offsetY)
  {
    this.offsetY = offsetY;
  }

  public void setScale(double scale)
  {
    this.scale = scale;
  }

  public List<Drawable> getDrawingList()
  {
    return drawingList;
  }

  public double getOffsetX()
  {
    return offsetX;
  }

  public double getOffsetY()
  {
    return offsetY;
  }

  public double getScale()
  {
    return scale;
  }

  public double getRotation()
  {
    return rotation;
  }

  public void setRotation(double rotation)
  {
    this.rotation = rotation;
  }

  public boolean isAntializing()
  {
    return antializing;
  }

  public void setAntializing(boolean antializing)
  {
    this.antializing = antializing;
  }

  public boolean isMirrorXAxis()
  {
    return mirrorXAxis;
  }

  public void setMirrorXAxis(boolean mirrorXAxis)
  {
    this.mirrorXAxis = mirrorXAxis;
  }
  
  public boolean isShowCoordinates()
  {
    return showCoordinates;
  }

  public void setShowCoordinates(boolean showCoordinates)
  {
    this.showCoordinates = showCoordinates;
  }
    
  // </editor-fold>
}//end DynamicCanvasPanel

