/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.naoth.rc.dialogs;

import de.naoth.rc.RobotControl;
import de.naoth.rc.components.RemoteRobotPanel;
import de.naoth.rc.core.dialog.AbstractDialog;
import de.naoth.rc.core.dialog.DialogPlugin;
import de.naoth.rc.core.manager.ObjectListener;
import de.naoth.rc.core.manager.SwingCommandExecutor;
import de.naoth.rc.dataformats.SPLMessage;
import de.naoth.rc.manager.GenericManagerFactory;
import de.naoth.rc.messages.Representations;
import java.io.IOException;
import java.net.InetAddress;
import java.net.InetSocketAddress;
import java.net.SocketAddress;
import java.net.SocketException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.channels.AsynchronousCloseException;
import java.nio.channels.DatagramChannel;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;
import java.util.TreeMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.SwingUtilities;
import net.xeoh.plugins.base.annotations.PluginImplementation;
import net.xeoh.plugins.base.annotations.injections.InjectPlugin;
import net.java.games.input.Component;
import net.java.games.input.Controller;
import net.java.games.input.ControllerEnvironment;
import net.java.games.input.Event;
import net.java.games.input.EventQueue;

/**
 *
 * @author Verena
 */
public class RemoteTeamControl extends AbstractDialog {

    @PluginImplementation
    public static class Plugin extends DialogPlugin<RemoteTeamControl> {

        @InjectPlugin
        public static RobotControl parent;
        @InjectPlugin
        public static SwingCommandExecutor commandExecutor;
        @InjectPlugin
        public static GenericManagerFactory genericManagerFactory;
    }//end Plugin

    private final Map<String, TeamCommMessage> messageMap = Collections.synchronizedMap(new TreeMap<String, TeamCommMessage>());
    private final HashMap<String, RemoteRobotPanel> robotsMap = new HashMap<>();
    private TeamCommListener teamCommListener;
    private Timer timerCheckMessages;
    
    public RemoteTeamControl() 
    {
        initComponents();
        
        try {
            teamCommListener = new TeamCommListener();
            teamCommListener.connect(10004);
        } catch (IOException | InterruptedException ex) {
            ex.printStackTrace(System.err);
        }
        
        
        this.timerCheckMessages = new Timer();
        this.timerCheckMessages.scheduleAtFixedRate(new TeamCommListenTask(), 100, 33);
        
        Controller[] ca = ControllerEnvironment.getDefaultEnvironment().getControllers();
        for(int i =0;i<ca.length;i++)
        {
            /* Get the name of the controller */
            System.out.println(ca[i].getName());
            
            registerControl(ca[i]);
            
            System.out.println("Type: "+ca[i].getType().toString());

            /* Get this controllers components (buttons and axis) */
            Component[] components = ca[i].getComponents();
            System.out.println("Component Count: "+components.length);
            for(int j=0;j<components.length;j++){
                
                /* Get the components name */
                System.out.println("Component "+j+": "+components[j].getName());
                System.out.println("    Identifier: "+ components[j].getIdentifier().getName());
                System.out.print("    ComponentType: ");
                if (components[j].isRelative()) {
                    System.out.print("Relative");
                } else {
                    System.out.print("Absolute");
                }
                if (components[j].isAnalog()) {
                    System.out.print(" Analog");
                } else {
                    System.out.print(" Digital");
                }
            }
        }

    }
    
    private void registerControl(Controller controller) {
        try {
            if(controller.getType() == Controller.Type.KEYBOARD) {
                this.timerCheckMessages.scheduleAtFixedRate(new KeyBoardControl(controller), 100, 33);
            } else if(controller.getType() == Controller.Type.GAMEPAD) {
                this.timerCheckMessages.scheduleAtFixedRate(new GamePadControl(controller), 100, 33);
            }
        } catch(IOException ex) {
            ex.printStackTrace(System.err);
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        robotPanel = new javax.swing.JPanel();

        robotPanel.setLayout(new javax.swing.BoxLayout(robotPanel, javax.swing.BoxLayout.LINE_AXIS));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(robotPanel, javax.swing.GroupLayout.DEFAULT_SIZE, 589, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(robotPanel, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, 176, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

class RemoteCommandResultHandler implements ObjectListener<byte[]> {

    @Override
    public void newObjectReceived(byte[] object) {
        if (!new String(object).isEmpty()) {
            System.out.println(new String(object));
        }
    }

    @Override
    public void errorOccured(String cause) {
        System.out.println(cause);
    }
}

    class RemoteCommand {
        public Representations.RemoteControlCommand.ActionType action = Representations.RemoteControlCommand.ActionType.STAND;
        public int x = 0;
        public int y = 0;
        public double alpha = 0;
    }
    
    
    private abstract class RobotController extends TimerTask
    {
        private final Controller control;
        private final DatagramChannel channel;
        private InetSocketAddress targetAddress = null;
        
        protected HashMap<String, RemoteCommand> commands = new HashMap<>();
        
        public RobotController(Controller control) throws IOException {
            this.control = control;
            this.channel = DatagramChannel.open();
        }
        
        public void bind(InetSocketAddress address) {
            targetAddress = address;
        }
        
        protected void send(RemoteCommand command) 
        {
            if(targetAddress == null) {
                return;
            }
            
            Representations.RemoteControlCommand.Builder cmd = Representations.RemoteControlCommand.newBuilder();
            cmd.setAction(command.action);
            cmd.getTargetBuilder()
                .setRotation(command.alpha)
                .getTranslationBuilder().setX(command.x).setY(command.y);

            try {
                ByteBuffer buffer = ByteBuffer.wrap(cmd.build().toByteArray());
                this.channel.send(buffer, targetAddress);
                
            } catch (IOException ex) {
                ex.printStackTrace(System.err);
            }
        }
        
        @Override
        public void run() 
        {
            control.poll();
            EventQueue queue = control.getEventQueue();
            
            Event event = new Event();
            while(queue.getNextEvent(event)) 
            {
                update(event);
            }
            
            RemoteCommand fc = new RemoteCommand();
            fc.action = Representations.RemoteControlCommand.ActionType.STAND;
            for(RemoteCommand c : this.commands.values()) {
                if(c != null) {
                    fc.action = c.action;
                    fc.x += c.x;
                    fc.y += c.y;
                }
            }
            send(fc);
        }
        
        protected abstract void update(Event event);
    }
    
    private class GamePadControl extends RobotController 
    {
        public GamePadControl(Controller control) throws IOException {
            super(control);
        }
        
        @Override
        protected void update(Event event)
        {
            System.out.println(event.getComponent().getName() + " - " + event.getValue());
            Component.Identifier id = event.getComponent().getIdentifier();
            
        } 
    }// end class GamePadControl

    private class KeyBoardControl extends RobotController 
    {
        public KeyBoardControl(Controller control) throws IOException {
            super(control);
        }
        
        @Override
        protected void update(Event event)
        {
            System.out.println(event.getComponent().getName() + " - " + event.getValue());
            Component.Identifier id = event.getComponent().getIdentifier();
            if(id == Component.Identifier.Key.W) {
                if(event.getValue() > 0) {
                    RemoteCommand c = new RemoteCommand();
                    c.action = Representations.RemoteControlCommand.ActionType.WALK;
                    c.x = 50;
                    commands.put(id.getName(), c);
                } else {
                    commands.remove(id.getName());
                }
            } else if(id == Component.Identifier.Key.S) {
                if(event.getValue() > 0) {
                    RemoteCommand c = new RemoteCommand();
                    c.action = Representations.RemoteControlCommand.ActionType.WALK;
                    c.x = -50;
                    commands.put(id.getName(), c);
                } else {
                    commands.remove(id.getName());
                }
            } else if(id == Component.Identifier.Key.A) {
                if(event.getValue() > 0) {
                    RemoteCommand c = new RemoteCommand();
                    c.action = Representations.RemoteControlCommand.ActionType.WALK;
                    c.y = 50;
                    commands.put(id.getName(), c);
                } else {
                    commands.remove(id.getName());
                }
            } else if(id == Component.Identifier.Key.D) {
                if(event.getValue() > 0) {
                    RemoteCommand c = new RemoteCommand();
                    c.action = Representations.RemoteControlCommand.ActionType.WALK;
                    c.y = -50;
                    commands.put(id.getName(), c);
                } else {
                    commands.remove(id.getName());
                }
            }
        } 
    }// end class KeyBoardControl
    
    
    public class Sender {
        private final DatagramChannel channel;

        public Sender() throws IOException {
            this.channel = DatagramChannel.open();
            this.channel.configureBlocking(true);
            //this.channel.bind(new InetSocketAddress(InetAddress.getByName("0.0.0.0"), port));
        }
        
        void send(Representations.RemoteControlCommand rcc, InetSocketAddress address) throws IOException {
            ByteBuffer buffer = ByteBuffer.wrap(rcc.toByteArray());
            this.channel.send(buffer, new InetSocketAddress(InetAddress.getByName("10.0.4.85"), 10401));
        }
    }

    private class TeamCommListenTask extends TimerTask {

        @Override
        public void run() {
            synchronized (messageMap) {
                if (messageMap.isEmpty()) {
                    return;
                }

                for (Map.Entry<String, TeamCommMessage> msgEntry : messageMap.entrySet()) 
                {
                    final String address = msgEntry.getKey();
                    final TeamCommMessage msg = msgEntry.getValue();

                    SwingUtilities.invokeLater(new Runnable() {
                        @Override
                        public void run() {
                            RemoteRobotPanel robotStatus = robotsMap.get(address);
                            if (robotStatus == null) {
                                robotStatus = new RemoteRobotPanel();
                                robotsMap.put(address, robotStatus);
                                robotPanel.add(robotStatus);
                                robotPanel.repaint();
                            }
                            // update
                            robotStatus.setStatus(msg.timestamp, msg.message);
                        }
                    });
                }
            } // end synchronized
        } // end run
    }

    public class TeamCommListener implements Runnable {
        private DatagramChannel channel;
        private Thread trigger;

        private final ByteBuffer readBuffer;

        public TeamCommListener() {
            this.readBuffer = ByteBuffer.allocateDirect(SPLMessage.SPL_STANDARD_MESSAGE_SIZE);
            this.readBuffer.order(ByteOrder.LITTLE_ENDIAN);
        }

        boolean isConnected() {
            return this.channel != null && this.trigger != null;
        }

        public void connect(int port) throws IOException, InterruptedException {
            disconnect();

            this.channel = DatagramChannel.open();
            this.channel.configureBlocking(true);
            this.channel.bind(new InetSocketAddress(InetAddress.getByName("0.0.0.0"), port));

            this.trigger = new Thread(this);
            this.trigger.start();
        }

        public void disconnect() throws IOException, InterruptedException {
            if (this.channel != null) {
                this.channel.close();
                this.channel = null;
            }
            if (this.trigger != null) {
                this.trigger.join();
                this.trigger = null;
            }
        }

        @Override
        public void run() {
            try {
                while (true) {
                    this.readBuffer.clear();
                    SocketAddress address = this.channel.receive(this.readBuffer);
                    this.readBuffer.flip();

                    try {
                        long timestamp = System.currentTimeMillis();
                        SPLMessage spl_msg = new SPLMessage(this.readBuffer);
                        TeamCommMessage tc_msg = new TeamCommMessage(timestamp, spl_msg);
                        
                        if (address instanceof InetSocketAddress) {
                            messageMap.put(((InetSocketAddress) address).getHostString(), tc_msg);
                        }

                    } catch (Exception ex) {
                        Logger.getLogger(TeamCommViewer.class.getName()).log(Level.INFO, null, ex);
                    }

                }
            } catch (AsynchronousCloseException ex) {
                /* socket was closed, that's fine */
            } catch (SocketException ex) {
                Logger.getLogger(TeamCommViewer.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger(TeamCommViewer.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
    }//end class TeamCommListener

    public class TeamCommMessage {

        public TeamCommMessage(long timestamp, SPLMessage message) {
            this.timestamp = timestamp;
            this.message = message;
        }

        public final long timestamp;
        public final SPLMessage message;
        
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel robotPanel;
    // End of variables declaration//GEN-END:variables
}
