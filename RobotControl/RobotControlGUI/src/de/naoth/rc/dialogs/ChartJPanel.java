/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

package de.naoth.rc.dialogs;

import de.naoth.rc.dialogs.ResultSaver.ResultType;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.geom.Line2D;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;
import javax.swing.JPanel;

/**
 *
 * @author helios
 */
public class ChartJPanel extends javax.swing.JPanel {

    int minY, maxY;
    double minX, maxX, stepX;
    List<ResultSaver> resultList;
    List<ResultType> resultTypeList;
    boolean intParameter;
    /**
     * Creates new form ChartJFrame
     */
    public ChartJPanel() {
        resultList=null;
        resultTypeList = new LinkedList<>();
        resultTypeList.addAll(Arrays.asList(ResultType.values()));
        initComponents();
        /*JPanel panel=new JPanel();
        getContentPane().add(panel);
        width = 450;
        height = 450;
        setSize(width,height);        */
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setMinimumSize(new java.awt.Dimension(300, 300));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
   
    @Override
    public void paint(Graphics g) {
        super.paint(g);  // fixes the immediate problem.
         if (resultList == null || resultList.size()<2) return;
       
        int margin = 50;        
       
        
        Graphics2D g2 = (Graphics2D) g;
        //Draw Axis;
        g2.setColor(Color.black);
        Line2D lin = new Line2D.Float(margin, this.getHeight()-margin, this.getWidth()-margin, this.getHeight()- margin);
        g2.draw(lin); 
        lin = new Line2D.Float(margin, margin, margin, this.getHeight()- margin);
        g2.draw(lin); 
        //
        paintResult(g2, margin);
        paintXLabel(g2,margin, resultList.size());
        paintYLabel(g2,minY, maxY, margin);
        


    }
    
    private void paintResult(Graphics2D g, int margin) {
        float stepX;
        float difY;
        difY = maxY-minY;
        stepX = 100f/resultList.size();
        
        for (int i=0; i<resultList.size();i++)
        {
            ResultSaver result = resultList.get(i);
            float coorX1, coorY, coorX2;
            //Skallieren auf 100*100
            coorX1 = ( i* stepX);
            
            coorX2 = ((i+1)* stepX);
            //Variable Größenanpassung
            coorX2 = (this.getWidth()-2*margin)*coorX2/100f+margin;  
            coorX1 = (this.getWidth()-2*margin)*coorX1/100f+margin;
            for (ResultType resultType: resultTypeList){
                g.setColor(ResultSaver.getColor(resultType));               
                //Skallieren auf 100*100
                coorY = 100-((result.getValue(resultType)-minY)/difY)*100f;
                //Variable Größenanpassung
                coorY = (this.getHeight()-2*margin)*coorY/100f+margin;
                Line2D lin = new Line2D.Float(coorX1, coorY, coorX2, coorY);
                g.draw(lin); 
            }
        }
    }
    
    private void paintYLabel(Graphics2D g,int min, int max, int margin){
        final int minLabelSpace = 20;
        final int scale = 10;
        g.setColor(Color.black);
        Line2D lin = new Line2D.Float(margin-5, this.getHeight()-margin, margin, this.getHeight()- margin);
        g.draw(lin);
        g.drawString(""+min,0 , this.getHeight() - margin+5);
        lin = new Line2D.Float(margin-5, margin, margin, margin);
        g.draw(lin);
        g.drawString(""+max,0 , margin+5); 
        int numOfSpaces = (this.getHeight() - 2*margin - minLabelSpace) / minLabelSpace;
        int degree  = 0;                
        while (numOfSpaces<(maxY-minY)/Math.pow(scale, degree)) degree++;         
        int yOffset =(int) ((minY / (int) Math.pow(scale, degree) +1)* (int) Math.pow(scale, degree));        
        float startY =  100-((yOffset-minY)/(float)(maxY - minY))*100f;
        startY = (this.getHeight()-2*margin)*startY/100f+margin; 
        
        float stepY = 100-((yOffset+(float)Math.pow(scale, degree)-minY)/(float)(maxY - minY))*100f;
        stepY = startY -((this.getHeight()-2*margin)*stepY/100f+margin);  
        //korrigierte numOfSPaces based on the acctual uses labelSpace
        numOfSpaces = (int) Math.ceil((maxY / Math.pow(scale, degree))) - (minY / (int) Math.pow(scale, degree) +1);      
        
        for (int i=0;i<numOfSpaces;i++){
            lin = new Line2D.Float(margin-5, startY - (i*stepY) , margin, startY - (i*stepY));
            g.draw(lin);  
            g.drawString(String.valueOf((int)(yOffset+i*Math.pow(scale, degree))), 0, startY - (i*stepY)+5);
        }
        
     /*   lin = new Line2D.Float(margin-5, test2 , margin, test2);
        g.draw(lin);  
        g.drawString(String.valueOf(yOffset+(int)Math.pow(10, degree)), 0, test2);
     /*  
        for (int i=0;i<numOfSpaces;i++){
            lin = new Line2D.Float(margin-5, this.getHeight() - margin - i*minLabelSpace , margin, this.getHeight() - margin - i*minLabelSpace);
            g.draw(lin);    
        }*/
       
    }
    
    private void paintXLabel(Graphics2D g, int margin, int numOfElements){
        double stepSize = ((this.getWidth()-2*margin)*1.0)/numOfElements;
        g.setColor(Color.black);
        Line2D lin = new Line2D.Float(margin, this.getHeight()-margin, margin, this.getHeight()- margin + 5);
        g.draw(lin);
        for (int i=0; i<numOfElements; i++) {
            float coorX = (float)(margin+(i+1)* stepSize);
            lin = new Line2D.Float(coorX, this.getHeight()-margin, coorX, this.getHeight()-margin+5);
            g.draw(lin);
            coorX = (float)(margin + i* stepSize + 1);
            if (i+1==numOfElements) {
                if (intParameter) g.drawString(String.valueOf((int) maxX), coorX,  this.getHeight()- margin + 15);
                else g.drawString(String.valueOf(maxX), coorX,  this.getHeight()-margin + 15);
            } else {
                if (intParameter) g.drawString(String.valueOf((int) (minX+(i*stepX))), coorX,  this.getHeight()-margin + 15);
                else g.drawString(String.valueOf(minX+(i*stepX)), coorX,  this.getHeight()-margin + 15);
            }
        }        
    }
    
   
    
    public void setMinMaxY() {
        minY = Integer.MAX_VALUE;
        maxY = 0;
        if (resultList==null) return; 
        for (int i=0; i<resultList.size();i++)
        {            
            ResultSaver result = resultList.get(i);
            for (ResultType resultType: resultTypeList){
                if (result.getValue(resultType)<minY) minY =  result.getValue(resultType);
                if (result.getValue(resultType)>maxY) maxY =  result.getValue(resultType);
            }
            

        }
        //minimale y Achsengröße
        if (maxY-minY<20) {
            int newMinY = (minY+maxY)/2 -10; 
            minY = newMinY>=0?newMinY:0;
            maxY = minY+20;
        }   
    }
    
    private void setMinMaxX() {
        minX =  Integer.MAX_VALUE;
        maxX = 0;
        if (resultList==null) return; 
        for (int i=0; i<resultList.size();i++)
        {
            ResultSaver result = resultList.get(i);
            if (result.parameterValue<minX) minX = (result.parameterValue);
            if (result.parameterValue>maxX) maxX = (result.parameterValue);
        }
    }
    
    void setValues(List<ResultSaver> resultList,Double stepX, boolean intParameter){
        this.resultList = resultList;
        this.stepX = stepX;
        this.intParameter = intParameter;
        setMinMaxX();
        setMinMaxY();
    }
    
    void addDrawing(ResultType resultType) {
        resultTypeList.add(resultType);
    }
    
    void removeDrawing(ResultType resultType) {
        resultTypeList.remove(resultType);
    }
    
       

    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
}

/*
 public void setValues(List<ResultSaver>() resultList, Double stepX, boolean intParameter){
        this.resultList = resultList;
        this.stepX = stepX;
        
    }   

*/