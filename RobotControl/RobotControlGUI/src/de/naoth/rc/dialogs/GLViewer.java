/**
 * @author <a href="xu@informatik.hu-berlin.de">Xu, Yuan</a>
 */
package de.naoth.rc.dialogs;

import com.jogamp.opengl.GL3;
import com.jogamp.opengl.GLAutoDrawable;
import com.jogamp.opengl.GLCapabilities;
import com.jogamp.opengl.GLEventListener;
import com.jogamp.opengl.GLProfile;
import com.jogamp.opengl.awt.GLCanvas;
import com.jogamp.opengl.util.FPSAnimator;
import de.naoth.rc.opengl.Camera;
import de.naoth.rc.opengl.Scene;
import de.naoth.rc.opengl.representations.Point3f;
import de.naoth.rc.opengl.representations.Vector3f;
import de.naoth.rc.RobotControl;
import de.naoth.rc.core.dialog.AbstractDialog;
import de.naoth.rc.core.dialog.DialogPlugin;
import de.naoth.rc.core.manager.ObjectListener;
import de.naoth.rc.manager.GLViewerSceneManager;
import de.naoth.rc.manager.ImageManagerBottom;
import de.naoth.rc.manager.ImageManagerTop;
import de.naoth.rc.opengl.Shader;
import de.naoth.rc.opengl.drawings.*;
import de.naoth.rc.opengl.model.GLObject;
import de.naoth.rc.opengl.representations.GLCache;
import de.naoth.rc.opengl.representations.Matrix4;
import java.awt.MouseInfo;
import java.awt.Point;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.util.HashMap;
import java.util.concurrent.ConcurrentLinkedQueue;
import net.xeoh.plugins.base.annotations.PluginImplementation;
import net.xeoh.plugins.base.annotations.injections.InjectPlugin;

//@PluginImplementation
public class GLViewer extends AbstractDialog {

    @PluginImplementation
    public static class Plugin extends DialogPlugin<GLViewer> {

        @InjectPlugin
        public static RobotControl parent;
        @InjectPlugin
        public static GLViewerSceneManager glViewerSceneManager;
        @InjectPlugin
        public static ImageManagerBottom imageManager;
        @InjectPlugin
        public static ImageManagerTop imageTopManager;
    }//end Plugin

    private final GLCanvas canvas;

    private GLEventListenerImpl glImpl;

    /**
     * Creates new form ThreeDimensionViewer
     */
    public GLViewer() {
        super();
        initComponents();

        GLProfile glp = GLProfile.getGL2GL3();
        GLCapabilities caps = new GLCapabilities(glp);

        this.canvas = new GLCanvas(caps);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jToolBar = new javax.swing.JToolBar();
        jToggleButtonUpdate = new javax.swing.JToggleButton();
        jCheckBoxField = new javax.swing.JCheckBox();
        jCheckBoxImage = new javax.swing.JCheckBox();
        cbUseFieldViewer = new javax.swing.JCheckBox();
        jPanelCanvas = new com.jogamp.opengl.awt.GLJPanel();

        jToolBar.setFloatable(false);
        jToolBar.setRollover(true);

        jToggleButtonUpdate.setText("Update");
        jToggleButtonUpdate.setToolTipText("Update scene from robot.");
        jToggleButtonUpdate.setFocusable(false);
        jToggleButtonUpdate.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);
        jToggleButtonUpdate.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToggleButtonUpdate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jToggleButtonUpdateActionPerformed(evt);
            }
        });
        jToolBar.add(jToggleButtonUpdate);

        jCheckBoxField.setSelected(true);
        jCheckBoxField.setText("Field");
        jCheckBoxField.setToolTipText("Show the soccer field.");
        jCheckBoxField.setFocusable(false);
        jCheckBoxField.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
        jCheckBoxField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxFieldActionPerformed(evt);
            }
        });
        jToolBar.add(jCheckBoxField);

        jCheckBoxImage.setText("Image");
        jCheckBoxImage.setToolTipText("Receive image from camera of robot.");
        jCheckBoxImage.setFocusable(false);
        jCheckBoxImage.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
        jCheckBoxImage.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jCheckBoxImage.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxImageActionPerformed(evt);
            }
        });
        jToolBar.add(jCheckBoxImage);

        cbUseFieldViewer.setText("Use FieldViewer");
        cbUseFieldViewer.setFocusable(false);
        cbUseFieldViewer.setHorizontalTextPosition(javax.swing.SwingConstants.RIGHT);
        cbUseFieldViewer.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);
        jToolBar.add(cbUseFieldViewer);

        jPanelCanvas.addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                jPanelCanvasComponentResized(evt);
            }
        });

        javax.swing.GroupLayout jPanelCanvasLayout = new javax.swing.GroupLayout(jPanelCanvas);
        jPanelCanvas.setLayout(jPanelCanvasLayout);
        jPanelCanvasLayout.setHorizontalGroup(
            jPanelCanvasLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        jPanelCanvasLayout.setVerticalGroup(
            jPanelCanvasLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 269, Short.MAX_VALUE)
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jToolBar, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
            .addComponent(jPanelCanvas, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(jToolBar, javax.swing.GroupLayout.PREFERRED_SIZE, 25, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanelCanvas, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
    }// </editor-fold>//GEN-END:initComponents

  private void jCheckBoxFieldActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jCheckBoxFieldActionPerformed
  {//GEN-HEADEREND:event_jCheckBoxFieldActionPerformed
      //TODO do something
  }//GEN-LAST:event_jCheckBoxFieldActionPerformed

  private void jToggleButtonUpdateActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jToggleButtonUpdateActionPerformed
  {//GEN-HEADEREND:event_jToggleButtonUpdateActionPerformed
      if (jToggleButtonUpdate.isSelected()) {
          if (Plugin.parent.checkConnected()) {
              Plugin.glViewerSceneManager.addListener(glImpl);
          } else {
              jToggleButtonUpdate.setSelected(false);
          }
      } else {
          Plugin.glViewerSceneManager.removeListener(glImpl);
      }
  }//GEN-LAST:event_jToggleButtonUpdateActionPerformed

  private void jCheckBoxImageActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_jCheckBoxImageActionPerformed
  {//GEN-HEADEREND:event_jCheckBoxImageActionPerformed
      //TODO do something
  }//GEN-LAST:event_jCheckBoxImageActionPerformed

    private void jPanelCanvasComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_jPanelCanvasComponentResized
        canvas.setSize(jPanelCanvas.getSize());
    }//GEN-LAST:event_jPanelCanvasComponentResized

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBox cbUseFieldViewer;
    private javax.swing.JCheckBox jCheckBoxField;
    private javax.swing.JCheckBox jCheckBoxImage;
    private com.jogamp.opengl.awt.GLJPanel jPanelCanvas;
    private javax.swing.JToggleButton jToggleButtonUpdate;
    private javax.swing.JToolBar jToolBar;
    // End of variables declaration//GEN-END:variables

    @Override
    public void init() {

        glImpl = new GLEventListenerImpl(canvas);

        this.canvas.addGLEventListener(glImpl);

        jPanelCanvas.add(this.canvas);
    }

    @Override
    public void dispose() {
        System.out.println("Dispose is not implemented for: " + this.getClass().getName());
    }//end dispose

}

final class GLEventListenerImpl implements GLEventListener, ObjectListener<String[][]> {

    private FPSAnimator animator;

    private GL3 gl;

    private Camera camera;

    private final GLCanvas canvas;

    public Scene dynamicScene, staticScene;
    public ConcurrentLinkedQueue<GLObject> dynamicDisplayQueue, staticDisplayQueue;
    public GLCache glCache;

    public ConcurrentLinkedQueue<String[]> newObjectReceived;

    private final Point3f camPos = new Point3f(20, 30, 40);

    private final String pathToGLSL = System.getProperty("user.dir").replaceAll("\\\\", "/") + "/src/de/naoth/rc/opengl/glsl/";
    private final String scenePath = System.getProperty("user.dir").replaceAll("\\\\", "/") + "/src/de/naoth/rc/opengl/res/";

    private InputModifier inputModifier;

    public GLEventListenerImpl(GLCanvas canvas) {
        this.newObjectReceived = new ConcurrentLinkedQueue();
        this.canvas = canvas;

        this.dynamicDisplayQueue = new ConcurrentLinkedQueue();
        this.staticDisplayQueue = new ConcurrentLinkedQueue();

        this.glCache = new GLCache();
    }

    @Override
    public void newObjectReceived(String[][] object) {
        for (String[] object1 : object) {
            newObjectReceived.add(object1);
        }

    }

    @Override
    public void errorOccured(String cause) {
        System.err.println(cause);
    }

    @Override
    public void init(GLAutoDrawable drawable) {
        gl = drawable.getGL().getGL3();

        Shader standardTexturedModelShader = new Shader(gl, pathToGLSL, "vertex_shader.glsl", "texture_FS.glsl");
        Shader standardModelShader = new Shader(gl, pathToGLSL, "color_VS.glsl", "color_FS.glsl");

        standardTexturedModelShader.setGlobalUniform("light.position", new float[]{0f, 50f, 0f});
        standardTexturedModelShader.setGlobalUniform("light.intensities", new float[]{1f, 1f, 1f});

        standardModelShader.setGlobalUniform("light.position", new float[]{0f, 50f, 0f});
        standardModelShader.setGlobalUniform("light.intensities", new float[]{1f, 1f, 1f});

        this.glCache.putShader("ModelShader", standardModelShader);
        this.glCache.putShader("TexturedModelShader", standardTexturedModelShader);

        this.dynamicScene = new Scene(gl, glCache, dynamicDisplayQueue);
        this.staticScene = new Scene(gl, glCache, staticDisplayQueue);

        String[][] object = new String[1][1];
        object[0][0] = GLDrawable2.class.getPackage().getName() + ".Field";
        this.newObjectReceived(object);

        gl.glEnable(GL3.GL_DEPTH_TEST);

        camera = new Camera(Camera.FOCUS_MODE, camPos, new Point3f(0, 0, 0), new Point3f(0, 1, 0), canvas.getWidth(), canvas.getHeight());
        this.inputModifier = new InputModifier(this, camera);
        this.canvas.addKeyListener((KeyListener) inputModifier);
        this.canvas.addMouseListener((MouseListener) inputModifier);
        new Thread(inputModifier).start();

        animator = new FPSAnimator(drawable, 60);
        animator.start();
    }

    @Override
    public void reshape(GLAutoDrawable drawable, int x, int y, int width, int height) {
        this.camera.reshape(width, height);
    }

    @Override
    public void dispose(GLAutoDrawable drawable) {
        this.animator.stop();
    }

    @Override
    public void display(GLAutoDrawable drawable) {

        for (String[] each : newObjectReceived) {
            dynamicScene.add(each);
        }
        newObjectReceived.clear();

        gl.glEnable(GL3.GL_BLEND);
        gl.glBlendFunc(GL3.GL_SRC_ALPHA, GL3.GL_ONE_MINUS_SRC_ALPHA);

        gl.glClearColor(0.839f, 0.851f, 0.875f, 1.0f);
        //gl.glClearColor((float)Math.random(), (float)Math.random(), (float)Math.random(), 1.0f); //may cause seizures ;)
        gl.glClear(GL3.GL_COLOR_BUFFER_BIT | GL3.GL_DEPTH_BUFFER_BIT);

        this.camera.review();

        Matrix4 cameraMatrix = camera.getCameraMatrix();

        this.dynamicScene.update();
        this.staticScene.update();

        for (GLObject each : staticDisplayQueue) {
            each.bindShader();
            each.bind();
            each.display(cameraMatrix);
            each.unbind();
            each.unbindShader();
        }

        for (GLObject each : dynamicDisplayQueue) {
            each.bindShader();
            each.bind();
            each.display(cameraMatrix);
            each.unbind();
            each.unbindShader();
        }
    }

}

final class InputModifier implements KeyListener, MouseListener, Runnable {

    GLEventListenerImpl glImpl;
    Camera camera;

    public HashMap<Integer, Boolean> pressedKeys;

    public boolean mousePressed = false;
    public Point mousePos = new Point();

    public InputModifier(GLEventListenerImpl glImpl, Camera camera) {
        this.glImpl = glImpl;
        this.camera = camera;
        this.pressedKeys = new HashMap();

        //register keys
        this.pressedKeys.put(KeyEvent.VK_W, false);
        this.pressedKeys.put(KeyEvent.VK_A, false);
        this.pressedKeys.put(KeyEvent.VK_S, false);
        this.pressedKeys.put(KeyEvent.VK_D, false);
        this.pressedKeys.put(KeyEvent.VK_R, false);
        this.pressedKeys.put(KeyEvent.VK_F, false);
        this.pressedKeys.put(KeyEvent.VK_UP, false);
        this.pressedKeys.put(KeyEvent.VK_DOWN, false);
        this.pressedKeys.put(KeyEvent.VK_RIGHT, false);
        this.pressedKeys.put(KeyEvent.VK_LEFT, false);
        this.pressedKeys.put(KeyEvent.VK_ESCAPE, false);
    }

    //KEYLISTENER
    @Override
    public void keyTyped(KeyEvent e) {
    }

    @Override
    public void keyPressed(KeyEvent e) {
        //don't listen to unregistered keys
        if (this.pressedKeys.containsKey(e.getKeyCode())) {
            this.pressedKeys.put(e.getKeyCode(), true);
        }
    }

    @Override
    public void keyReleased(KeyEvent e) {
        //don't listen to unregistered keys
        if (this.pressedKeys.containsKey(e.getKeyCode())) {
            this.pressedKeys.put(e.getKeyCode(), false);
        }
    }

    //MOUSELISTENER
    @Override
    public void mouseClicked(MouseEvent e) {
    }

    @Override
    public void mousePressed(MouseEvent e) {
        System.out.println("press");
        mousePos = MouseInfo.getPointerInfo().getLocation();
        this.mousePressed = true;
    }

    @Override
    public void mouseReleased(MouseEvent e) {
        this.mousePressed = false;
    }

    @Override
    public void mouseEntered(MouseEvent e) {
    }

    @Override
    public void mouseExited(MouseEvent e) {
    }

    @Override
    public void run() {
        while (true) {

            if (this.pressedKeys.get(KeyEvent.VK_W)) {
                camera.rotateUp(-0.02f);
            }
            if (this.pressedKeys.get(KeyEvent.VK_A)) {
                camera.rotateRight(-0.02f);
            }
            if (this.pressedKeys.get(KeyEvent.VK_S)) {
                camera.rotateUp(0.02f);
            }
            if (this.pressedKeys.get(KeyEvent.VK_D)) {
                camera.rotateRight(0.02f);
            }
            if (this.pressedKeys.get(KeyEvent.VK_R)) {
                camera.setFocus(new Vector3f(0, 2, 0));
            }
            if (this.pressedKeys.get(KeyEvent.VK_F)) {
                camera.setMode(Camera.FLY_MODE);
            }
            if (this.pressedKeys.get(KeyEvent.VK_UP)) {
                camera.moveForward(1);
            }
            if (this.pressedKeys.get(KeyEvent.VK_DOWN)) {
                camera.moveForward(-1);
            }
            if (this.pressedKeys.get(KeyEvent.VK_RIGHT)) {

            }
            if (this.pressedKeys.get(KeyEvent.VK_LEFT)) {

            }
            if (this.pressedKeys.get(KeyEvent.VK_ESCAPE)) {

            }

            if (this.mousePressed) {
                Point newPos = MouseInfo.getPointerInfo().getLocation();

                if (this.mousePos.y > newPos.y) {
                    camera.rotateUp(Math.abs(this.mousePos.y - newPos.y) * 0.01f);
                } else if (this.mousePos.y < newPos.y) {
                    camera.rotateUp(-Math.abs(this.mousePos.y - newPos.y) * 0.01f);
                }

                if (this.mousePos.x > newPos.x) {
                    camera.rotateRight(Math.abs(this.mousePos.x - newPos.x) * 0.01f);
                } else if (this.mousePos.x < newPos.x) {
                    camera.rotateRight(-Math.abs(this.mousePos.x - newPos.x) * 0.01f);
                }

                mousePos = newPos;
            }

            try {
                Thread.sleep(10);
            } catch (InterruptedException ex) {
            }
        }
    }
}
