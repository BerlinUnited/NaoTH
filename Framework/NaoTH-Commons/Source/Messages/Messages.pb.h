// added by NaoTH 
#if defined(__GNUC__) && defined(_NAOTH_CHECK_CONVERSION_)
#if __GNUC__ > 3 && __GNUC_MINOR__ > 5
#pragma GCC diagnostic push
#endif
#pragma GCC diagnostic ignored "-Wconversion"
#endif

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Messages.proto

#ifndef PROTOBUF_Messages_2eproto__INCLUDED
#define PROTOBUF_Messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "CommonTypes.pb.h"
// @@protoc_insertion_point(includes)

namespace naothmessages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Messages_2eproto();
void protobuf_AssignDesc_Messages_2eproto();
void protobuf_ShutdownFile_Messages_2eproto();

class CMDArg;
class CMD;
class PlayerModel;
class TeamCommMessage;
class StopwatchItem;
class Stopwatches;
class PlotItem;
class PlotStroke2D;
class Plots;
class XABSLSymbol;
class XABSLActiveOptionSparse;
class XABSLActionSparse;
class SymbolValueList;
class SymbolValueList_DoubleSymbol;
class SymbolValueList_BooleanSymbol;
class SymbolValueList_EnumSymbol;
class BehaviorStatusSparse;
class XABSLBehavior;
class XABSLBehavior_EnumType;
class XABSLBehavior_EnumType_Element;
class XABSLBehavior_Option;
class XABSLBehavior_Option_State;
class XABSLBehavior_Agent;
class XABSLParameter;
class XABSLAction;
class BehaviorStatus;
class Module;
class ModuleList;
class FeatureKeyPoint;
class FeatureDetectionResult;
class SingleDescriptor;
class FeatureClass;
class FeatureTable;

enum PlotItem_PlotType {
  PlotItem_PlotType_Default = 1,
  PlotItem_PlotType_Plot2D = 2,
  PlotItem_PlotType_Origin2D = 3
};
bool PlotItem_PlotType_IsValid(int value);
const PlotItem_PlotType PlotItem_PlotType_PlotType_MIN = PlotItem_PlotType_Default;
const PlotItem_PlotType PlotItem_PlotType_PlotType_MAX = PlotItem_PlotType_Origin2D;
const int PlotItem_PlotType_PlotType_ARRAYSIZE = PlotItem_PlotType_PlotType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlotItem_PlotType_descriptor();
inline const ::std::string& PlotItem_PlotType_Name(PlotItem_PlotType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlotItem_PlotType_descriptor(), value);
}
inline bool PlotItem_PlotType_Parse(
    const ::std::string& name, PlotItem_PlotType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlotItem_PlotType>(
    PlotItem_PlotType_descriptor(), name, value);
}
enum XABSLSymbol_SymbolType {
  XABSLSymbol_SymbolType_Decimal = 0,
  XABSLSymbol_SymbolType_Boolean = 1,
  XABSLSymbol_SymbolType_Enum = 2,
  XABSLSymbol_SymbolType_Unknown = 3
};
bool XABSLSymbol_SymbolType_IsValid(int value);
const XABSLSymbol_SymbolType XABSLSymbol_SymbolType_SymbolType_MIN = XABSLSymbol_SymbolType_Decimal;
const XABSLSymbol_SymbolType XABSLSymbol_SymbolType_SymbolType_MAX = XABSLSymbol_SymbolType_Unknown;
const int XABSLSymbol_SymbolType_SymbolType_ARRAYSIZE = XABSLSymbol_SymbolType_SymbolType_MAX + 1;

const ::google::protobuf::EnumDescriptor* XABSLSymbol_SymbolType_descriptor();
inline const ::std::string& XABSLSymbol_SymbolType_Name(XABSLSymbol_SymbolType value) {
  return ::google::protobuf::internal::NameOfEnum(
    XABSLSymbol_SymbolType_descriptor(), value);
}
inline bool XABSLSymbol_SymbolType_Parse(
    const ::std::string& name, XABSLSymbol_SymbolType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XABSLSymbol_SymbolType>(
    XABSLSymbol_SymbolType_descriptor(), name, value);
}
enum XABSLActionSparse_ActionType {
  XABSLActionSparse_ActionType_Option = 0,
  XABSLActionSparse_ActionType_BasicBehavior = 1,
  XABSLActionSparse_ActionType_SymbolAssignement = 2,
  XABSLActionSparse_ActionType_Unknown = 3
};
bool XABSLActionSparse_ActionType_IsValid(int value);
const XABSLActionSparse_ActionType XABSLActionSparse_ActionType_ActionType_MIN = XABSLActionSparse_ActionType_Option;
const XABSLActionSparse_ActionType XABSLActionSparse_ActionType_ActionType_MAX = XABSLActionSparse_ActionType_Unknown;
const int XABSLActionSparse_ActionType_ActionType_ARRAYSIZE = XABSLActionSparse_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* XABSLActionSparse_ActionType_descriptor();
inline const ::std::string& XABSLActionSparse_ActionType_Name(XABSLActionSparse_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    XABSLActionSparse_ActionType_descriptor(), value);
}
inline bool XABSLActionSparse_ActionType_Parse(
    const ::std::string& name, XABSLActionSparse_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XABSLActionSparse_ActionType>(
    XABSLActionSparse_ActionType_descriptor(), name, value);
}
enum XABSLParameter_ParamType {
  XABSLParameter_ParamType_Decimal = 0,
  XABSLParameter_ParamType_Boolean = 1,
  XABSLParameter_ParamType_Enum = 2,
  XABSLParameter_ParamType_Unknown = 3
};
bool XABSLParameter_ParamType_IsValid(int value);
const XABSLParameter_ParamType XABSLParameter_ParamType_ParamType_MIN = XABSLParameter_ParamType_Decimal;
const XABSLParameter_ParamType XABSLParameter_ParamType_ParamType_MAX = XABSLParameter_ParamType_Unknown;
const int XABSLParameter_ParamType_ParamType_ARRAYSIZE = XABSLParameter_ParamType_ParamType_MAX + 1;

const ::google::protobuf::EnumDescriptor* XABSLParameter_ParamType_descriptor();
inline const ::std::string& XABSLParameter_ParamType_Name(XABSLParameter_ParamType value) {
  return ::google::protobuf::internal::NameOfEnum(
    XABSLParameter_ParamType_descriptor(), value);
}
inline bool XABSLParameter_ParamType_Parse(
    const ::std::string& name, XABSLParameter_ParamType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XABSLParameter_ParamType>(
    XABSLParameter_ParamType_descriptor(), name, value);
}
enum XABSLAction_ActionType {
  XABSLAction_ActionType_Option = 0,
  XABSLAction_ActionType_BasicBehavior = 1,
  XABSLAction_ActionType_DecimalOutputSymbol = 2,
  XABSLAction_ActionType_BooleanOutputSymbol = 3,
  XABSLAction_ActionType_EnumOutputSymbol = 4,
  XABSLAction_ActionType_Unknown = 5
};
bool XABSLAction_ActionType_IsValid(int value);
const XABSLAction_ActionType XABSLAction_ActionType_ActionType_MIN = XABSLAction_ActionType_Option;
const XABSLAction_ActionType XABSLAction_ActionType_ActionType_MAX = XABSLAction_ActionType_Unknown;
const int XABSLAction_ActionType_ActionType_ARRAYSIZE = XABSLAction_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* XABSLAction_ActionType_descriptor();
inline const ::std::string& XABSLAction_ActionType_Name(XABSLAction_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    XABSLAction_ActionType_descriptor(), value);
}
inline bool XABSLAction_ActionType_Parse(
    const ::std::string& name, XABSLAction_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XABSLAction_ActionType>(
    XABSLAction_ActionType_descriptor(), name, value);
}
// ===================================================================

class CMDArg : public ::google::protobuf::Message {
 public:
  CMDArg();
  virtual ~CMDArg();
  
  CMDArg(const CMDArg& from);
  
  inline CMDArg& operator=(const CMDArg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CMDArg& default_instance();
  
  void Swap(CMDArg* other);
  
  // implements Message ----------------------------------------------
  
  CMDArg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMDArg& from);
  void MergeFrom(const CMDArg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional bytes bytes = 3;
  inline bool has_bytes() const;
  inline void clear_bytes();
  static const int kBytesFieldNumber = 3;
  inline const ::std::string& bytes() const;
  inline void set_bytes(const ::std::string& value);
  inline void set_bytes(const char* value);
  inline void set_bytes(const void* value, size_t size);
  inline ::std::string* mutable_bytes();
  inline ::std::string* release_bytes();
  
  // @@protoc_insertion_point(class_scope:naothmessages.CMDArg)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bytes();
  inline void clear_has_bytes();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* bytes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static CMDArg* default_instance_;
};
// -------------------------------------------------------------------

class CMD : public ::google::protobuf::Message {
 public:
  CMD();
  virtual ~CMD();
  
  CMD(const CMD& from);
  
  inline CMD& operator=(const CMD& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CMD& default_instance();
  
  void Swap(CMD* other);
  
  // implements Message ----------------------------------------------
  
  CMD* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMD& from);
  void MergeFrom(const CMD& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .naothmessages.CMDArg args = 2;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::naothmessages::CMDArg& args(int index) const;
  inline ::naothmessages::CMDArg* mutable_args(int index);
  inline ::naothmessages::CMDArg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::CMDArg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::CMDArg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:naothmessages.CMD)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::CMDArg > args_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static CMD* default_instance_;
};
// -------------------------------------------------------------------

class PlayerModel : public ::google::protobuf::Message {
 public:
  PlayerModel();
  virtual ~PlayerModel();
  
  PlayerModel(const PlayerModel& from);
  
  inline PlayerModel& operator=(const PlayerModel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerModel& default_instance();
  
  void Swap(PlayerModel* other);
  
  // implements Message ----------------------------------------------
  
  PlayerModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerModel& from);
  void MergeFrom(const PlayerModel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);
  
  // optional .naothmessages.Pose2D poseOnField = 2;
  inline bool has_poseonfield() const;
  inline void clear_poseonfield();
  static const int kPoseOnFieldFieldNumber = 2;
  inline const ::naothmessages::Pose2D& poseonfield() const;
  inline ::naothmessages::Pose2D* mutable_poseonfield();
  inline ::naothmessages::Pose2D* release_poseonfield();
  
  // @@protoc_insertion_point(class_scope:naothmessages.PlayerModel)
 private:
  inline void set_has_number();
  inline void clear_has_number();
  inline void set_has_poseonfield();
  inline void clear_has_poseonfield();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::Pose2D* poseonfield_;
  ::google::protobuf::int32 number_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static PlayerModel* default_instance_;
};
// -------------------------------------------------------------------

class TeamCommMessage : public ::google::protobuf::Message {
 public:
  TeamCommMessage();
  virtual ~TeamCommMessage();
  
  TeamCommMessage(const TeamCommMessage& from);
  
  inline TeamCommMessage& operator=(const TeamCommMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamCommMessage& default_instance();
  
  void Swap(TeamCommMessage* other);
  
  // implements Message ----------------------------------------------
  
  TeamCommMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamCommMessage& from);
  void MergeFrom(const TeamCommMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 playerNumber = 1;
  inline bool has_playernumber() const;
  inline void clear_playernumber();
  static const int kPlayerNumberFieldNumber = 1;
  inline ::google::protobuf::int32 playernumber() const;
  inline void set_playernumber(::google::protobuf::int32 value);
  
  // required int32 teamNumber = 2;
  inline bool has_teamnumber() const;
  inline void clear_teamnumber();
  static const int kTeamNumberFieldNumber = 2;
  inline ::google::protobuf::int32 teamnumber() const;
  inline void set_teamnumber(::google::protobuf::int32 value);
  
  // optional bool wasStriker = 3 [default = false];
  inline bool has_wasstriker() const;
  inline void clear_wasstriker();
  static const int kWasStrikerFieldNumber = 3;
  inline bool wasstriker() const;
  inline void set_wasstriker(bool value);
  
  // optional bool isPenalized = 4 [default = false];
  inline bool has_ispenalized() const;
  inline void clear_ispenalized();
  static const int kIsPenalizedFieldNumber = 4;
  inline bool ispenalized() const;
  inline void set_ispenalized(bool value);
  
  // optional double timeSinceBallWasSeen = 5;
  inline bool has_timesinceballwasseen() const;
  inline void clear_timesinceballwasseen();
  static const int kTimeSinceBallWasSeenFieldNumber = 5;
  inline double timesinceballwasseen() const;
  inline void set_timesinceballwasseen(double value);
  
  // optional .naothmessages.DoubleVector2 ballPosition = 6;
  inline bool has_ballposition() const;
  inline void clear_ballposition();
  static const int kBallPositionFieldNumber = 6;
  inline const ::naothmessages::DoubleVector2& ballposition() const;
  inline ::naothmessages::DoubleVector2* mutable_ballposition();
  inline ::naothmessages::DoubleVector2* release_ballposition();
  
  // optional .naothmessages.Pose2D positionOnField = 7;
  inline bool has_positiononfield() const;
  inline void clear_positiononfield();
  static const int kPositionOnFieldFieldNumber = 7;
  inline const ::naothmessages::Pose2D& positiononfield() const;
  inline ::naothmessages::Pose2D* mutable_positiononfield();
  inline ::naothmessages::Pose2D* release_positiononfield();
  
  // optional .naothmessages.PlayerModel opponent = 8;
  inline bool has_opponent() const;
  inline void clear_opponent();
  static const int kOpponentFieldNumber = 8;
  inline const ::naothmessages::PlayerModel& opponent() const;
  inline ::naothmessages::PlayerModel* mutable_opponent();
  inline ::naothmessages::PlayerModel* release_opponent();
  
  // optional bool isFallenDown = 9 [default = false];
  inline bool has_isfallendown() const;
  inline void clear_isfallendown();
  static const int kIsFallenDownFieldNumber = 9;
  inline bool isfallendown() const;
  inline void set_isfallendown(bool value);
  
  // optional double timeToBall = 10;
  inline bool has_timetoball() const;
  inline void clear_timetoball();
  static const int kTimeToBallFieldNumber = 10;
  inline double timetoball() const;
  inline void set_timetoball(double value);
  
  // optional string bodyID = 11;
  inline bool has_bodyid() const;
  inline void clear_bodyid();
  static const int kBodyIDFieldNumber = 11;
  inline const ::std::string& bodyid() const;
  inline void set_bodyid(const ::std::string& value);
  inline void set_bodyid(const char* value);
  inline void set_bodyid(const char* value, size_t size);
  inline ::std::string* mutable_bodyid();
  inline ::std::string* release_bodyid();
  
  // @@protoc_insertion_point(class_scope:naothmessages.TeamCommMessage)
 private:
  inline void set_has_playernumber();
  inline void clear_has_playernumber();
  inline void set_has_teamnumber();
  inline void clear_has_teamnumber();
  inline void set_has_wasstriker();
  inline void clear_has_wasstriker();
  inline void set_has_ispenalized();
  inline void clear_has_ispenalized();
  inline void set_has_timesinceballwasseen();
  inline void clear_has_timesinceballwasseen();
  inline void set_has_ballposition();
  inline void clear_has_ballposition();
  inline void set_has_positiononfield();
  inline void clear_has_positiononfield();
  inline void set_has_opponent();
  inline void clear_has_opponent();
  inline void set_has_isfallendown();
  inline void clear_has_isfallendown();
  inline void set_has_timetoball();
  inline void clear_has_timetoball();
  inline void set_has_bodyid();
  inline void clear_has_bodyid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 playernumber_;
  ::google::protobuf::int32 teamnumber_;
  double timesinceballwasseen_;
  ::naothmessages::DoubleVector2* ballposition_;
  ::naothmessages::Pose2D* positiononfield_;
  ::naothmessages::PlayerModel* opponent_;
  double timetoball_;
  ::std::string* bodyid_;
  bool wasstriker_;
  bool ispenalized_;
  bool isfallendown_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static TeamCommMessage* default_instance_;
};
// -------------------------------------------------------------------

class StopwatchItem : public ::google::protobuf::Message {
 public:
  StopwatchItem();
  virtual ~StopwatchItem();
  
  StopwatchItem(const StopwatchItem& from);
  
  inline StopwatchItem& operator=(const StopwatchItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopwatchItem& default_instance();
  
  void Swap(StopwatchItem* other);
  
  // implements Message ----------------------------------------------
  
  StopwatchItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopwatchItem& from);
  void MergeFrom(const StopwatchItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required int32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.StopwatchItem)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_time();
  inline void clear_has_time();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static StopwatchItem* default_instance_;
};
// -------------------------------------------------------------------

class Stopwatches : public ::google::protobuf::Message {
 public:
  Stopwatches();
  virtual ~Stopwatches();
  
  Stopwatches(const Stopwatches& from);
  
  inline Stopwatches& operator=(const Stopwatches& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stopwatches& default_instance();
  
  void Swap(Stopwatches* other);
  
  // implements Message ----------------------------------------------
  
  Stopwatches* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stopwatches& from);
  void MergeFrom(const Stopwatches& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.StopwatchItem stopwatches = 1;
  inline int stopwatches_size() const;
  inline void clear_stopwatches();
  static const int kStopwatchesFieldNumber = 1;
  inline const ::naothmessages::StopwatchItem& stopwatches(int index) const;
  inline ::naothmessages::StopwatchItem* mutable_stopwatches(int index);
  inline ::naothmessages::StopwatchItem* add_stopwatches();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::StopwatchItem >&
      stopwatches() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::StopwatchItem >*
      mutable_stopwatches();
  
  // @@protoc_insertion_point(class_scope:naothmessages.Stopwatches)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::StopwatchItem > stopwatches_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static Stopwatches* default_instance_;
};
// -------------------------------------------------------------------

class PlotItem : public ::google::protobuf::Message {
 public:
  PlotItem();
  virtual ~PlotItem();
  
  PlotItem(const PlotItem& from);
  
  inline PlotItem& operator=(const PlotItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlotItem& default_instance();
  
  void Swap(PlotItem* other);
  
  // implements Message ----------------------------------------------
  
  PlotItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlotItem& from);
  void MergeFrom(const PlotItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PlotItem_PlotType PlotType;
  static const PlotType Default = PlotItem_PlotType_Default;
  static const PlotType Plot2D = PlotItem_PlotType_Plot2D;
  static const PlotType Origin2D = PlotItem_PlotType_Origin2D;
  static inline bool PlotType_IsValid(int value) {
    return PlotItem_PlotType_IsValid(value);
  }
  static const PlotType PlotType_MIN =
    PlotItem_PlotType_PlotType_MIN;
  static const PlotType PlotType_MAX =
    PlotItem_PlotType_PlotType_MAX;
  static const int PlotType_ARRAYSIZE =
    PlotItem_PlotType_PlotType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PlotType_descriptor() {
    return PlotItem_PlotType_descriptor();
  }
  static inline const ::std::string& PlotType_Name(PlotType value) {
    return PlotItem_PlotType_Name(value);
  }
  static inline bool PlotType_Parse(const ::std::string& name,
      PlotType* value) {
    return PlotItem_PlotType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.PlotItem.PlotType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::naothmessages::PlotItem_PlotType type() const;
  inline void set_type(::naothmessages::PlotItem_PlotType value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional double value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline double value() const;
  inline void set_value(double value);
  
  // optional double x = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline double x() const;
  inline void set_x(double value);
  
  // optional double y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline double y() const;
  inline void set_y(double value);
  
  // optional double rotation = 6;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 6;
  inline double rotation() const;
  inline void set_rotation(double value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.PlotItem)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  double value_;
  double x_;
  double y_;
  double rotation_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static PlotItem* default_instance_;
};
// -------------------------------------------------------------------

class PlotStroke2D : public ::google::protobuf::Message {
 public:
  PlotStroke2D();
  virtual ~PlotStroke2D();
  
  PlotStroke2D(const PlotStroke2D& from);
  
  inline PlotStroke2D& operator=(const PlotStroke2D& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlotStroke2D& default_instance();
  
  void Swap(PlotStroke2D* other);
  
  // implements Message ----------------------------------------------
  
  PlotStroke2D* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlotStroke2D& from);
  void MergeFrom(const PlotStroke2D& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .naothmessages.DoubleVector2 points = 1;
  inline int points_size() const;
  inline void clear_points();
  static const int kPointsFieldNumber = 1;
  inline const ::naothmessages::DoubleVector2& points(int index) const;
  inline ::naothmessages::DoubleVector2* mutable_points(int index);
  inline ::naothmessages::DoubleVector2* add_points();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
      points() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
      mutable_points();
  
  // @@protoc_insertion_point(class_scope:naothmessages.PlotStroke2D)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 > points_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static PlotStroke2D* default_instance_;
};
// -------------------------------------------------------------------

class Plots : public ::google::protobuf::Message {
 public:
  Plots();
  virtual ~Plots();
  
  Plots(const Plots& from);
  
  inline Plots& operator=(const Plots& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Plots& default_instance();
  
  void Swap(Plots* other);
  
  // implements Message ----------------------------------------------
  
  Plots* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Plots& from);
  void MergeFrom(const Plots& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.PlotItem plots = 1;
  inline int plots_size() const;
  inline void clear_plots();
  static const int kPlotsFieldNumber = 1;
  inline const ::naothmessages::PlotItem& plots(int index) const;
  inline ::naothmessages::PlotItem* mutable_plots(int index);
  inline ::naothmessages::PlotItem* add_plots();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotItem >&
      plots() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotItem >*
      mutable_plots();
  
  // repeated .naothmessages.PlotStroke2D plotstrokes = 2;
  inline int plotstrokes_size() const;
  inline void clear_plotstrokes();
  static const int kPlotstrokesFieldNumber = 2;
  inline const ::naothmessages::PlotStroke2D& plotstrokes(int index) const;
  inline ::naothmessages::PlotStroke2D* mutable_plotstrokes(int index);
  inline ::naothmessages::PlotStroke2D* add_plotstrokes();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotStroke2D >&
      plotstrokes() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotStroke2D >*
      mutable_plotstrokes();
  
  // @@protoc_insertion_point(class_scope:naothmessages.Plots)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotItem > plots_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotStroke2D > plotstrokes_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static Plots* default_instance_;
};
// -------------------------------------------------------------------

class XABSLSymbol : public ::google::protobuf::Message {
 public:
  XABSLSymbol();
  virtual ~XABSLSymbol();
  
  XABSLSymbol(const XABSLSymbol& from);
  
  inline XABSLSymbol& operator=(const XABSLSymbol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLSymbol& default_instance();
  
  void Swap(XABSLSymbol* other);
  
  // implements Message ----------------------------------------------
  
  XABSLSymbol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLSymbol& from);
  void MergeFrom(const XABSLSymbol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef XABSLSymbol_SymbolType SymbolType;
  static const SymbolType Decimal = XABSLSymbol_SymbolType_Decimal;
  static const SymbolType Boolean = XABSLSymbol_SymbolType_Boolean;
  static const SymbolType Enum = XABSLSymbol_SymbolType_Enum;
  static const SymbolType Unknown = XABSLSymbol_SymbolType_Unknown;
  static inline bool SymbolType_IsValid(int value) {
    return XABSLSymbol_SymbolType_IsValid(value);
  }
  static const SymbolType SymbolType_MIN =
    XABSLSymbol_SymbolType_SymbolType_MIN;
  static const SymbolType SymbolType_MAX =
    XABSLSymbol_SymbolType_SymbolType_MAX;
  static const int SymbolType_ARRAYSIZE =
    XABSLSymbol_SymbolType_SymbolType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SymbolType_descriptor() {
    return XABSLSymbol_SymbolType_descriptor();
  }
  static inline const ::std::string& SymbolType_Name(SymbolType value) {
    return XABSLSymbol_SymbolType_Name(value);
  }
  static inline bool SymbolType_Parse(const ::std::string& name,
      SymbolType* value) {
    return XABSLSymbol_SymbolType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1 [default = -1];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // required .naothmessages.XABSLSymbol.SymbolType type = 2 [default = Unknown];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::naothmessages::XABSLSymbol_SymbolType type() const;
  inline void set_type(::naothmessages::XABSLSymbol_SymbolType value);
  
  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional double decimalValue = 11;
  inline bool has_decimalvalue() const;
  inline void clear_decimalvalue();
  static const int kDecimalValueFieldNumber = 11;
  inline double decimalvalue() const;
  inline void set_decimalvalue(double value);
  
  // optional bool boolValue = 12;
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 12;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);
  
  // optional int32 enumValue = 13;
  inline bool has_enumvalue() const;
  inline void clear_enumvalue();
  static const int kEnumValueFieldNumber = 13;
  inline ::google::protobuf::int32 enumvalue() const;
  inline void set_enumvalue(::google::protobuf::int32 value);
  
  // optional int32 enumTypeId = 14;
  inline bool has_enumtypeid() const;
  inline void clear_enumtypeid();
  static const int kEnumTypeIdFieldNumber = 14;
  inline ::google::protobuf::int32 enumtypeid() const;
  inline void set_enumtypeid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLSymbol)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_decimalvalue();
  inline void clear_has_decimalvalue();
  inline void set_has_boolvalue();
  inline void clear_has_boolvalue();
  inline void set_has_enumvalue();
  inline void clear_has_enumvalue();
  inline void set_has_enumtypeid();
  inline void clear_has_enumtypeid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 id_;
  int type_;
  ::std::string* name_;
  double decimalvalue_;
  bool boolvalue_;
  ::google::protobuf::int32 enumvalue_;
  ::google::protobuf::int32 enumtypeid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLSymbol* default_instance_;
};
// -------------------------------------------------------------------

class XABSLActiveOptionSparse : public ::google::protobuf::Message {
 public:
  XABSLActiveOptionSparse();
  virtual ~XABSLActiveOptionSparse();
  
  XABSLActiveOptionSparse(const XABSLActiveOptionSparse& from);
  
  inline XABSLActiveOptionSparse& operator=(const XABSLActiveOptionSparse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLActiveOptionSparse& default_instance();
  
  void Swap(XABSLActiveOptionSparse* other);
  
  // implements Message ----------------------------------------------
  
  XABSLActiveOptionSparse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLActiveOptionSparse& from);
  void MergeFrom(const XABSLActiveOptionSparse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1 [default = -1];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int64 timeOfExecution = 3 [default = 0];
  inline bool has_timeofexecution() const;
  inline void clear_timeofexecution();
  static const int kTimeOfExecutionFieldNumber = 3;
  inline ::google::protobuf::int64 timeofexecution() const;
  inline void set_timeofexecution(::google::protobuf::int64 value);
  
  // optional int32 activeState = 4;
  inline bool has_activestate() const;
  inline void clear_activestate();
  static const int kActiveStateFieldNumber = 4;
  inline ::google::protobuf::int32 activestate() const;
  inline void set_activestate(::google::protobuf::int32 value);
  
  // optional int64 stateTime = 5;
  inline bool has_statetime() const;
  inline void clear_statetime();
  static const int kStateTimeFieldNumber = 5;
  inline ::google::protobuf::int64 statetime() const;
  inline void set_statetime(::google::protobuf::int64 value);
  
  // repeated double decimalParameters = 6;
  inline int decimalparameters_size() const;
  inline void clear_decimalparameters();
  static const int kDecimalParametersFieldNumber = 6;
  inline double decimalparameters(int index) const;
  inline void set_decimalparameters(int index, double value);
  inline void add_decimalparameters(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      decimalparameters() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_decimalparameters();
  
  // repeated bool booleanParameters = 7;
  inline int booleanparameters_size() const;
  inline void clear_booleanparameters();
  static const int kBooleanParametersFieldNumber = 7;
  inline bool booleanparameters(int index) const;
  inline void set_booleanparameters(int index, bool value);
  inline void add_booleanparameters(bool value);
  inline const ::google::protobuf::RepeatedField< bool >&
      booleanparameters() const;
  inline ::google::protobuf::RepeatedField< bool >*
      mutable_booleanparameters();
  
  // repeated int32 enumeratedParameters = 8;
  inline int enumeratedparameters_size() const;
  inline void clear_enumeratedparameters();
  static const int kEnumeratedParametersFieldNumber = 8;
  inline ::google::protobuf::int32 enumeratedparameters(int index) const;
  inline void set_enumeratedparameters(int index, ::google::protobuf::int32 value);
  inline void add_enumeratedparameters(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      enumeratedparameters() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_enumeratedparameters();
  
  // repeated .naothmessages.XABSLActionSparse activeSubActions = 9;
  inline int activesubactions_size() const;
  inline void clear_activesubactions();
  static const int kActiveSubActionsFieldNumber = 9;
  inline const ::naothmessages::XABSLActionSparse& activesubactions(int index) const;
  inline ::naothmessages::XABSLActionSparse* mutable_activesubactions(int index);
  inline ::naothmessages::XABSLActionSparse* add_activesubactions();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLActionSparse >&
      activesubactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLActionSparse >*
      mutable_activesubactions();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLActiveOptionSparse)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_timeofexecution();
  inline void clear_has_timeofexecution();
  inline void set_has_activestate();
  inline void clear_has_activestate();
  inline void set_has_statetime();
  inline void clear_has_statetime();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int64 timeofexecution_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 activestate_;
  ::google::protobuf::int64 statetime_;
  ::google::protobuf::RepeatedField< double > decimalparameters_;
  ::google::protobuf::RepeatedField< bool > booleanparameters_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > enumeratedparameters_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLActionSparse > activesubactions_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLActiveOptionSparse* default_instance_;
};
// -------------------------------------------------------------------

class XABSLActionSparse : public ::google::protobuf::Message {
 public:
  XABSLActionSparse();
  virtual ~XABSLActionSparse();
  
  XABSLActionSparse(const XABSLActionSparse& from);
  
  inline XABSLActionSparse& operator=(const XABSLActionSparse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLActionSparse& default_instance();
  
  void Swap(XABSLActionSparse* other);
  
  // implements Message ----------------------------------------------
  
  XABSLActionSparse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLActionSparse& from);
  void MergeFrom(const XABSLActionSparse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef XABSLActionSparse_ActionType ActionType;
  static const ActionType Option = XABSLActionSparse_ActionType_Option;
  static const ActionType BasicBehavior = XABSLActionSparse_ActionType_BasicBehavior;
  static const ActionType SymbolAssignement = XABSLActionSparse_ActionType_SymbolAssignement;
  static const ActionType Unknown = XABSLActionSparse_ActionType_Unknown;
  static inline bool ActionType_IsValid(int value) {
    return XABSLActionSparse_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    XABSLActionSparse_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    XABSLActionSparse_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    XABSLActionSparse_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return XABSLActionSparse_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return XABSLActionSparse_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return XABSLActionSparse_ActionType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.XABSLActionSparse.ActionType type = 2 [default = Unknown];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::naothmessages::XABSLActionSparse_ActionType type() const;
  inline void set_type(::naothmessages::XABSLActionSparse_ActionType value);
  
  // optional .naothmessages.XABSLSymbol symbol = 3;
  inline bool has_symbol() const;
  inline void clear_symbol();
  static const int kSymbolFieldNumber = 3;
  inline const ::naothmessages::XABSLSymbol& symbol() const;
  inline ::naothmessages::XABSLSymbol* mutable_symbol();
  inline ::naothmessages::XABSLSymbol* release_symbol();
  
  // optional .naothmessages.XABSLActiveOptionSparse option = 4;
  inline bool has_option() const;
  inline void clear_option();
  static const int kOptionFieldNumber = 4;
  inline const ::naothmessages::XABSLActiveOptionSparse& option() const;
  inline ::naothmessages::XABSLActiveOptionSparse* mutable_option();
  inline ::naothmessages::XABSLActiveOptionSparse* release_option();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLActionSparse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_symbol();
  inline void clear_has_symbol();
  inline void set_has_option();
  inline void clear_has_option();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::XABSLSymbol* symbol_;
  ::naothmessages::XABSLActiveOptionSparse* option_;
  int type_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLActionSparse* default_instance_;
};
// -------------------------------------------------------------------

class SymbolValueList_DoubleSymbol : public ::google::protobuf::Message {
 public:
  SymbolValueList_DoubleSymbol();
  virtual ~SymbolValueList_DoubleSymbol();
  
  SymbolValueList_DoubleSymbol(const SymbolValueList_DoubleSymbol& from);
  
  inline SymbolValueList_DoubleSymbol& operator=(const SymbolValueList_DoubleSymbol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolValueList_DoubleSymbol& default_instance();
  
  void Swap(SymbolValueList_DoubleSymbol* other);
  
  // implements Message ----------------------------------------------
  
  SymbolValueList_DoubleSymbol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolValueList_DoubleSymbol& from);
  void MergeFrom(const SymbolValueList_DoubleSymbol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1 [default = -1];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional double value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline double value() const;
  inline void set_value(double value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.SymbolValueList.DoubleSymbol)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  double value_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static SymbolValueList_DoubleSymbol* default_instance_;
};
// -------------------------------------------------------------------

class SymbolValueList_BooleanSymbol : public ::google::protobuf::Message {
 public:
  SymbolValueList_BooleanSymbol();
  virtual ~SymbolValueList_BooleanSymbol();
  
  SymbolValueList_BooleanSymbol(const SymbolValueList_BooleanSymbol& from);
  
  inline SymbolValueList_BooleanSymbol& operator=(const SymbolValueList_BooleanSymbol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolValueList_BooleanSymbol& default_instance();
  
  void Swap(SymbolValueList_BooleanSymbol* other);
  
  // implements Message ----------------------------------------------
  
  SymbolValueList_BooleanSymbol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolValueList_BooleanSymbol& from);
  void MergeFrom(const SymbolValueList_BooleanSymbol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1 [default = -1];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional bool value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline bool value() const;
  inline void set_value(bool value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.SymbolValueList.BooleanSymbol)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  bool value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static SymbolValueList_BooleanSymbol* default_instance_;
};
// -------------------------------------------------------------------

class SymbolValueList_EnumSymbol : public ::google::protobuf::Message {
 public:
  SymbolValueList_EnumSymbol();
  virtual ~SymbolValueList_EnumSymbol();
  
  SymbolValueList_EnumSymbol(const SymbolValueList_EnumSymbol& from);
  
  inline SymbolValueList_EnumSymbol& operator=(const SymbolValueList_EnumSymbol& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolValueList_EnumSymbol& default_instance();
  
  void Swap(SymbolValueList_EnumSymbol* other);
  
  // implements Message ----------------------------------------------
  
  SymbolValueList_EnumSymbol* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolValueList_EnumSymbol& from);
  void MergeFrom(const SymbolValueList_EnumSymbol& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1 [default = -1];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int32 value = 13;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 13;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // optional int32 typeId = 14;
  inline bool has_typeid_() const;
  inline void clear_typeid_();
  static const int kTypeIdFieldNumber = 14;
  inline ::google::protobuf::int32 typeid_() const;
  inline void set_typeid_(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.SymbolValueList.EnumSymbol)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_typeid_();
  inline void clear_has_typeid_();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 value_;
  ::google::protobuf::int32 typeid__;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static SymbolValueList_EnumSymbol* default_instance_;
};
// -------------------------------------------------------------------

class SymbolValueList : public ::google::protobuf::Message {
 public:
  SymbolValueList();
  virtual ~SymbolValueList();
  
  SymbolValueList(const SymbolValueList& from);
  
  inline SymbolValueList& operator=(const SymbolValueList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SymbolValueList& default_instance();
  
  void Swap(SymbolValueList* other);
  
  // implements Message ----------------------------------------------
  
  SymbolValueList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SymbolValueList& from);
  void MergeFrom(const SymbolValueList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef SymbolValueList_DoubleSymbol DoubleSymbol;
  typedef SymbolValueList_BooleanSymbol BooleanSymbol;
  typedef SymbolValueList_EnumSymbol EnumSymbol;
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.SymbolValueList.DoubleSymbol decimal = 1;
  inline int decimal_size() const;
  inline void clear_decimal();
  static const int kDecimalFieldNumber = 1;
  inline const ::naothmessages::SymbolValueList_DoubleSymbol& decimal(int index) const;
  inline ::naothmessages::SymbolValueList_DoubleSymbol* mutable_decimal(int index);
  inline ::naothmessages::SymbolValueList_DoubleSymbol* add_decimal();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_DoubleSymbol >&
      decimal() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_DoubleSymbol >*
      mutable_decimal();
  
  // repeated .naothmessages.SymbolValueList.BooleanSymbol boolean = 2;
  inline int boolean_size() const;
  inline void clear_boolean();
  static const int kBooleanFieldNumber = 2;
  inline const ::naothmessages::SymbolValueList_BooleanSymbol& boolean(int index) const;
  inline ::naothmessages::SymbolValueList_BooleanSymbol* mutable_boolean(int index);
  inline ::naothmessages::SymbolValueList_BooleanSymbol* add_boolean();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_BooleanSymbol >&
      boolean() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_BooleanSymbol >*
      mutable_boolean();
  
  // repeated .naothmessages.SymbolValueList.EnumSymbol enumerated = 3;
  inline int enumerated_size() const;
  inline void clear_enumerated();
  static const int kEnumeratedFieldNumber = 3;
  inline const ::naothmessages::SymbolValueList_EnumSymbol& enumerated(int index) const;
  inline ::naothmessages::SymbolValueList_EnumSymbol* mutable_enumerated(int index);
  inline ::naothmessages::SymbolValueList_EnumSymbol* add_enumerated();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_EnumSymbol >&
      enumerated() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_EnumSymbol >*
      mutable_enumerated();
  
  // @@protoc_insertion_point(class_scope:naothmessages.SymbolValueList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_DoubleSymbol > decimal_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_BooleanSymbol > boolean_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_EnumSymbol > enumerated_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static SymbolValueList* default_instance_;
};
// -------------------------------------------------------------------

class BehaviorStatusSparse : public ::google::protobuf::Message {
 public:
  BehaviorStatusSparse();
  virtual ~BehaviorStatusSparse();
  
  BehaviorStatusSparse(const BehaviorStatusSparse& from);
  
  inline BehaviorStatusSparse& operator=(const BehaviorStatusSparse& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorStatusSparse& default_instance();
  
  void Swap(BehaviorStatusSparse* other);
  
  // implements Message ----------------------------------------------
  
  BehaviorStatusSparse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BehaviorStatusSparse& from);
  void MergeFrom(const BehaviorStatusSparse& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string agent = 1;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 1;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const char* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  
  // repeated .naothmessages.XABSLActionSparse activeRootActions = 2;
  inline int activerootactions_size() const;
  inline void clear_activerootactions();
  static const int kActiveRootActionsFieldNumber = 2;
  inline const ::naothmessages::XABSLActionSparse& activerootactions(int index) const;
  inline ::naothmessages::XABSLActionSparse* mutable_activerootactions(int index);
  inline ::naothmessages::XABSLActionSparse* add_activerootactions();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLActionSparse >&
      activerootactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLActionSparse >*
      mutable_activerootactions();
  
  // optional .naothmessages.SymbolValueList inputSymbolList = 10;
  inline bool has_inputsymbollist() const;
  inline void clear_inputsymbollist();
  static const int kInputSymbolListFieldNumber = 10;
  inline const ::naothmessages::SymbolValueList& inputsymbollist() const;
  inline ::naothmessages::SymbolValueList* mutable_inputsymbollist();
  inline ::naothmessages::SymbolValueList* release_inputsymbollist();
  
  // optional .naothmessages.SymbolValueList outputSymbolList = 11;
  inline bool has_outputsymbollist() const;
  inline void clear_outputsymbollist();
  static const int kOutputSymbolListFieldNumber = 11;
  inline const ::naothmessages::SymbolValueList& outputsymbollist() const;
  inline ::naothmessages::SymbolValueList* mutable_outputsymbollist();
  inline ::naothmessages::SymbolValueList* release_outputsymbollist();
  
  // optional uint32 frameNumber = 5;
  inline bool has_framenumber() const;
  inline void clear_framenumber();
  static const int kFrameNumberFieldNumber = 5;
  inline ::google::protobuf::uint32 framenumber() const;
  inline void set_framenumber(::google::protobuf::uint32 value);
  
  // optional string errorMessage = 6;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 6;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  
  // @@protoc_insertion_point(class_scope:naothmessages.BehaviorStatusSparse)
 private:
  inline void set_has_agent();
  inline void clear_has_agent();
  inline void set_has_inputsymbollist();
  inline void clear_has_inputsymbollist();
  inline void set_has_outputsymbollist();
  inline void clear_has_outputsymbollist();
  inline void set_has_framenumber();
  inline void clear_has_framenumber();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* agent_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLActionSparse > activerootactions_;
  ::naothmessages::SymbolValueList* inputsymbollist_;
  ::naothmessages::SymbolValueList* outputsymbollist_;
  ::std::string* errormessage_;
  ::google::protobuf::uint32 framenumber_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static BehaviorStatusSparse* default_instance_;
};
// -------------------------------------------------------------------

class XABSLBehavior_EnumType_Element : public ::google::protobuf::Message {
 public:
  XABSLBehavior_EnumType_Element();
  virtual ~XABSLBehavior_EnumType_Element();
  
  XABSLBehavior_EnumType_Element(const XABSLBehavior_EnumType_Element& from);
  
  inline XABSLBehavior_EnumType_Element& operator=(const XABSLBehavior_EnumType_Element& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLBehavior_EnumType_Element& default_instance();
  
  void Swap(XABSLBehavior_EnumType_Element* other);
  
  // implements Message ----------------------------------------------
  
  XABSLBehavior_EnumType_Element* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLBehavior_EnumType_Element& from);
  void MergeFrom(const XABSLBehavior_EnumType_Element& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLBehavior.EnumType.Element)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::int32 value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLBehavior_EnumType_Element* default_instance_;
};
// -------------------------------------------------------------------

class XABSLBehavior_EnumType : public ::google::protobuf::Message {
 public:
  XABSLBehavior_EnumType();
  virtual ~XABSLBehavior_EnumType();
  
  XABSLBehavior_EnumType(const XABSLBehavior_EnumType& from);
  
  inline XABSLBehavior_EnumType& operator=(const XABSLBehavior_EnumType& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLBehavior_EnumType& default_instance();
  
  void Swap(XABSLBehavior_EnumType* other);
  
  // implements Message ----------------------------------------------
  
  XABSLBehavior_EnumType* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLBehavior_EnumType& from);
  void MergeFrom(const XABSLBehavior_EnumType& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef XABSLBehavior_EnumType_Element Element;
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .naothmessages.XABSLBehavior.EnumType.Element elements = 2;
  inline int elements_size() const;
  inline void clear_elements();
  static const int kElementsFieldNumber = 2;
  inline const ::naothmessages::XABSLBehavior_EnumType_Element& elements(int index) const;
  inline ::naothmessages::XABSLBehavior_EnumType_Element* mutable_elements(int index);
  inline ::naothmessages::XABSLBehavior_EnumType_Element* add_elements();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_EnumType_Element >&
      elements() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_EnumType_Element >*
      mutable_elements();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLBehavior.EnumType)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_EnumType_Element > elements_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLBehavior_EnumType* default_instance_;
};
// -------------------------------------------------------------------

class XABSLBehavior_Option_State : public ::google::protobuf::Message {
 public:
  XABSLBehavior_Option_State();
  virtual ~XABSLBehavior_Option_State();
  
  XABSLBehavior_Option_State(const XABSLBehavior_Option_State& from);
  
  inline XABSLBehavior_Option_State& operator=(const XABSLBehavior_Option_State& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLBehavior_Option_State& default_instance();
  
  void Swap(XABSLBehavior_Option_State* other);
  
  // implements Message ----------------------------------------------
  
  XABSLBehavior_Option_State* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLBehavior_Option_State& from);
  void MergeFrom(const XABSLBehavior_Option_State& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional bool target = 2;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 2;
  inline bool target() const;
  inline void set_target(bool value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLBehavior.Option.State)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_target();
  inline void clear_has_target();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  bool target_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLBehavior_Option_State* default_instance_;
};
// -------------------------------------------------------------------

class XABSLBehavior_Option : public ::google::protobuf::Message {
 public:
  XABSLBehavior_Option();
  virtual ~XABSLBehavior_Option();
  
  XABSLBehavior_Option(const XABSLBehavior_Option& from);
  
  inline XABSLBehavior_Option& operator=(const XABSLBehavior_Option& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLBehavior_Option& default_instance();
  
  void Swap(XABSLBehavior_Option* other);
  
  // implements Message ----------------------------------------------
  
  XABSLBehavior_Option* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLBehavior_Option& from);
  void MergeFrom(const XABSLBehavior_Option& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef XABSLBehavior_Option_State State;
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .naothmessages.XABSLBehavior.Option.State states = 3;
  inline int states_size() const;
  inline void clear_states();
  static const int kStatesFieldNumber = 3;
  inline const ::naothmessages::XABSLBehavior_Option_State& states(int index) const;
  inline ::naothmessages::XABSLBehavior_Option_State* mutable_states(int index);
  inline ::naothmessages::XABSLBehavior_Option_State* add_states();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Option_State >&
      states() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Option_State >*
      mutable_states();
  
  // repeated .naothmessages.XABSLSymbol parameters = 2;
  inline int parameters_size() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 2;
  inline const ::naothmessages::XABSLSymbol& parameters(int index) const;
  inline ::naothmessages::XABSLSymbol* mutable_parameters(int index);
  inline ::naothmessages::XABSLSymbol* add_parameters();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLSymbol >&
      parameters() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLSymbol >*
      mutable_parameters();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLBehavior.Option)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Option_State > states_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLSymbol > parameters_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLBehavior_Option* default_instance_;
};
// -------------------------------------------------------------------

class XABSLBehavior_Agent : public ::google::protobuf::Message {
 public:
  XABSLBehavior_Agent();
  virtual ~XABSLBehavior_Agent();
  
  XABSLBehavior_Agent(const XABSLBehavior_Agent& from);
  
  inline XABSLBehavior_Agent& operator=(const XABSLBehavior_Agent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLBehavior_Agent& default_instance();
  
  void Swap(XABSLBehavior_Agent* other);
  
  // implements Message ----------------------------------------------
  
  XABSLBehavior_Agent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLBehavior_Agent& from);
  void MergeFrom(const XABSLBehavior_Agent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // required string rootOption = 2;
  inline bool has_rootoption() const;
  inline void clear_rootoption();
  static const int kRootOptionFieldNumber = 2;
  inline const ::std::string& rootoption() const;
  inline void set_rootoption(const ::std::string& value);
  inline void set_rootoption(const char* value);
  inline void set_rootoption(const char* value, size_t size);
  inline ::std::string* mutable_rootoption();
  inline ::std::string* release_rootoption();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLBehavior.Agent)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_rootoption();
  inline void clear_has_rootoption();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::std::string* rootoption_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLBehavior_Agent* default_instance_;
};
// -------------------------------------------------------------------

class XABSLBehavior : public ::google::protobuf::Message {
 public:
  XABSLBehavior();
  virtual ~XABSLBehavior();
  
  XABSLBehavior(const XABSLBehavior& from);
  
  inline XABSLBehavior& operator=(const XABSLBehavior& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLBehavior& default_instance();
  
  void Swap(XABSLBehavior* other);
  
  // implements Message ----------------------------------------------
  
  XABSLBehavior* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLBehavior& from);
  void MergeFrom(const XABSLBehavior& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef XABSLBehavior_EnumType EnumType;
  typedef XABSLBehavior_Option Option;
  typedef XABSLBehavior_Agent Agent;
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.XABSLBehavior.EnumType enumerations = 10;
  inline int enumerations_size() const;
  inline void clear_enumerations();
  static const int kEnumerationsFieldNumber = 10;
  inline const ::naothmessages::XABSLBehavior_EnumType& enumerations(int index) const;
  inline ::naothmessages::XABSLBehavior_EnumType* mutable_enumerations(int index);
  inline ::naothmessages::XABSLBehavior_EnumType* add_enumerations();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_EnumType >&
      enumerations() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_EnumType >*
      mutable_enumerations();
  
  // repeated .naothmessages.XABSLBehavior.Option options = 11;
  inline int options_size() const;
  inline void clear_options();
  static const int kOptionsFieldNumber = 11;
  inline const ::naothmessages::XABSLBehavior_Option& options(int index) const;
  inline ::naothmessages::XABSLBehavior_Option* mutable_options(int index);
  inline ::naothmessages::XABSLBehavior_Option* add_options();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Option >&
      options() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Option >*
      mutable_options();
  
  // repeated .naothmessages.XABSLBehavior.Agent agents = 12;
  inline int agents_size() const;
  inline void clear_agents();
  static const int kAgentsFieldNumber = 12;
  inline const ::naothmessages::XABSLBehavior_Agent& agents(int index) const;
  inline ::naothmessages::XABSLBehavior_Agent* mutable_agents(int index);
  inline ::naothmessages::XABSLBehavior_Agent* add_agents();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Agent >&
      agents() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Agent >*
      mutable_agents();
  
  // optional .naothmessages.SymbolValueList inputSymbolList = 13;
  inline bool has_inputsymbollist() const;
  inline void clear_inputsymbollist();
  static const int kInputSymbolListFieldNumber = 13;
  inline const ::naothmessages::SymbolValueList& inputsymbollist() const;
  inline ::naothmessages::SymbolValueList* mutable_inputsymbollist();
  inline ::naothmessages::SymbolValueList* release_inputsymbollist();
  
  // optional .naothmessages.SymbolValueList outputSymbolList = 14;
  inline bool has_outputsymbollist() const;
  inline void clear_outputsymbollist();
  static const int kOutputSymbolListFieldNumber = 14;
  inline const ::naothmessages::SymbolValueList& outputsymbollist() const;
  inline ::naothmessages::SymbolValueList* mutable_outputsymbollist();
  inline ::naothmessages::SymbolValueList* release_outputsymbollist();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLBehavior)
 private:
  inline void set_has_inputsymbollist();
  inline void clear_has_inputsymbollist();
  inline void set_has_outputsymbollist();
  inline void clear_has_outputsymbollist();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_EnumType > enumerations_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Option > options_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Agent > agents_;
  ::naothmessages::SymbolValueList* inputsymbollist_;
  ::naothmessages::SymbolValueList* outputsymbollist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLBehavior* default_instance_;
};
// -------------------------------------------------------------------

class XABSLParameter : public ::google::protobuf::Message {
 public:
  XABSLParameter();
  virtual ~XABSLParameter();
  
  XABSLParameter(const XABSLParameter& from);
  
  inline XABSLParameter& operator=(const XABSLParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLParameter& default_instance();
  
  void Swap(XABSLParameter* other);
  
  // implements Message ----------------------------------------------
  
  XABSLParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLParameter& from);
  void MergeFrom(const XABSLParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef XABSLParameter_ParamType ParamType;
  static const ParamType Decimal = XABSLParameter_ParamType_Decimal;
  static const ParamType Boolean = XABSLParameter_ParamType_Boolean;
  static const ParamType Enum = XABSLParameter_ParamType_Enum;
  static const ParamType Unknown = XABSLParameter_ParamType_Unknown;
  static inline bool ParamType_IsValid(int value) {
    return XABSLParameter_ParamType_IsValid(value);
  }
  static const ParamType ParamType_MIN =
    XABSLParameter_ParamType_ParamType_MIN;
  static const ParamType ParamType_MAX =
    XABSLParameter_ParamType_ParamType_MAX;
  static const int ParamType_ARRAYSIZE =
    XABSLParameter_ParamType_ParamType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ParamType_descriptor() {
    return XABSLParameter_ParamType_descriptor();
  }
  static inline const ::std::string& ParamType_Name(ParamType value) {
    return XABSLParameter_ParamType_Name(value);
  }
  static inline bool ParamType_Parse(const ::std::string& name,
      ParamType* value) {
    return XABSLParameter_ParamType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1 [default = "unknown"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional .naothmessages.XABSLParameter.ParamType type = 2 [default = Unknown];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::naothmessages::XABSLParameter_ParamType type() const;
  inline void set_type(::naothmessages::XABSLParameter_ParamType value);
  
  // optional double decimalValue = 3;
  inline bool has_decimalvalue() const;
  inline void clear_decimalvalue();
  static const int kDecimalValueFieldNumber = 3;
  inline double decimalvalue() const;
  inline void set_decimalvalue(double value);
  
  // optional bool boolValue = 4;
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 4;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);
  
  // optional string enumValue = 5;
  inline bool has_enumvalue() const;
  inline void clear_enumvalue();
  static const int kEnumValueFieldNumber = 5;
  inline const ::std::string& enumvalue() const;
  inline void set_enumvalue(const ::std::string& value);
  inline void set_enumvalue(const char* value);
  inline void set_enumvalue(const char* value, size_t size);
  inline ::std::string* mutable_enumvalue();
  inline ::std::string* release_enumvalue();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLParameter)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_decimalvalue();
  inline void clear_has_decimalvalue();
  inline void set_has_boolvalue();
  inline void clear_has_boolvalue();
  inline void set_has_enumvalue();
  inline void clear_has_enumvalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  double decimalvalue_;
  int type_;
  bool boolvalue_;
  ::std::string* enumvalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLParameter* default_instance_;
};
// -------------------------------------------------------------------

class XABSLAction : public ::google::protobuf::Message {
 public:
  XABSLAction();
  virtual ~XABSLAction();
  
  XABSLAction(const XABSLAction& from);
  
  inline XABSLAction& operator=(const XABSLAction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLAction& default_instance();
  
  void Swap(XABSLAction* other);
  
  // implements Message ----------------------------------------------
  
  XABSLAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLAction& from);
  void MergeFrom(const XABSLAction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef XABSLAction_ActionType ActionType;
  static const ActionType Option = XABSLAction_ActionType_Option;
  static const ActionType BasicBehavior = XABSLAction_ActionType_BasicBehavior;
  static const ActionType DecimalOutputSymbol = XABSLAction_ActionType_DecimalOutputSymbol;
  static const ActionType BooleanOutputSymbol = XABSLAction_ActionType_BooleanOutputSymbol;
  static const ActionType EnumOutputSymbol = XABSLAction_ActionType_EnumOutputSymbol;
  static const ActionType Unknown = XABSLAction_ActionType_Unknown;
  static inline bool ActionType_IsValid(int value) {
    return XABSLAction_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    XABSLAction_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    XABSLAction_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    XABSLAction_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return XABSLAction_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return XABSLAction_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return XABSLAction_ActionType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .naothmessages.XABSLAction.ActionType type = 1 [default = Unknown];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::naothmessages::XABSLAction_ActionType type() const;
  inline void set_type(::naothmessages::XABSLAction_ActionType value);
  
  // optional string name = 2 [default = "unknown"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional int64 timeOfExecution = 3 [default = 0];
  inline bool has_timeofexecution() const;
  inline void clear_timeofexecution();
  static const int kTimeOfExecutionFieldNumber = 3;
  inline ::google::protobuf::int64 timeofexecution() const;
  inline void set_timeofexecution(::google::protobuf::int64 value);
  
  // optional string activeState = 4;
  inline bool has_activestate() const;
  inline void clear_activestate();
  static const int kActiveStateFieldNumber = 4;
  inline const ::std::string& activestate() const;
  inline void set_activestate(const ::std::string& value);
  inline void set_activestate(const char* value);
  inline void set_activestate(const char* value, size_t size);
  inline ::std::string* mutable_activestate();
  inline ::std::string* release_activestate();
  
  // optional int64 stateTime = 5;
  inline bool has_statetime() const;
  inline void clear_statetime();
  static const int kStateTimeFieldNumber = 5;
  inline ::google::protobuf::int64 statetime() const;
  inline void set_statetime(::google::protobuf::int64 value);
  
  // repeated .naothmessages.XABSLParameter parameters = 6;
  inline int parameters_size() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 6;
  inline const ::naothmessages::XABSLParameter& parameters(int index) const;
  inline ::naothmessages::XABSLParameter* mutable_parameters(int index);
  inline ::naothmessages::XABSLParameter* add_parameters();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
      parameters() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
      mutable_parameters();
  
  // repeated .naothmessages.XABSLAction activeSubActions = 7;
  inline int activesubactions_size() const;
  inline void clear_activesubactions();
  static const int kActiveSubActionsFieldNumber = 7;
  inline const ::naothmessages::XABSLAction& activesubactions(int index) const;
  inline ::naothmessages::XABSLAction* mutable_activesubactions(int index);
  inline ::naothmessages::XABSLAction* add_activesubactions();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >&
      activesubactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >*
      mutable_activesubactions();
  
  // optional double decimalValue = 8;
  inline bool has_decimalvalue() const;
  inline void clear_decimalvalue();
  static const int kDecimalValueFieldNumber = 8;
  inline double decimalvalue() const;
  inline void set_decimalvalue(double value);
  
  // optional bool boolValue = 9;
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 9;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);
  
  // optional string enumValue = 10;
  inline bool has_enumvalue() const;
  inline void clear_enumvalue();
  static const int kEnumValueFieldNumber = 10;
  inline const ::std::string& enumvalue() const;
  inline void set_enumvalue(const ::std::string& value);
  inline void set_enumvalue(const char* value);
  inline void set_enumvalue(const char* value, size_t size);
  inline ::std::string* mutable_enumvalue();
  inline ::std::string* release_enumvalue();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLAction)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_timeofexecution();
  inline void clear_has_timeofexecution();
  inline void set_has_activestate();
  inline void clear_has_activestate();
  inline void set_has_statetime();
  inline void clear_has_statetime();
  inline void set_has_decimalvalue();
  inline void clear_has_decimalvalue();
  inline void set_has_boolvalue();
  inline void clear_has_boolvalue();
  inline void set_has_enumvalue();
  inline void clear_has_enumvalue();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int64 timeofexecution_;
  ::std::string* activestate_;
  ::google::protobuf::int64 statetime_;
  int type_;
  bool boolvalue_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter > parameters_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction > activesubactions_;
  double decimalvalue_;
  ::std::string* enumvalue_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static XABSLAction* default_instance_;
};
// -------------------------------------------------------------------

class BehaviorStatus : public ::google::protobuf::Message {
 public:
  BehaviorStatus();
  virtual ~BehaviorStatus();
  
  BehaviorStatus(const BehaviorStatus& from);
  
  inline BehaviorStatus& operator=(const BehaviorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorStatus& default_instance();
  
  void Swap(BehaviorStatus* other);
  
  // implements Message ----------------------------------------------
  
  BehaviorStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BehaviorStatus& from);
  void MergeFrom(const BehaviorStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string agent = 1;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 1;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const char* value, size_t size);
  inline ::std::string* mutable_agent();
  inline ::std::string* release_agent();
  
  // repeated .naothmessages.XABSLAction activeRootActions = 2;
  inline int activerootactions_size() const;
  inline void clear_activerootactions();
  static const int kActiveRootActionsFieldNumber = 2;
  inline const ::naothmessages::XABSLAction& activerootactions(int index) const;
  inline ::naothmessages::XABSLAction* mutable_activerootactions(int index);
  inline ::naothmessages::XABSLAction* add_activerootactions();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >&
      activerootactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >*
      mutable_activerootactions();
  
  // repeated .naothmessages.XABSLParameter inputSymbols = 3;
  inline int inputsymbols_size() const;
  inline void clear_inputsymbols();
  static const int kInputSymbolsFieldNumber = 3;
  inline const ::naothmessages::XABSLParameter& inputsymbols(int index) const;
  inline ::naothmessages::XABSLParameter* mutable_inputsymbols(int index);
  inline ::naothmessages::XABSLParameter* add_inputsymbols();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
      inputsymbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
      mutable_inputsymbols();
  
  // repeated .naothmessages.XABSLParameter outputSymbols = 4;
  inline int outputsymbols_size() const;
  inline void clear_outputsymbols();
  static const int kOutputSymbolsFieldNumber = 4;
  inline const ::naothmessages::XABSLParameter& outputsymbols(int index) const;
  inline ::naothmessages::XABSLParameter* mutable_outputsymbols(int index);
  inline ::naothmessages::XABSLParameter* add_outputsymbols();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
      outputsymbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
      mutable_outputsymbols();
  
  // optional uint32 frameNumber = 5;
  inline bool has_framenumber() const;
  inline void clear_framenumber();
  static const int kFrameNumberFieldNumber = 5;
  inline ::google::protobuf::uint32 framenumber() const;
  inline void set_framenumber(::google::protobuf::uint32 value);
  
  // optional string errorMessage = 6;
  inline bool has_errormessage() const;
  inline void clear_errormessage();
  static const int kErrorMessageFieldNumber = 6;
  inline const ::std::string& errormessage() const;
  inline void set_errormessage(const ::std::string& value);
  inline void set_errormessage(const char* value);
  inline void set_errormessage(const char* value, size_t size);
  inline ::std::string* mutable_errormessage();
  inline ::std::string* release_errormessage();
  
  // @@protoc_insertion_point(class_scope:naothmessages.BehaviorStatus)
 private:
  inline void set_has_agent();
  inline void clear_has_agent();
  inline void set_has_framenumber();
  inline void clear_has_framenumber();
  inline void set_has_errormessage();
  inline void clear_has_errormessage();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* agent_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction > activerootactions_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter > inputsymbols_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter > outputsymbols_;
  ::std::string* errormessage_;
  ::google::protobuf::uint32 framenumber_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static BehaviorStatus* default_instance_;
};
// -------------------------------------------------------------------

class Module : public ::google::protobuf::Message {
 public:
  Module();
  virtual ~Module();
  
  Module(const Module& from);
  
  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Module& default_instance();
  
  void Swap(Module* other);
  
  // implements Message ----------------------------------------------
  
  Module* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Module& from);
  void MergeFrom(const Module& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated string usedRepresentations = 2;
  inline int usedrepresentations_size() const;
  inline void clear_usedrepresentations();
  static const int kUsedRepresentationsFieldNumber = 2;
  inline const ::std::string& usedrepresentations(int index) const;
  inline ::std::string* mutable_usedrepresentations(int index);
  inline void set_usedrepresentations(int index, const ::std::string& value);
  inline void set_usedrepresentations(int index, const char* value);
  inline void set_usedrepresentations(int index, const char* value, size_t size);
  inline ::std::string* add_usedrepresentations();
  inline void add_usedrepresentations(const ::std::string& value);
  inline void add_usedrepresentations(const char* value);
  inline void add_usedrepresentations(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& usedrepresentations() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_usedrepresentations();
  
  // repeated string providedRepresentations = 3;
  inline int providedrepresentations_size() const;
  inline void clear_providedrepresentations();
  static const int kProvidedRepresentationsFieldNumber = 3;
  inline const ::std::string& providedrepresentations(int index) const;
  inline ::std::string* mutable_providedrepresentations(int index);
  inline void set_providedrepresentations(int index, const ::std::string& value);
  inline void set_providedrepresentations(int index, const char* value);
  inline void set_providedrepresentations(int index, const char* value, size_t size);
  inline ::std::string* add_providedrepresentations();
  inline void add_providedrepresentations(const ::std::string& value);
  inline void add_providedrepresentations(const char* value);
  inline void add_providedrepresentations(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& providedrepresentations() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_providedrepresentations();
  
  // optional bool active = 4 [default = false];
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 4;
  inline bool active() const;
  inline void set_active(bool value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.Module)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_active();
  inline void clear_has_active();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> usedrepresentations_;
  ::google::protobuf::RepeatedPtrField< ::std::string> providedrepresentations_;
  bool active_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static Module* default_instance_;
};
// -------------------------------------------------------------------

class ModuleList : public ::google::protobuf::Message {
 public:
  ModuleList();
  virtual ~ModuleList();
  
  ModuleList(const ModuleList& from);
  
  inline ModuleList& operator=(const ModuleList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleList& default_instance();
  
  void Swap(ModuleList* other);
  
  // implements Message ----------------------------------------------
  
  ModuleList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleList& from);
  void MergeFrom(const ModuleList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.Module modules = 1;
  inline int modules_size() const;
  inline void clear_modules();
  static const int kModulesFieldNumber = 1;
  inline const ::naothmessages::Module& modules(int index) const;
  inline ::naothmessages::Module* mutable_modules(int index);
  inline ::naothmessages::Module* add_modules();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Module >&
      modules() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Module >*
      mutable_modules();
  
  // @@protoc_insertion_point(class_scope:naothmessages.ModuleList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::Module > modules_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static ModuleList* default_instance_;
};
// -------------------------------------------------------------------

class FeatureKeyPoint : public ::google::protobuf::Message {
 public:
  FeatureKeyPoint();
  virtual ~FeatureKeyPoint();
  
  FeatureKeyPoint(const FeatureKeyPoint& from);
  
  inline FeatureKeyPoint& operator=(const FeatureKeyPoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureKeyPoint& default_instance();
  
  void Swap(FeatureKeyPoint* other);
  
  // implements Message ----------------------------------------------
  
  FeatureKeyPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureKeyPoint& from);
  void MergeFrom(const FeatureKeyPoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.FloatVector2 pt = 1;
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 1;
  inline const ::naothmessages::FloatVector2& pt() const;
  inline ::naothmessages::FloatVector2* mutable_pt();
  inline ::naothmessages::FloatVector2* release_pt();
  
  // required float size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline float size() const;
  inline void set_size(float value);
  
  // required float angle = 3;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 3;
  inline float angle() const;
  inline void set_angle(float value);
  
  // required float response = 4;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 4;
  inline float response() const;
  inline void set_response(float value);
  
  // required int32 octave = 5;
  inline bool has_octave() const;
  inline void clear_octave();
  static const int kOctaveFieldNumber = 5;
  inline ::google::protobuf::int32 octave() const;
  inline void set_octave(::google::protobuf::int32 value);
  
  // required int32 class_id = 6;
  inline bool has_class_id() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 6;
  inline ::google::protobuf::int32 class_id() const;
  inline void set_class_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.FeatureKeyPoint)
 private:
  inline void set_has_pt();
  inline void clear_has_pt();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_angle();
  inline void clear_has_angle();
  inline void set_has_response();
  inline void clear_has_response();
  inline void set_has_octave();
  inline void clear_has_octave();
  inline void set_has_class_id();
  inline void clear_has_class_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::FloatVector2* pt_;
  float size_;
  float angle_;
  float response_;
  ::google::protobuf::int32 octave_;
  ::google::protobuf::int32 class_id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static FeatureKeyPoint* default_instance_;
};
// -------------------------------------------------------------------

class FeatureDetectionResult : public ::google::protobuf::Message {
 public:
  FeatureDetectionResult();
  virtual ~FeatureDetectionResult();
  
  FeatureDetectionResult(const FeatureDetectionResult& from);
  
  inline FeatureDetectionResult& operator=(const FeatureDetectionResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureDetectionResult& default_instance();
  
  void Swap(FeatureDetectionResult* other);
  
  // implements Message ----------------------------------------------
  
  FeatureDetectionResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureDetectionResult& from);
  void MergeFrom(const FeatureDetectionResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes grayScaleImage = 1;
  inline bool has_grayscaleimage() const;
  inline void clear_grayscaleimage();
  static const int kGrayScaleImageFieldNumber = 1;
  inline const ::std::string& grayscaleimage() const;
  inline void set_grayscaleimage(const ::std::string& value);
  inline void set_grayscaleimage(const char* value);
  inline void set_grayscaleimage(const void* value, size_t size);
  inline ::std::string* mutable_grayscaleimage();
  inline ::std::string* release_grayscaleimage();
  
  // repeated .naothmessages.FeatureKeyPoint keyPoints = 2;
  inline int keypoints_size() const;
  inline void clear_keypoints();
  static const int kKeyPointsFieldNumber = 2;
  inline const ::naothmessages::FeatureKeyPoint& keypoints(int index) const;
  inline ::naothmessages::FeatureKeyPoint* mutable_keypoints(int index);
  inline ::naothmessages::FeatureKeyPoint* add_keypoints();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureKeyPoint >&
      keypoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureKeyPoint >*
      mutable_keypoints();
  
  // repeated .naothmessages.SingleDescriptor descriptors = 3;
  inline int descriptors_size() const;
  inline void clear_descriptors();
  static const int kDescriptorsFieldNumber = 3;
  inline const ::naothmessages::SingleDescriptor& descriptors(int index) const;
  inline ::naothmessages::SingleDescriptor* mutable_descriptors(int index);
  inline ::naothmessages::SingleDescriptor* add_descriptors();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >&
      descriptors() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >*
      mutable_descriptors();
  
  // repeated string namesForKeyPoints = 4;
  inline int namesforkeypoints_size() const;
  inline void clear_namesforkeypoints();
  static const int kNamesForKeyPointsFieldNumber = 4;
  inline const ::std::string& namesforkeypoints(int index) const;
  inline ::std::string* mutable_namesforkeypoints(int index);
  inline void set_namesforkeypoints(int index, const ::std::string& value);
  inline void set_namesforkeypoints(int index, const char* value);
  inline void set_namesforkeypoints(int index, const char* value, size_t size);
  inline ::std::string* add_namesforkeypoints();
  inline void add_namesforkeypoints(const ::std::string& value);
  inline void add_namesforkeypoints(const char* value);
  inline void add_namesforkeypoints(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& namesforkeypoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_namesforkeypoints();
  
  // optional int32 numberOfFeatureElements = 5 [default = 64];
  inline bool has_numberoffeatureelements() const;
  inline void clear_numberoffeatureelements();
  static const int kNumberOfFeatureElementsFieldNumber = 5;
  inline ::google::protobuf::int32 numberoffeatureelements() const;
  inline void set_numberoffeatureelements(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.FeatureDetectionResult)
 private:
  inline void set_has_grayscaleimage();
  inline void clear_has_grayscaleimage();
  inline void set_has_numberoffeatureelements();
  inline void clear_has_numberoffeatureelements();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* grayscaleimage_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureKeyPoint > keypoints_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor > descriptors_;
  ::google::protobuf::RepeatedPtrField< ::std::string> namesforkeypoints_;
  ::google::protobuf::int32 numberoffeatureelements_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static FeatureDetectionResult* default_instance_;
};
// -------------------------------------------------------------------

class SingleDescriptor : public ::google::protobuf::Message {
 public:
  SingleDescriptor();
  virtual ~SingleDescriptor();
  
  SingleDescriptor(const SingleDescriptor& from);
  
  inline SingleDescriptor& operator=(const SingleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleDescriptor& default_instance();
  
  void Swap(SingleDescriptor* other);
  
  // implements Message ----------------------------------------------
  
  SingleDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleDescriptor& from);
  void MergeFrom(const SingleDescriptor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated float d = 1;
  inline int d_size() const;
  inline void clear_d();
  static const int kDFieldNumber = 1;
  inline float d(int index) const;
  inline void set_d(int index, float value);
  inline void add_d(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      d() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_d();
  
  // @@protoc_insertion_point(class_scope:naothmessages.SingleDescriptor)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedField< float > d_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static SingleDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class FeatureClass : public ::google::protobuf::Message {
 public:
  FeatureClass();
  virtual ~FeatureClass();
  
  FeatureClass(const FeatureClass& from);
  
  inline FeatureClass& operator=(const FeatureClass& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureClass& default_instance();
  
  void Swap(FeatureClass* other);
  
  // implements Message ----------------------------------------------
  
  FeatureClass* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureClass& from);
  void MergeFrom(const FeatureClass& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // repeated .naothmessages.SingleDescriptor samples = 2;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 2;
  inline const ::naothmessages::SingleDescriptor& samples(int index) const;
  inline ::naothmessages::SingleDescriptor* mutable_samples(int index);
  inline ::naothmessages::SingleDescriptor* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >*
      mutable_samples();
  
  // optional double objectHeight = 3;
  inline bool has_objectheight() const;
  inline void clear_objectheight();
  static const int kObjectHeightFieldNumber = 3;
  inline double objectheight() const;
  inline void set_objectheight(double value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.FeatureClass)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_objectheight();
  inline void clear_has_objectheight();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor > samples_;
  double objectheight_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static FeatureClass* default_instance_;
};
// -------------------------------------------------------------------

class FeatureTable : public ::google::protobuf::Message {
 public:
  FeatureTable();
  virtual ~FeatureTable();
  
  FeatureTable(const FeatureTable& from);
  
  inline FeatureTable& operator=(const FeatureTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureTable& default_instance();
  
  void Swap(FeatureTable* other);
  
  // implements Message ----------------------------------------------
  
  FeatureTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureTable& from);
  void MergeFrom(const FeatureTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.FeatureClass classes = 1;
  inline int classes_size() const;
  inline void clear_classes();
  static const int kClassesFieldNumber = 1;
  inline const ::naothmessages::FeatureClass& classes(int index) const;
  inline ::naothmessages::FeatureClass* mutable_classes(int index);
  inline ::naothmessages::FeatureClass* add_classes();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureClass >&
      classes() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureClass >*
      mutable_classes();
  
  // optional int32 numberOfFeatureElements = 2 [default = 64];
  inline bool has_numberoffeatureelements() const;
  inline void clear_numberoffeatureelements();
  static const int kNumberOfFeatureElementsFieldNumber = 2;
  inline ::google::protobuf::int32 numberoffeatureelements() const;
  inline void set_numberoffeatureelements(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.FeatureTable)
 private:
  inline void set_has_numberoffeatureelements();
  inline void clear_has_numberoffeatureelements();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureClass > classes_;
  ::google::protobuf::int32 numberoffeatureelements_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  void InitAsDefaultInstance();
  static FeatureTable* default_instance_;
};
// ===================================================================


// ===================================================================

// CMDArg

// required string name = 1;
inline bool CMDArg::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMDArg::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMDArg::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMDArg::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CMDArg::name() const {
  return *name_;
}
inline void CMDArg::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMDArg::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMDArg::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMDArg::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CMDArg::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bytes bytes = 3;
inline bool CMDArg::has_bytes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CMDArg::set_has_bytes() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CMDArg::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CMDArg::clear_bytes() {
  if (bytes_ != &::google::protobuf::internal::kEmptyString) {
    bytes_->clear();
  }
  clear_has_bytes();
}
inline const ::std::string& CMDArg::bytes() const {
  return *bytes_;
}
inline void CMDArg::set_bytes(const ::std::string& value) {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  bytes_->assign(value);
}
inline void CMDArg::set_bytes(const char* value) {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  bytes_->assign(value);
}
inline void CMDArg::set_bytes(const void* value, size_t size) {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMDArg::mutable_bytes() {
  set_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    bytes_ = new ::std::string;
  }
  return bytes_;
}
inline ::std::string* CMDArg::release_bytes() {
  clear_has_bytes();
  if (bytes_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bytes_;
    bytes_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// CMD

// required string name = 1;
inline bool CMD::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CMD::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CMD::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CMD::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CMD::name() const {
  return *name_;
}
inline void CMD::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMD::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMD::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMD::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CMD::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .naothmessages.CMDArg args = 2;
inline int CMD::args_size() const {
  return args_.size();
}
inline void CMD::clear_args() {
  args_.Clear();
}
inline const ::naothmessages::CMDArg& CMD::args(int index) const {
  return args_.Get(index);
}
inline ::naothmessages::CMDArg* CMD::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::naothmessages::CMDArg* CMD::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::CMDArg >&
CMD::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::CMDArg >*
CMD::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// PlayerModel

// required int32 number = 1;
inline bool PlayerModel::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlayerModel::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlayerModel::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlayerModel::clear_number() {
  number_ = 0;
  clear_has_number();
}
inline ::google::protobuf::int32 PlayerModel::number() const {
  return number_;
}
inline void PlayerModel::set_number(::google::protobuf::int32 value) {
  set_has_number();
  number_ = value;
}

// optional .naothmessages.Pose2D poseOnField = 2;
inline bool PlayerModel::has_poseonfield() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlayerModel::set_has_poseonfield() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlayerModel::clear_has_poseonfield() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlayerModel::clear_poseonfield() {
  if (poseonfield_ != NULL) poseonfield_->::naothmessages::Pose2D::Clear();
  clear_has_poseonfield();
}
inline const ::naothmessages::Pose2D& PlayerModel::poseonfield() const {
  return poseonfield_ != NULL ? *poseonfield_ : *default_instance_->poseonfield_;
}
inline ::naothmessages::Pose2D* PlayerModel::mutable_poseonfield() {
  set_has_poseonfield();
  if (poseonfield_ == NULL) poseonfield_ = new ::naothmessages::Pose2D;
  return poseonfield_;
}
inline ::naothmessages::Pose2D* PlayerModel::release_poseonfield() {
  clear_has_poseonfield();
  ::naothmessages::Pose2D* temp = poseonfield_;
  poseonfield_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// TeamCommMessage

// required int32 playerNumber = 1;
inline bool TeamCommMessage::has_playernumber() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamCommMessage::set_has_playernumber() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamCommMessage::clear_has_playernumber() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamCommMessage::clear_playernumber() {
  playernumber_ = 0;
  clear_has_playernumber();
}
inline ::google::protobuf::int32 TeamCommMessage::playernumber() const {
  return playernumber_;
}
inline void TeamCommMessage::set_playernumber(::google::protobuf::int32 value) {
  set_has_playernumber();
  playernumber_ = value;
}

// required int32 teamNumber = 2;
inline bool TeamCommMessage::has_teamnumber() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamCommMessage::set_has_teamnumber() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamCommMessage::clear_has_teamnumber() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamCommMessage::clear_teamnumber() {
  teamnumber_ = 0;
  clear_has_teamnumber();
}
inline ::google::protobuf::int32 TeamCommMessage::teamnumber() const {
  return teamnumber_;
}
inline void TeamCommMessage::set_teamnumber(::google::protobuf::int32 value) {
  set_has_teamnumber();
  teamnumber_ = value;
}

// optional bool wasStriker = 3 [default = false];
inline bool TeamCommMessage::has_wasstriker() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamCommMessage::set_has_wasstriker() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamCommMessage::clear_has_wasstriker() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamCommMessage::clear_wasstriker() {
  wasstriker_ = false;
  clear_has_wasstriker();
}
inline bool TeamCommMessage::wasstriker() const {
  return wasstriker_;
}
inline void TeamCommMessage::set_wasstriker(bool value) {
  set_has_wasstriker();
  wasstriker_ = value;
}

// optional bool isPenalized = 4 [default = false];
inline bool TeamCommMessage::has_ispenalized() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamCommMessage::set_has_ispenalized() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamCommMessage::clear_has_ispenalized() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamCommMessage::clear_ispenalized() {
  ispenalized_ = false;
  clear_has_ispenalized();
}
inline bool TeamCommMessage::ispenalized() const {
  return ispenalized_;
}
inline void TeamCommMessage::set_ispenalized(bool value) {
  set_has_ispenalized();
  ispenalized_ = value;
}

// optional double timeSinceBallWasSeen = 5;
inline bool TeamCommMessage::has_timesinceballwasseen() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamCommMessage::set_has_timesinceballwasseen() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamCommMessage::clear_has_timesinceballwasseen() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamCommMessage::clear_timesinceballwasseen() {
  timesinceballwasseen_ = 0;
  clear_has_timesinceballwasseen();
}
inline double TeamCommMessage::timesinceballwasseen() const {
  return timesinceballwasseen_;
}
inline void TeamCommMessage::set_timesinceballwasseen(double value) {
  set_has_timesinceballwasseen();
  timesinceballwasseen_ = value;
}

// optional .naothmessages.DoubleVector2 ballPosition = 6;
inline bool TeamCommMessage::has_ballposition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TeamCommMessage::set_has_ballposition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TeamCommMessage::clear_has_ballposition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TeamCommMessage::clear_ballposition() {
  if (ballposition_ != NULL) ballposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_ballposition();
}
inline const ::naothmessages::DoubleVector2& TeamCommMessage::ballposition() const {
  return ballposition_ != NULL ? *ballposition_ : *default_instance_->ballposition_;
}
inline ::naothmessages::DoubleVector2* TeamCommMessage::mutable_ballposition() {
  set_has_ballposition();
  if (ballposition_ == NULL) ballposition_ = new ::naothmessages::DoubleVector2;
  return ballposition_;
}
inline ::naothmessages::DoubleVector2* TeamCommMessage::release_ballposition() {
  clear_has_ballposition();
  ::naothmessages::DoubleVector2* temp = ballposition_;
  ballposition_ = NULL;
  return temp;
}

// optional .naothmessages.Pose2D positionOnField = 7;
inline bool TeamCommMessage::has_positiononfield() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TeamCommMessage::set_has_positiononfield() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TeamCommMessage::clear_has_positiononfield() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TeamCommMessage::clear_positiononfield() {
  if (positiononfield_ != NULL) positiononfield_->::naothmessages::Pose2D::Clear();
  clear_has_positiononfield();
}
inline const ::naothmessages::Pose2D& TeamCommMessage::positiononfield() const {
  return positiononfield_ != NULL ? *positiononfield_ : *default_instance_->positiononfield_;
}
inline ::naothmessages::Pose2D* TeamCommMessage::mutable_positiononfield() {
  set_has_positiononfield();
  if (positiononfield_ == NULL) positiononfield_ = new ::naothmessages::Pose2D;
  return positiononfield_;
}
inline ::naothmessages::Pose2D* TeamCommMessage::release_positiononfield() {
  clear_has_positiononfield();
  ::naothmessages::Pose2D* temp = positiononfield_;
  positiononfield_ = NULL;
  return temp;
}

// optional .naothmessages.PlayerModel opponent = 8;
inline bool TeamCommMessage::has_opponent() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TeamCommMessage::set_has_opponent() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TeamCommMessage::clear_has_opponent() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TeamCommMessage::clear_opponent() {
  if (opponent_ != NULL) opponent_->::naothmessages::PlayerModel::Clear();
  clear_has_opponent();
}
inline const ::naothmessages::PlayerModel& TeamCommMessage::opponent() const {
  return opponent_ != NULL ? *opponent_ : *default_instance_->opponent_;
}
inline ::naothmessages::PlayerModel* TeamCommMessage::mutable_opponent() {
  set_has_opponent();
  if (opponent_ == NULL) opponent_ = new ::naothmessages::PlayerModel;
  return opponent_;
}
inline ::naothmessages::PlayerModel* TeamCommMessage::release_opponent() {
  clear_has_opponent();
  ::naothmessages::PlayerModel* temp = opponent_;
  opponent_ = NULL;
  return temp;
}

// optional bool isFallenDown = 9 [default = false];
inline bool TeamCommMessage::has_isfallendown() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TeamCommMessage::set_has_isfallendown() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TeamCommMessage::clear_has_isfallendown() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TeamCommMessage::clear_isfallendown() {
  isfallendown_ = false;
  clear_has_isfallendown();
}
inline bool TeamCommMessage::isfallendown() const {
  return isfallendown_;
}
inline void TeamCommMessage::set_isfallendown(bool value) {
  set_has_isfallendown();
  isfallendown_ = value;
}

// optional double timeToBall = 10;
inline bool TeamCommMessage::has_timetoball() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TeamCommMessage::set_has_timetoball() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TeamCommMessage::clear_has_timetoball() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TeamCommMessage::clear_timetoball() {
  timetoball_ = 0;
  clear_has_timetoball();
}
inline double TeamCommMessage::timetoball() const {
  return timetoball_;
}
inline void TeamCommMessage::set_timetoball(double value) {
  set_has_timetoball();
  timetoball_ = value;
}

// optional string bodyID = 11;
inline bool TeamCommMessage::has_bodyid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TeamCommMessage::set_has_bodyid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TeamCommMessage::clear_has_bodyid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TeamCommMessage::clear_bodyid() {
  if (bodyid_ != &::google::protobuf::internal::kEmptyString) {
    bodyid_->clear();
  }
  clear_has_bodyid();
}
inline const ::std::string& TeamCommMessage::bodyid() const {
  return *bodyid_;
}
inline void TeamCommMessage::set_bodyid(const ::std::string& value) {
  set_has_bodyid();
  if (bodyid_ == &::google::protobuf::internal::kEmptyString) {
    bodyid_ = new ::std::string;
  }
  bodyid_->assign(value);
}
inline void TeamCommMessage::set_bodyid(const char* value) {
  set_has_bodyid();
  if (bodyid_ == &::google::protobuf::internal::kEmptyString) {
    bodyid_ = new ::std::string;
  }
  bodyid_->assign(value);
}
inline void TeamCommMessage::set_bodyid(const char* value, size_t size) {
  set_has_bodyid();
  if (bodyid_ == &::google::protobuf::internal::kEmptyString) {
    bodyid_ = new ::std::string;
  }
  bodyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TeamCommMessage::mutable_bodyid() {
  set_has_bodyid();
  if (bodyid_ == &::google::protobuf::internal::kEmptyString) {
    bodyid_ = new ::std::string;
  }
  return bodyid_;
}
inline ::std::string* TeamCommMessage::release_bodyid() {
  clear_has_bodyid();
  if (bodyid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bodyid_;
    bodyid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// StopwatchItem

// required string name = 1;
inline bool StopwatchItem::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StopwatchItem::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StopwatchItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StopwatchItem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StopwatchItem::name() const {
  return *name_;
}
inline void StopwatchItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StopwatchItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StopwatchItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StopwatchItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StopwatchItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required int32 time = 2;
inline bool StopwatchItem::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StopwatchItem::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StopwatchItem::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StopwatchItem::clear_time() {
  time_ = 0;
  clear_has_time();
}
inline ::google::protobuf::int32 StopwatchItem::time() const {
  return time_;
}
inline void StopwatchItem::set_time(::google::protobuf::int32 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// Stopwatches

// repeated .naothmessages.StopwatchItem stopwatches = 1;
inline int Stopwatches::stopwatches_size() const {
  return stopwatches_.size();
}
inline void Stopwatches::clear_stopwatches() {
  stopwatches_.Clear();
}
inline const ::naothmessages::StopwatchItem& Stopwatches::stopwatches(int index) const {
  return stopwatches_.Get(index);
}
inline ::naothmessages::StopwatchItem* Stopwatches::mutable_stopwatches(int index) {
  return stopwatches_.Mutable(index);
}
inline ::naothmessages::StopwatchItem* Stopwatches::add_stopwatches() {
  return stopwatches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::StopwatchItem >&
Stopwatches::stopwatches() const {
  return stopwatches_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::StopwatchItem >*
Stopwatches::mutable_stopwatches() {
  return &stopwatches_;
}

// -------------------------------------------------------------------

// PlotItem

// required .naothmessages.PlotItem.PlotType type = 1;
inline bool PlotItem::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlotItem::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlotItem::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlotItem::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::naothmessages::PlotItem_PlotType PlotItem::type() const {
  return static_cast< ::naothmessages::PlotItem_PlotType >(type_);
}
inline void PlotItem::set_type(::naothmessages::PlotItem_PlotType value) {
  GOOGLE_DCHECK(::naothmessages::PlotItem_PlotType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string name = 2;
inline bool PlotItem::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PlotItem::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PlotItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PlotItem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlotItem::name() const {
  return *name_;
}
inline void PlotItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlotItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlotItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlotItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlotItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double value = 3;
inline bool PlotItem::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PlotItem::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PlotItem::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PlotItem::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double PlotItem::value() const {
  return value_;
}
inline void PlotItem::set_value(double value) {
  set_has_value();
  value_ = value;
}

// optional double x = 4;
inline bool PlotItem::has_x() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PlotItem::set_has_x() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PlotItem::clear_has_x() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PlotItem::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline double PlotItem::x() const {
  return x_;
}
inline void PlotItem::set_x(double value) {
  set_has_x();
  x_ = value;
}

// optional double y = 5;
inline bool PlotItem::has_y() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PlotItem::set_has_y() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PlotItem::clear_has_y() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PlotItem::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline double PlotItem::y() const {
  return y_;
}
inline void PlotItem::set_y(double value) {
  set_has_y();
  y_ = value;
}

// optional double rotation = 6;
inline bool PlotItem::has_rotation() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PlotItem::set_has_rotation() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PlotItem::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PlotItem::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline double PlotItem::rotation() const {
  return rotation_;
}
inline void PlotItem::set_rotation(double value) {
  set_has_rotation();
  rotation_ = value;
}

// -------------------------------------------------------------------

// PlotStroke2D

// required string name = 2;
inline bool PlotStroke2D::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PlotStroke2D::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PlotStroke2D::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PlotStroke2D::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PlotStroke2D::name() const {
  return *name_;
}
inline void PlotStroke2D::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlotStroke2D::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlotStroke2D::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlotStroke2D::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PlotStroke2D::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .naothmessages.DoubleVector2 points = 1;
inline int PlotStroke2D::points_size() const {
  return points_.size();
}
inline void PlotStroke2D::clear_points() {
  points_.Clear();
}
inline const ::naothmessages::DoubleVector2& PlotStroke2D::points(int index) const {
  return points_.Get(index);
}
inline ::naothmessages::DoubleVector2* PlotStroke2D::mutable_points(int index) {
  return points_.Mutable(index);
}
inline ::naothmessages::DoubleVector2* PlotStroke2D::add_points() {
  return points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
PlotStroke2D::points() const {
  return points_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
PlotStroke2D::mutable_points() {
  return &points_;
}

// -------------------------------------------------------------------

// Plots

// repeated .naothmessages.PlotItem plots = 1;
inline int Plots::plots_size() const {
  return plots_.size();
}
inline void Plots::clear_plots() {
  plots_.Clear();
}
inline const ::naothmessages::PlotItem& Plots::plots(int index) const {
  return plots_.Get(index);
}
inline ::naothmessages::PlotItem* Plots::mutable_plots(int index) {
  return plots_.Mutable(index);
}
inline ::naothmessages::PlotItem* Plots::add_plots() {
  return plots_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotItem >&
Plots::plots() const {
  return plots_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotItem >*
Plots::mutable_plots() {
  return &plots_;
}

// repeated .naothmessages.PlotStroke2D plotstrokes = 2;
inline int Plots::plotstrokes_size() const {
  return plotstrokes_.size();
}
inline void Plots::clear_plotstrokes() {
  plotstrokes_.Clear();
}
inline const ::naothmessages::PlotStroke2D& Plots::plotstrokes(int index) const {
  return plotstrokes_.Get(index);
}
inline ::naothmessages::PlotStroke2D* Plots::mutable_plotstrokes(int index) {
  return plotstrokes_.Mutable(index);
}
inline ::naothmessages::PlotStroke2D* Plots::add_plotstrokes() {
  return plotstrokes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotStroke2D >&
Plots::plotstrokes() const {
  return plotstrokes_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotStroke2D >*
Plots::mutable_plotstrokes() {
  return &plotstrokes_;
}

// -------------------------------------------------------------------

// XABSLSymbol

// required int32 id = 1 [default = -1];
inline bool XABSLSymbol::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XABSLSymbol::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XABSLSymbol::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XABSLSymbol::clear_id() {
  id_ = -1;
  clear_has_id();
}
inline ::google::protobuf::int32 XABSLSymbol::id() const {
  return id_;
}
inline void XABSLSymbol::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required .naothmessages.XABSLSymbol.SymbolType type = 2 [default = Unknown];
inline bool XABSLSymbol::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XABSLSymbol::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XABSLSymbol::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XABSLSymbol::clear_type() {
  type_ = 3;
  clear_has_type();
}
inline ::naothmessages::XABSLSymbol_SymbolType XABSLSymbol::type() const {
  return static_cast< ::naothmessages::XABSLSymbol_SymbolType >(type_);
}
inline void XABSLSymbol::set_type(::naothmessages::XABSLSymbol_SymbolType value) {
  GOOGLE_DCHECK(::naothmessages::XABSLSymbol_SymbolType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 3;
inline bool XABSLSymbol::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XABSLSymbol::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XABSLSymbol::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XABSLSymbol::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& XABSLSymbol::name() const {
  return *name_;
}
inline void XABSLSymbol::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLSymbol::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLSymbol::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLSymbol::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* XABSLSymbol::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double decimalValue = 11;
inline bool XABSLSymbol::has_decimalvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XABSLSymbol::set_has_decimalvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XABSLSymbol::clear_has_decimalvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XABSLSymbol::clear_decimalvalue() {
  decimalvalue_ = 0;
  clear_has_decimalvalue();
}
inline double XABSLSymbol::decimalvalue() const {
  return decimalvalue_;
}
inline void XABSLSymbol::set_decimalvalue(double value) {
  set_has_decimalvalue();
  decimalvalue_ = value;
}

// optional bool boolValue = 12;
inline bool XABSLSymbol::has_boolvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XABSLSymbol::set_has_boolvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XABSLSymbol::clear_has_boolvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XABSLSymbol::clear_boolvalue() {
  boolvalue_ = false;
  clear_has_boolvalue();
}
inline bool XABSLSymbol::boolvalue() const {
  return boolvalue_;
}
inline void XABSLSymbol::set_boolvalue(bool value) {
  set_has_boolvalue();
  boolvalue_ = value;
}

// optional int32 enumValue = 13;
inline bool XABSLSymbol::has_enumvalue() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XABSLSymbol::set_has_enumvalue() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XABSLSymbol::clear_has_enumvalue() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XABSLSymbol::clear_enumvalue() {
  enumvalue_ = 0;
  clear_has_enumvalue();
}
inline ::google::protobuf::int32 XABSLSymbol::enumvalue() const {
  return enumvalue_;
}
inline void XABSLSymbol::set_enumvalue(::google::protobuf::int32 value) {
  set_has_enumvalue();
  enumvalue_ = value;
}

// optional int32 enumTypeId = 14;
inline bool XABSLSymbol::has_enumtypeid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void XABSLSymbol::set_has_enumtypeid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void XABSLSymbol::clear_has_enumtypeid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void XABSLSymbol::clear_enumtypeid() {
  enumtypeid_ = 0;
  clear_has_enumtypeid();
}
inline ::google::protobuf::int32 XABSLSymbol::enumtypeid() const {
  return enumtypeid_;
}
inline void XABSLSymbol::set_enumtypeid(::google::protobuf::int32 value) {
  set_has_enumtypeid();
  enumtypeid_ = value;
}

// -------------------------------------------------------------------

// XABSLActiveOptionSparse

// required int32 id = 1 [default = -1];
inline bool XABSLActiveOptionSparse::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XABSLActiveOptionSparse::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XABSLActiveOptionSparse::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XABSLActiveOptionSparse::clear_id() {
  id_ = -1;
  clear_has_id();
}
inline ::google::protobuf::int32 XABSLActiveOptionSparse::id() const {
  return id_;
}
inline void XABSLActiveOptionSparse::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int64 timeOfExecution = 3 [default = 0];
inline bool XABSLActiveOptionSparse::has_timeofexecution() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XABSLActiveOptionSparse::set_has_timeofexecution() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XABSLActiveOptionSparse::clear_has_timeofexecution() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XABSLActiveOptionSparse::clear_timeofexecution() {
  timeofexecution_ = GOOGLE_LONGLONG(0);
  clear_has_timeofexecution();
}
inline ::google::protobuf::int64 XABSLActiveOptionSparse::timeofexecution() const {
  return timeofexecution_;
}
inline void XABSLActiveOptionSparse::set_timeofexecution(::google::protobuf::int64 value) {
  set_has_timeofexecution();
  timeofexecution_ = value;
}

// optional int32 activeState = 4;
inline bool XABSLActiveOptionSparse::has_activestate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XABSLActiveOptionSparse::set_has_activestate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XABSLActiveOptionSparse::clear_has_activestate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XABSLActiveOptionSparse::clear_activestate() {
  activestate_ = 0;
  clear_has_activestate();
}
inline ::google::protobuf::int32 XABSLActiveOptionSparse::activestate() const {
  return activestate_;
}
inline void XABSLActiveOptionSparse::set_activestate(::google::protobuf::int32 value) {
  set_has_activestate();
  activestate_ = value;
}

// optional int64 stateTime = 5;
inline bool XABSLActiveOptionSparse::has_statetime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XABSLActiveOptionSparse::set_has_statetime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XABSLActiveOptionSparse::clear_has_statetime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XABSLActiveOptionSparse::clear_statetime() {
  statetime_ = GOOGLE_LONGLONG(0);
  clear_has_statetime();
}
inline ::google::protobuf::int64 XABSLActiveOptionSparse::statetime() const {
  return statetime_;
}
inline void XABSLActiveOptionSparse::set_statetime(::google::protobuf::int64 value) {
  set_has_statetime();
  statetime_ = value;
}

// repeated double decimalParameters = 6;
inline int XABSLActiveOptionSparse::decimalparameters_size() const {
  return decimalparameters_.size();
}
inline void XABSLActiveOptionSparse::clear_decimalparameters() {
  decimalparameters_.Clear();
}
inline double XABSLActiveOptionSparse::decimalparameters(int index) const {
  return decimalparameters_.Get(index);
}
inline void XABSLActiveOptionSparse::set_decimalparameters(int index, double value) {
  decimalparameters_.Set(index, value);
}
inline void XABSLActiveOptionSparse::add_decimalparameters(double value) {
  decimalparameters_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
XABSLActiveOptionSparse::decimalparameters() const {
  return decimalparameters_;
}
inline ::google::protobuf::RepeatedField< double >*
XABSLActiveOptionSparse::mutable_decimalparameters() {
  return &decimalparameters_;
}

// repeated bool booleanParameters = 7;
inline int XABSLActiveOptionSparse::booleanparameters_size() const {
  return booleanparameters_.size();
}
inline void XABSLActiveOptionSparse::clear_booleanparameters() {
  booleanparameters_.Clear();
}
inline bool XABSLActiveOptionSparse::booleanparameters(int index) const {
  return booleanparameters_.Get(index);
}
inline void XABSLActiveOptionSparse::set_booleanparameters(int index, bool value) {
  booleanparameters_.Set(index, value);
}
inline void XABSLActiveOptionSparse::add_booleanparameters(bool value) {
  booleanparameters_.Add(value);
}
inline const ::google::protobuf::RepeatedField< bool >&
XABSLActiveOptionSparse::booleanparameters() const {
  return booleanparameters_;
}
inline ::google::protobuf::RepeatedField< bool >*
XABSLActiveOptionSparse::mutable_booleanparameters() {
  return &booleanparameters_;
}

// repeated int32 enumeratedParameters = 8;
inline int XABSLActiveOptionSparse::enumeratedparameters_size() const {
  return enumeratedparameters_.size();
}
inline void XABSLActiveOptionSparse::clear_enumeratedparameters() {
  enumeratedparameters_.Clear();
}
inline ::google::protobuf::int32 XABSLActiveOptionSparse::enumeratedparameters(int index) const {
  return enumeratedparameters_.Get(index);
}
inline void XABSLActiveOptionSparse::set_enumeratedparameters(int index, ::google::protobuf::int32 value) {
  enumeratedparameters_.Set(index, value);
}
inline void XABSLActiveOptionSparse::add_enumeratedparameters(::google::protobuf::int32 value) {
  enumeratedparameters_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
XABSLActiveOptionSparse::enumeratedparameters() const {
  return enumeratedparameters_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
XABSLActiveOptionSparse::mutable_enumeratedparameters() {
  return &enumeratedparameters_;
}

// repeated .naothmessages.XABSLActionSparse activeSubActions = 9;
inline int XABSLActiveOptionSparse::activesubactions_size() const {
  return activesubactions_.size();
}
inline void XABSLActiveOptionSparse::clear_activesubactions() {
  activesubactions_.Clear();
}
inline const ::naothmessages::XABSLActionSparse& XABSLActiveOptionSparse::activesubactions(int index) const {
  return activesubactions_.Get(index);
}
inline ::naothmessages::XABSLActionSparse* XABSLActiveOptionSparse::mutable_activesubactions(int index) {
  return activesubactions_.Mutable(index);
}
inline ::naothmessages::XABSLActionSparse* XABSLActiveOptionSparse::add_activesubactions() {
  return activesubactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLActionSparse >&
XABSLActiveOptionSparse::activesubactions() const {
  return activesubactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLActionSparse >*
XABSLActiveOptionSparse::mutable_activesubactions() {
  return &activesubactions_;
}

// -------------------------------------------------------------------

// XABSLActionSparse

// required .naothmessages.XABSLActionSparse.ActionType type = 2 [default = Unknown];
inline bool XABSLActionSparse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XABSLActionSparse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XABSLActionSparse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XABSLActionSparse::clear_type() {
  type_ = 3;
  clear_has_type();
}
inline ::naothmessages::XABSLActionSparse_ActionType XABSLActionSparse::type() const {
  return static_cast< ::naothmessages::XABSLActionSparse_ActionType >(type_);
}
inline void XABSLActionSparse::set_type(::naothmessages::XABSLActionSparse_ActionType value) {
  GOOGLE_DCHECK(::naothmessages::XABSLActionSparse_ActionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .naothmessages.XABSLSymbol symbol = 3;
inline bool XABSLActionSparse::has_symbol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XABSLActionSparse::set_has_symbol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XABSLActionSparse::clear_has_symbol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XABSLActionSparse::clear_symbol() {
  if (symbol_ != NULL) symbol_->::naothmessages::XABSLSymbol::Clear();
  clear_has_symbol();
}
inline const ::naothmessages::XABSLSymbol& XABSLActionSparse::symbol() const {
  return symbol_ != NULL ? *symbol_ : *default_instance_->symbol_;
}
inline ::naothmessages::XABSLSymbol* XABSLActionSparse::mutable_symbol() {
  set_has_symbol();
  if (symbol_ == NULL) symbol_ = new ::naothmessages::XABSLSymbol;
  return symbol_;
}
inline ::naothmessages::XABSLSymbol* XABSLActionSparse::release_symbol() {
  clear_has_symbol();
  ::naothmessages::XABSLSymbol* temp = symbol_;
  symbol_ = NULL;
  return temp;
}

// optional .naothmessages.XABSLActiveOptionSparse option = 4;
inline bool XABSLActionSparse::has_option() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XABSLActionSparse::set_has_option() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XABSLActionSparse::clear_has_option() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XABSLActionSparse::clear_option() {
  if (option_ != NULL) option_->::naothmessages::XABSLActiveOptionSparse::Clear();
  clear_has_option();
}
inline const ::naothmessages::XABSLActiveOptionSparse& XABSLActionSparse::option() const {
  return option_ != NULL ? *option_ : *default_instance_->option_;
}
inline ::naothmessages::XABSLActiveOptionSparse* XABSLActionSparse::mutable_option() {
  set_has_option();
  if (option_ == NULL) option_ = new ::naothmessages::XABSLActiveOptionSparse;
  return option_;
}
inline ::naothmessages::XABSLActiveOptionSparse* XABSLActionSparse::release_option() {
  clear_has_option();
  ::naothmessages::XABSLActiveOptionSparse* temp = option_;
  option_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// SymbolValueList_DoubleSymbol

// required int32 id = 1 [default = -1];
inline bool SymbolValueList_DoubleSymbol::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolValueList_DoubleSymbol::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolValueList_DoubleSymbol::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolValueList_DoubleSymbol::clear_id() {
  id_ = -1;
  clear_has_id();
}
inline ::google::protobuf::int32 SymbolValueList_DoubleSymbol::id() const {
  return id_;
}
inline void SymbolValueList_DoubleSymbol::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool SymbolValueList_DoubleSymbol::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolValueList_DoubleSymbol::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolValueList_DoubleSymbol::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolValueList_DoubleSymbol::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SymbolValueList_DoubleSymbol::name() const {
  return *name_;
}
inline void SymbolValueList_DoubleSymbol::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SymbolValueList_DoubleSymbol::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SymbolValueList_DoubleSymbol::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymbolValueList_DoubleSymbol::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SymbolValueList_DoubleSymbol::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional double value = 3;
inline bool SymbolValueList_DoubleSymbol::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolValueList_DoubleSymbol::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolValueList_DoubleSymbol::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolValueList_DoubleSymbol::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double SymbolValueList_DoubleSymbol::value() const {
  return value_;
}
inline void SymbolValueList_DoubleSymbol::set_value(double value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// SymbolValueList_BooleanSymbol

// required int32 id = 1 [default = -1];
inline bool SymbolValueList_BooleanSymbol::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolValueList_BooleanSymbol::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolValueList_BooleanSymbol::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolValueList_BooleanSymbol::clear_id() {
  id_ = -1;
  clear_has_id();
}
inline ::google::protobuf::int32 SymbolValueList_BooleanSymbol::id() const {
  return id_;
}
inline void SymbolValueList_BooleanSymbol::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool SymbolValueList_BooleanSymbol::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolValueList_BooleanSymbol::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolValueList_BooleanSymbol::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolValueList_BooleanSymbol::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SymbolValueList_BooleanSymbol::name() const {
  return *name_;
}
inline void SymbolValueList_BooleanSymbol::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SymbolValueList_BooleanSymbol::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SymbolValueList_BooleanSymbol::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymbolValueList_BooleanSymbol::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SymbolValueList_BooleanSymbol::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool value = 3;
inline bool SymbolValueList_BooleanSymbol::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolValueList_BooleanSymbol::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolValueList_BooleanSymbol::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolValueList_BooleanSymbol::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool SymbolValueList_BooleanSymbol::value() const {
  return value_;
}
inline void SymbolValueList_BooleanSymbol::set_value(bool value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// SymbolValueList_EnumSymbol

// required int32 id = 1 [default = -1];
inline bool SymbolValueList_EnumSymbol::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SymbolValueList_EnumSymbol::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SymbolValueList_EnumSymbol::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SymbolValueList_EnumSymbol::clear_id() {
  id_ = -1;
  clear_has_id();
}
inline ::google::protobuf::int32 SymbolValueList_EnumSymbol::id() const {
  return id_;
}
inline void SymbolValueList_EnumSymbol::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool SymbolValueList_EnumSymbol::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SymbolValueList_EnumSymbol::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SymbolValueList_EnumSymbol::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SymbolValueList_EnumSymbol::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SymbolValueList_EnumSymbol::name() const {
  return *name_;
}
inline void SymbolValueList_EnumSymbol::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SymbolValueList_EnumSymbol::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SymbolValueList_EnumSymbol::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SymbolValueList_EnumSymbol::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SymbolValueList_EnumSymbol::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int32 value = 13;
inline bool SymbolValueList_EnumSymbol::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SymbolValueList_EnumSymbol::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SymbolValueList_EnumSymbol::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SymbolValueList_EnumSymbol::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 SymbolValueList_EnumSymbol::value() const {
  return value_;
}
inline void SymbolValueList_EnumSymbol::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// optional int32 typeId = 14;
inline bool SymbolValueList_EnumSymbol::has_typeid_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SymbolValueList_EnumSymbol::set_has_typeid_() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SymbolValueList_EnumSymbol::clear_has_typeid_() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SymbolValueList_EnumSymbol::clear_typeid_() {
  typeid__ = 0;
  clear_has_typeid_();
}
inline ::google::protobuf::int32 SymbolValueList_EnumSymbol::typeid_() const {
  return typeid__;
}
inline void SymbolValueList_EnumSymbol::set_typeid_(::google::protobuf::int32 value) {
  set_has_typeid_();
  typeid__ = value;
}

// -------------------------------------------------------------------

// SymbolValueList

// repeated .naothmessages.SymbolValueList.DoubleSymbol decimal = 1;
inline int SymbolValueList::decimal_size() const {
  return decimal_.size();
}
inline void SymbolValueList::clear_decimal() {
  decimal_.Clear();
}
inline const ::naothmessages::SymbolValueList_DoubleSymbol& SymbolValueList::decimal(int index) const {
  return decimal_.Get(index);
}
inline ::naothmessages::SymbolValueList_DoubleSymbol* SymbolValueList::mutable_decimal(int index) {
  return decimal_.Mutable(index);
}
inline ::naothmessages::SymbolValueList_DoubleSymbol* SymbolValueList::add_decimal() {
  return decimal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_DoubleSymbol >&
SymbolValueList::decimal() const {
  return decimal_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_DoubleSymbol >*
SymbolValueList::mutable_decimal() {
  return &decimal_;
}

// repeated .naothmessages.SymbolValueList.BooleanSymbol boolean = 2;
inline int SymbolValueList::boolean_size() const {
  return boolean_.size();
}
inline void SymbolValueList::clear_boolean() {
  boolean_.Clear();
}
inline const ::naothmessages::SymbolValueList_BooleanSymbol& SymbolValueList::boolean(int index) const {
  return boolean_.Get(index);
}
inline ::naothmessages::SymbolValueList_BooleanSymbol* SymbolValueList::mutable_boolean(int index) {
  return boolean_.Mutable(index);
}
inline ::naothmessages::SymbolValueList_BooleanSymbol* SymbolValueList::add_boolean() {
  return boolean_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_BooleanSymbol >&
SymbolValueList::boolean() const {
  return boolean_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_BooleanSymbol >*
SymbolValueList::mutable_boolean() {
  return &boolean_;
}

// repeated .naothmessages.SymbolValueList.EnumSymbol enumerated = 3;
inline int SymbolValueList::enumerated_size() const {
  return enumerated_.size();
}
inline void SymbolValueList::clear_enumerated() {
  enumerated_.Clear();
}
inline const ::naothmessages::SymbolValueList_EnumSymbol& SymbolValueList::enumerated(int index) const {
  return enumerated_.Get(index);
}
inline ::naothmessages::SymbolValueList_EnumSymbol* SymbolValueList::mutable_enumerated(int index) {
  return enumerated_.Mutable(index);
}
inline ::naothmessages::SymbolValueList_EnumSymbol* SymbolValueList::add_enumerated() {
  return enumerated_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_EnumSymbol >&
SymbolValueList::enumerated() const {
  return enumerated_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SymbolValueList_EnumSymbol >*
SymbolValueList::mutable_enumerated() {
  return &enumerated_;
}

// -------------------------------------------------------------------

// BehaviorStatusSparse

// optional string agent = 1;
inline bool BehaviorStatusSparse::has_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BehaviorStatusSparse::set_has_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BehaviorStatusSparse::clear_has_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BehaviorStatusSparse::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline const ::std::string& BehaviorStatusSparse::agent() const {
  return *agent_;
}
inline void BehaviorStatusSparse::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void BehaviorStatusSparse::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void BehaviorStatusSparse::set_agent(const char* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorStatusSparse::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* BehaviorStatusSparse::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .naothmessages.XABSLActionSparse activeRootActions = 2;
inline int BehaviorStatusSparse::activerootactions_size() const {
  return activerootactions_.size();
}
inline void BehaviorStatusSparse::clear_activerootactions() {
  activerootactions_.Clear();
}
inline const ::naothmessages::XABSLActionSparse& BehaviorStatusSparse::activerootactions(int index) const {
  return activerootactions_.Get(index);
}
inline ::naothmessages::XABSLActionSparse* BehaviorStatusSparse::mutable_activerootactions(int index) {
  return activerootactions_.Mutable(index);
}
inline ::naothmessages::XABSLActionSparse* BehaviorStatusSparse::add_activerootactions() {
  return activerootactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLActionSparse >&
BehaviorStatusSparse::activerootactions() const {
  return activerootactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLActionSparse >*
BehaviorStatusSparse::mutable_activerootactions() {
  return &activerootactions_;
}

// optional .naothmessages.SymbolValueList inputSymbolList = 10;
inline bool BehaviorStatusSparse::has_inputsymbollist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BehaviorStatusSparse::set_has_inputsymbollist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BehaviorStatusSparse::clear_has_inputsymbollist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BehaviorStatusSparse::clear_inputsymbollist() {
  if (inputsymbollist_ != NULL) inputsymbollist_->::naothmessages::SymbolValueList::Clear();
  clear_has_inputsymbollist();
}
inline const ::naothmessages::SymbolValueList& BehaviorStatusSparse::inputsymbollist() const {
  return inputsymbollist_ != NULL ? *inputsymbollist_ : *default_instance_->inputsymbollist_;
}
inline ::naothmessages::SymbolValueList* BehaviorStatusSparse::mutable_inputsymbollist() {
  set_has_inputsymbollist();
  if (inputsymbollist_ == NULL) inputsymbollist_ = new ::naothmessages::SymbolValueList;
  return inputsymbollist_;
}
inline ::naothmessages::SymbolValueList* BehaviorStatusSparse::release_inputsymbollist() {
  clear_has_inputsymbollist();
  ::naothmessages::SymbolValueList* temp = inputsymbollist_;
  inputsymbollist_ = NULL;
  return temp;
}

// optional .naothmessages.SymbolValueList outputSymbolList = 11;
inline bool BehaviorStatusSparse::has_outputsymbollist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BehaviorStatusSparse::set_has_outputsymbollist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BehaviorStatusSparse::clear_has_outputsymbollist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BehaviorStatusSparse::clear_outputsymbollist() {
  if (outputsymbollist_ != NULL) outputsymbollist_->::naothmessages::SymbolValueList::Clear();
  clear_has_outputsymbollist();
}
inline const ::naothmessages::SymbolValueList& BehaviorStatusSparse::outputsymbollist() const {
  return outputsymbollist_ != NULL ? *outputsymbollist_ : *default_instance_->outputsymbollist_;
}
inline ::naothmessages::SymbolValueList* BehaviorStatusSparse::mutable_outputsymbollist() {
  set_has_outputsymbollist();
  if (outputsymbollist_ == NULL) outputsymbollist_ = new ::naothmessages::SymbolValueList;
  return outputsymbollist_;
}
inline ::naothmessages::SymbolValueList* BehaviorStatusSparse::release_outputsymbollist() {
  clear_has_outputsymbollist();
  ::naothmessages::SymbolValueList* temp = outputsymbollist_;
  outputsymbollist_ = NULL;
  return temp;
}

// optional uint32 frameNumber = 5;
inline bool BehaviorStatusSparse::has_framenumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BehaviorStatusSparse::set_has_framenumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BehaviorStatusSparse::clear_has_framenumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BehaviorStatusSparse::clear_framenumber() {
  framenumber_ = 0u;
  clear_has_framenumber();
}
inline ::google::protobuf::uint32 BehaviorStatusSparse::framenumber() const {
  return framenumber_;
}
inline void BehaviorStatusSparse::set_framenumber(::google::protobuf::uint32 value) {
  set_has_framenumber();
  framenumber_ = value;
}

// optional string errorMessage = 6;
inline bool BehaviorStatusSparse::has_errormessage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BehaviorStatusSparse::set_has_errormessage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BehaviorStatusSparse::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BehaviorStatusSparse::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& BehaviorStatusSparse::errormessage() const {
  return *errormessage_;
}
inline void BehaviorStatusSparse::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void BehaviorStatusSparse::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void BehaviorStatusSparse::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorStatusSparse::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  return errormessage_;
}
inline ::std::string* BehaviorStatusSparse::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// XABSLBehavior_EnumType_Element

// required int32 value = 1;
inline bool XABSLBehavior_EnumType_Element::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XABSLBehavior_EnumType_Element::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XABSLBehavior_EnumType_Element::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XABSLBehavior_EnumType_Element::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 XABSLBehavior_EnumType_Element::value() const {
  return value_;
}
inline void XABSLBehavior_EnumType_Element::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// required string name = 2;
inline bool XABSLBehavior_EnumType_Element::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XABSLBehavior_EnumType_Element::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XABSLBehavior_EnumType_Element::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XABSLBehavior_EnumType_Element::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& XABSLBehavior_EnumType_Element::name() const {
  return *name_;
}
inline void XABSLBehavior_EnumType_Element::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLBehavior_EnumType_Element::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLBehavior_EnumType_Element::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLBehavior_EnumType_Element::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* XABSLBehavior_EnumType_Element::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// XABSLBehavior_EnumType

// required string name = 1;
inline bool XABSLBehavior_EnumType::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XABSLBehavior_EnumType::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XABSLBehavior_EnumType::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XABSLBehavior_EnumType::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& XABSLBehavior_EnumType::name() const {
  return *name_;
}
inline void XABSLBehavior_EnumType::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLBehavior_EnumType::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLBehavior_EnumType::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLBehavior_EnumType::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* XABSLBehavior_EnumType::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .naothmessages.XABSLBehavior.EnumType.Element elements = 2;
inline int XABSLBehavior_EnumType::elements_size() const {
  return elements_.size();
}
inline void XABSLBehavior_EnumType::clear_elements() {
  elements_.Clear();
}
inline const ::naothmessages::XABSLBehavior_EnumType_Element& XABSLBehavior_EnumType::elements(int index) const {
  return elements_.Get(index);
}
inline ::naothmessages::XABSLBehavior_EnumType_Element* XABSLBehavior_EnumType::mutable_elements(int index) {
  return elements_.Mutable(index);
}
inline ::naothmessages::XABSLBehavior_EnumType_Element* XABSLBehavior_EnumType::add_elements() {
  return elements_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_EnumType_Element >&
XABSLBehavior_EnumType::elements() const {
  return elements_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_EnumType_Element >*
XABSLBehavior_EnumType::mutable_elements() {
  return &elements_;
}

// -------------------------------------------------------------------

// XABSLBehavior_Option_State

// required string name = 1;
inline bool XABSLBehavior_Option_State::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XABSLBehavior_Option_State::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XABSLBehavior_Option_State::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XABSLBehavior_Option_State::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& XABSLBehavior_Option_State::name() const {
  return *name_;
}
inline void XABSLBehavior_Option_State::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLBehavior_Option_State::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLBehavior_Option_State::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLBehavior_Option_State::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* XABSLBehavior_Option_State::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional bool target = 2;
inline bool XABSLBehavior_Option_State::has_target() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XABSLBehavior_Option_State::set_has_target() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XABSLBehavior_Option_State::clear_has_target() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XABSLBehavior_Option_State::clear_target() {
  target_ = false;
  clear_has_target();
}
inline bool XABSLBehavior_Option_State::target() const {
  return target_;
}
inline void XABSLBehavior_Option_State::set_target(bool value) {
  set_has_target();
  target_ = value;
}

// -------------------------------------------------------------------

// XABSLBehavior_Option

// required string name = 1;
inline bool XABSLBehavior_Option::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XABSLBehavior_Option::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XABSLBehavior_Option::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XABSLBehavior_Option::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& XABSLBehavior_Option::name() const {
  return *name_;
}
inline void XABSLBehavior_Option::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLBehavior_Option::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLBehavior_Option::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLBehavior_Option::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* XABSLBehavior_Option::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .naothmessages.XABSLBehavior.Option.State states = 3;
inline int XABSLBehavior_Option::states_size() const {
  return states_.size();
}
inline void XABSLBehavior_Option::clear_states() {
  states_.Clear();
}
inline const ::naothmessages::XABSLBehavior_Option_State& XABSLBehavior_Option::states(int index) const {
  return states_.Get(index);
}
inline ::naothmessages::XABSLBehavior_Option_State* XABSLBehavior_Option::mutable_states(int index) {
  return states_.Mutable(index);
}
inline ::naothmessages::XABSLBehavior_Option_State* XABSLBehavior_Option::add_states() {
  return states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Option_State >&
XABSLBehavior_Option::states() const {
  return states_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Option_State >*
XABSLBehavior_Option::mutable_states() {
  return &states_;
}

// repeated .naothmessages.XABSLSymbol parameters = 2;
inline int XABSLBehavior_Option::parameters_size() const {
  return parameters_.size();
}
inline void XABSLBehavior_Option::clear_parameters() {
  parameters_.Clear();
}
inline const ::naothmessages::XABSLSymbol& XABSLBehavior_Option::parameters(int index) const {
  return parameters_.Get(index);
}
inline ::naothmessages::XABSLSymbol* XABSLBehavior_Option::mutable_parameters(int index) {
  return parameters_.Mutable(index);
}
inline ::naothmessages::XABSLSymbol* XABSLBehavior_Option::add_parameters() {
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLSymbol >&
XABSLBehavior_Option::parameters() const {
  return parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLSymbol >*
XABSLBehavior_Option::mutable_parameters() {
  return &parameters_;
}

// -------------------------------------------------------------------

// XABSLBehavior_Agent

// required string name = 1;
inline bool XABSLBehavior_Agent::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XABSLBehavior_Agent::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XABSLBehavior_Agent::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XABSLBehavior_Agent::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& XABSLBehavior_Agent::name() const {
  return *name_;
}
inline void XABSLBehavior_Agent::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLBehavior_Agent::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLBehavior_Agent::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLBehavior_Agent::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* XABSLBehavior_Agent::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// required string rootOption = 2;
inline bool XABSLBehavior_Agent::has_rootoption() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XABSLBehavior_Agent::set_has_rootoption() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XABSLBehavior_Agent::clear_has_rootoption() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XABSLBehavior_Agent::clear_rootoption() {
  if (rootoption_ != &::google::protobuf::internal::kEmptyString) {
    rootoption_->clear();
  }
  clear_has_rootoption();
}
inline const ::std::string& XABSLBehavior_Agent::rootoption() const {
  return *rootoption_;
}
inline void XABSLBehavior_Agent::set_rootoption(const ::std::string& value) {
  set_has_rootoption();
  if (rootoption_ == &::google::protobuf::internal::kEmptyString) {
    rootoption_ = new ::std::string;
  }
  rootoption_->assign(value);
}
inline void XABSLBehavior_Agent::set_rootoption(const char* value) {
  set_has_rootoption();
  if (rootoption_ == &::google::protobuf::internal::kEmptyString) {
    rootoption_ = new ::std::string;
  }
  rootoption_->assign(value);
}
inline void XABSLBehavior_Agent::set_rootoption(const char* value, size_t size) {
  set_has_rootoption();
  if (rootoption_ == &::google::protobuf::internal::kEmptyString) {
    rootoption_ = new ::std::string;
  }
  rootoption_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLBehavior_Agent::mutable_rootoption() {
  set_has_rootoption();
  if (rootoption_ == &::google::protobuf::internal::kEmptyString) {
    rootoption_ = new ::std::string;
  }
  return rootoption_;
}
inline ::std::string* XABSLBehavior_Agent::release_rootoption() {
  clear_has_rootoption();
  if (rootoption_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rootoption_;
    rootoption_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// XABSLBehavior

// repeated .naothmessages.XABSLBehavior.EnumType enumerations = 10;
inline int XABSLBehavior::enumerations_size() const {
  return enumerations_.size();
}
inline void XABSLBehavior::clear_enumerations() {
  enumerations_.Clear();
}
inline const ::naothmessages::XABSLBehavior_EnumType& XABSLBehavior::enumerations(int index) const {
  return enumerations_.Get(index);
}
inline ::naothmessages::XABSLBehavior_EnumType* XABSLBehavior::mutable_enumerations(int index) {
  return enumerations_.Mutable(index);
}
inline ::naothmessages::XABSLBehavior_EnumType* XABSLBehavior::add_enumerations() {
  return enumerations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_EnumType >&
XABSLBehavior::enumerations() const {
  return enumerations_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_EnumType >*
XABSLBehavior::mutable_enumerations() {
  return &enumerations_;
}

// repeated .naothmessages.XABSLBehavior.Option options = 11;
inline int XABSLBehavior::options_size() const {
  return options_.size();
}
inline void XABSLBehavior::clear_options() {
  options_.Clear();
}
inline const ::naothmessages::XABSLBehavior_Option& XABSLBehavior::options(int index) const {
  return options_.Get(index);
}
inline ::naothmessages::XABSLBehavior_Option* XABSLBehavior::mutable_options(int index) {
  return options_.Mutable(index);
}
inline ::naothmessages::XABSLBehavior_Option* XABSLBehavior::add_options() {
  return options_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Option >&
XABSLBehavior::options() const {
  return options_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Option >*
XABSLBehavior::mutable_options() {
  return &options_;
}

// repeated .naothmessages.XABSLBehavior.Agent agents = 12;
inline int XABSLBehavior::agents_size() const {
  return agents_.size();
}
inline void XABSLBehavior::clear_agents() {
  agents_.Clear();
}
inline const ::naothmessages::XABSLBehavior_Agent& XABSLBehavior::agents(int index) const {
  return agents_.Get(index);
}
inline ::naothmessages::XABSLBehavior_Agent* XABSLBehavior::mutable_agents(int index) {
  return agents_.Mutable(index);
}
inline ::naothmessages::XABSLBehavior_Agent* XABSLBehavior::add_agents() {
  return agents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Agent >&
XABSLBehavior::agents() const {
  return agents_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLBehavior_Agent >*
XABSLBehavior::mutable_agents() {
  return &agents_;
}

// optional .naothmessages.SymbolValueList inputSymbolList = 13;
inline bool XABSLBehavior::has_inputsymbollist() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XABSLBehavior::set_has_inputsymbollist() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XABSLBehavior::clear_has_inputsymbollist() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XABSLBehavior::clear_inputsymbollist() {
  if (inputsymbollist_ != NULL) inputsymbollist_->::naothmessages::SymbolValueList::Clear();
  clear_has_inputsymbollist();
}
inline const ::naothmessages::SymbolValueList& XABSLBehavior::inputsymbollist() const {
  return inputsymbollist_ != NULL ? *inputsymbollist_ : *default_instance_->inputsymbollist_;
}
inline ::naothmessages::SymbolValueList* XABSLBehavior::mutable_inputsymbollist() {
  set_has_inputsymbollist();
  if (inputsymbollist_ == NULL) inputsymbollist_ = new ::naothmessages::SymbolValueList;
  return inputsymbollist_;
}
inline ::naothmessages::SymbolValueList* XABSLBehavior::release_inputsymbollist() {
  clear_has_inputsymbollist();
  ::naothmessages::SymbolValueList* temp = inputsymbollist_;
  inputsymbollist_ = NULL;
  return temp;
}

// optional .naothmessages.SymbolValueList outputSymbolList = 14;
inline bool XABSLBehavior::has_outputsymbollist() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XABSLBehavior::set_has_outputsymbollist() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XABSLBehavior::clear_has_outputsymbollist() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XABSLBehavior::clear_outputsymbollist() {
  if (outputsymbollist_ != NULL) outputsymbollist_->::naothmessages::SymbolValueList::Clear();
  clear_has_outputsymbollist();
}
inline const ::naothmessages::SymbolValueList& XABSLBehavior::outputsymbollist() const {
  return outputsymbollist_ != NULL ? *outputsymbollist_ : *default_instance_->outputsymbollist_;
}
inline ::naothmessages::SymbolValueList* XABSLBehavior::mutable_outputsymbollist() {
  set_has_outputsymbollist();
  if (outputsymbollist_ == NULL) outputsymbollist_ = new ::naothmessages::SymbolValueList;
  return outputsymbollist_;
}
inline ::naothmessages::SymbolValueList* XABSLBehavior::release_outputsymbollist() {
  clear_has_outputsymbollist();
  ::naothmessages::SymbolValueList* temp = outputsymbollist_;
  outputsymbollist_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// XABSLParameter

// optional string name = 1 [default = "unknown"];
inline bool XABSLParameter::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XABSLParameter::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XABSLParameter::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XABSLParameter::clear_name() {
  if (name_ != &_default_name_) {
    name_->assign(_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& XABSLParameter::name() const {
  return *name_;
}
inline void XABSLParameter::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLParameter::set_name(const char* value) {
  set_has_name();
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLParameter::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLParameter::mutable_name() {
  set_has_name();
  if (name_ == &_default_name_) {
    name_ = new ::std::string(_default_name_);
  }
  return name_;
}
inline ::std::string* XABSLParameter::release_name() {
  clear_has_name();
  if (name_ == &_default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&_default_name_);
    return temp;
  }
}

// optional .naothmessages.XABSLParameter.ParamType type = 2 [default = Unknown];
inline bool XABSLParameter::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XABSLParameter::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XABSLParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XABSLParameter::clear_type() {
  type_ = 3;
  clear_has_type();
}
inline ::naothmessages::XABSLParameter_ParamType XABSLParameter::type() const {
  return static_cast< ::naothmessages::XABSLParameter_ParamType >(type_);
}
inline void XABSLParameter::set_type(::naothmessages::XABSLParameter_ParamType value) {
  GOOGLE_DCHECK(::naothmessages::XABSLParameter_ParamType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional double decimalValue = 3;
inline bool XABSLParameter::has_decimalvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XABSLParameter::set_has_decimalvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XABSLParameter::clear_has_decimalvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XABSLParameter::clear_decimalvalue() {
  decimalvalue_ = 0;
  clear_has_decimalvalue();
}
inline double XABSLParameter::decimalvalue() const {
  return decimalvalue_;
}
inline void XABSLParameter::set_decimalvalue(double value) {
  set_has_decimalvalue();
  decimalvalue_ = value;
}

// optional bool boolValue = 4;
inline bool XABSLParameter::has_boolvalue() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XABSLParameter::set_has_boolvalue() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XABSLParameter::clear_has_boolvalue() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XABSLParameter::clear_boolvalue() {
  boolvalue_ = false;
  clear_has_boolvalue();
}
inline bool XABSLParameter::boolvalue() const {
  return boolvalue_;
}
inline void XABSLParameter::set_boolvalue(bool value) {
  set_has_boolvalue();
  boolvalue_ = value;
}

// optional string enumValue = 5;
inline bool XABSLParameter::has_enumvalue() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XABSLParameter::set_has_enumvalue() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XABSLParameter::clear_has_enumvalue() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XABSLParameter::clear_enumvalue() {
  if (enumvalue_ != &::google::protobuf::internal::kEmptyString) {
    enumvalue_->clear();
  }
  clear_has_enumvalue();
}
inline const ::std::string& XABSLParameter::enumvalue() const {
  return *enumvalue_;
}
inline void XABSLParameter::set_enumvalue(const ::std::string& value) {
  set_has_enumvalue();
  if (enumvalue_ == &::google::protobuf::internal::kEmptyString) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(value);
}
inline void XABSLParameter::set_enumvalue(const char* value) {
  set_has_enumvalue();
  if (enumvalue_ == &::google::protobuf::internal::kEmptyString) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(value);
}
inline void XABSLParameter::set_enumvalue(const char* value, size_t size) {
  set_has_enumvalue();
  if (enumvalue_ == &::google::protobuf::internal::kEmptyString) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLParameter::mutable_enumvalue() {
  set_has_enumvalue();
  if (enumvalue_ == &::google::protobuf::internal::kEmptyString) {
    enumvalue_ = new ::std::string;
  }
  return enumvalue_;
}
inline ::std::string* XABSLParameter::release_enumvalue() {
  clear_has_enumvalue();
  if (enumvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enumvalue_;
    enumvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// XABSLAction

// optional .naothmessages.XABSLAction.ActionType type = 1 [default = Unknown];
inline bool XABSLAction::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XABSLAction::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XABSLAction::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XABSLAction::clear_type() {
  type_ = 5;
  clear_has_type();
}
inline ::naothmessages::XABSLAction_ActionType XABSLAction::type() const {
  return static_cast< ::naothmessages::XABSLAction_ActionType >(type_);
}
inline void XABSLAction::set_type(::naothmessages::XABSLAction_ActionType value) {
  GOOGLE_DCHECK(::naothmessages::XABSLAction_ActionType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string name = 2 [default = "unknown"];
inline bool XABSLAction::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XABSLAction::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XABSLAction::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XABSLAction::clear_name() {
  if (name_ != &_default_name_) {
    name_->assign(_default_name_);
  }
  clear_has_name();
}
inline const ::std::string& XABSLAction::name() const {
  return *name_;
}
inline void XABSLAction::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLAction::set_name(const char* value) {
  set_has_name();
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLAction::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLAction::mutable_name() {
  set_has_name();
  if (name_ == &_default_name_) {
    name_ = new ::std::string(_default_name_);
  }
  return name_;
}
inline ::std::string* XABSLAction::release_name() {
  clear_has_name();
  if (name_ == &_default_name_) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&_default_name_);
    return temp;
  }
}

// optional int64 timeOfExecution = 3 [default = 0];
inline bool XABSLAction::has_timeofexecution() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XABSLAction::set_has_timeofexecution() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XABSLAction::clear_has_timeofexecution() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XABSLAction::clear_timeofexecution() {
  timeofexecution_ = GOOGLE_LONGLONG(0);
  clear_has_timeofexecution();
}
inline ::google::protobuf::int64 XABSLAction::timeofexecution() const {
  return timeofexecution_;
}
inline void XABSLAction::set_timeofexecution(::google::protobuf::int64 value) {
  set_has_timeofexecution();
  timeofexecution_ = value;
}

// optional string activeState = 4;
inline bool XABSLAction::has_activestate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XABSLAction::set_has_activestate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XABSLAction::clear_has_activestate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XABSLAction::clear_activestate() {
  if (activestate_ != &::google::protobuf::internal::kEmptyString) {
    activestate_->clear();
  }
  clear_has_activestate();
}
inline const ::std::string& XABSLAction::activestate() const {
  return *activestate_;
}
inline void XABSLAction::set_activestate(const ::std::string& value) {
  set_has_activestate();
  if (activestate_ == &::google::protobuf::internal::kEmptyString) {
    activestate_ = new ::std::string;
  }
  activestate_->assign(value);
}
inline void XABSLAction::set_activestate(const char* value) {
  set_has_activestate();
  if (activestate_ == &::google::protobuf::internal::kEmptyString) {
    activestate_ = new ::std::string;
  }
  activestate_->assign(value);
}
inline void XABSLAction::set_activestate(const char* value, size_t size) {
  set_has_activestate();
  if (activestate_ == &::google::protobuf::internal::kEmptyString) {
    activestate_ = new ::std::string;
  }
  activestate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLAction::mutable_activestate() {
  set_has_activestate();
  if (activestate_ == &::google::protobuf::internal::kEmptyString) {
    activestate_ = new ::std::string;
  }
  return activestate_;
}
inline ::std::string* XABSLAction::release_activestate() {
  clear_has_activestate();
  if (activestate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = activestate_;
    activestate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional int64 stateTime = 5;
inline bool XABSLAction::has_statetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XABSLAction::set_has_statetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XABSLAction::clear_has_statetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XABSLAction::clear_statetime() {
  statetime_ = GOOGLE_LONGLONG(0);
  clear_has_statetime();
}
inline ::google::protobuf::int64 XABSLAction::statetime() const {
  return statetime_;
}
inline void XABSLAction::set_statetime(::google::protobuf::int64 value) {
  set_has_statetime();
  statetime_ = value;
}

// repeated .naothmessages.XABSLParameter parameters = 6;
inline int XABSLAction::parameters_size() const {
  return parameters_.size();
}
inline void XABSLAction::clear_parameters() {
  parameters_.Clear();
}
inline const ::naothmessages::XABSLParameter& XABSLAction::parameters(int index) const {
  return parameters_.Get(index);
}
inline ::naothmessages::XABSLParameter* XABSLAction::mutable_parameters(int index) {
  return parameters_.Mutable(index);
}
inline ::naothmessages::XABSLParameter* XABSLAction::add_parameters() {
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
XABSLAction::parameters() const {
  return parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
XABSLAction::mutable_parameters() {
  return &parameters_;
}

// repeated .naothmessages.XABSLAction activeSubActions = 7;
inline int XABSLAction::activesubactions_size() const {
  return activesubactions_.size();
}
inline void XABSLAction::clear_activesubactions() {
  activesubactions_.Clear();
}
inline const ::naothmessages::XABSLAction& XABSLAction::activesubactions(int index) const {
  return activesubactions_.Get(index);
}
inline ::naothmessages::XABSLAction* XABSLAction::mutable_activesubactions(int index) {
  return activesubactions_.Mutable(index);
}
inline ::naothmessages::XABSLAction* XABSLAction::add_activesubactions() {
  return activesubactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >&
XABSLAction::activesubactions() const {
  return activesubactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >*
XABSLAction::mutable_activesubactions() {
  return &activesubactions_;
}

// optional double decimalValue = 8;
inline bool XABSLAction::has_decimalvalue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void XABSLAction::set_has_decimalvalue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void XABSLAction::clear_has_decimalvalue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void XABSLAction::clear_decimalvalue() {
  decimalvalue_ = 0;
  clear_has_decimalvalue();
}
inline double XABSLAction::decimalvalue() const {
  return decimalvalue_;
}
inline void XABSLAction::set_decimalvalue(double value) {
  set_has_decimalvalue();
  decimalvalue_ = value;
}

// optional bool boolValue = 9;
inline bool XABSLAction::has_boolvalue() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void XABSLAction::set_has_boolvalue() {
  _has_bits_[0] |= 0x00000100u;
}
inline void XABSLAction::clear_has_boolvalue() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void XABSLAction::clear_boolvalue() {
  boolvalue_ = false;
  clear_has_boolvalue();
}
inline bool XABSLAction::boolvalue() const {
  return boolvalue_;
}
inline void XABSLAction::set_boolvalue(bool value) {
  set_has_boolvalue();
  boolvalue_ = value;
}

// optional string enumValue = 10;
inline bool XABSLAction::has_enumvalue() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void XABSLAction::set_has_enumvalue() {
  _has_bits_[0] |= 0x00000200u;
}
inline void XABSLAction::clear_has_enumvalue() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void XABSLAction::clear_enumvalue() {
  if (enumvalue_ != &::google::protobuf::internal::kEmptyString) {
    enumvalue_->clear();
  }
  clear_has_enumvalue();
}
inline const ::std::string& XABSLAction::enumvalue() const {
  return *enumvalue_;
}
inline void XABSLAction::set_enumvalue(const ::std::string& value) {
  set_has_enumvalue();
  if (enumvalue_ == &::google::protobuf::internal::kEmptyString) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(value);
}
inline void XABSLAction::set_enumvalue(const char* value) {
  set_has_enumvalue();
  if (enumvalue_ == &::google::protobuf::internal::kEmptyString) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(value);
}
inline void XABSLAction::set_enumvalue(const char* value, size_t size) {
  set_has_enumvalue();
  if (enumvalue_ == &::google::protobuf::internal::kEmptyString) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLAction::mutable_enumvalue() {
  set_has_enumvalue();
  if (enumvalue_ == &::google::protobuf::internal::kEmptyString) {
    enumvalue_ = new ::std::string;
  }
  return enumvalue_;
}
inline ::std::string* XABSLAction::release_enumvalue() {
  clear_has_enumvalue();
  if (enumvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enumvalue_;
    enumvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// BehaviorStatus

// optional string agent = 1;
inline bool BehaviorStatus::has_agent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BehaviorStatus::set_has_agent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BehaviorStatus::clear_has_agent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BehaviorStatus::clear_agent() {
  if (agent_ != &::google::protobuf::internal::kEmptyString) {
    agent_->clear();
  }
  clear_has_agent();
}
inline const ::std::string& BehaviorStatus::agent() const {
  return *agent_;
}
inline void BehaviorStatus::set_agent(const ::std::string& value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void BehaviorStatus::set_agent(const char* value) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void BehaviorStatus::set_agent(const char* value, size_t size) {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorStatus::mutable_agent() {
  set_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    agent_ = new ::std::string;
  }
  return agent_;
}
inline ::std::string* BehaviorStatus::release_agent() {
  clear_has_agent();
  if (agent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = agent_;
    agent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .naothmessages.XABSLAction activeRootActions = 2;
inline int BehaviorStatus::activerootactions_size() const {
  return activerootactions_.size();
}
inline void BehaviorStatus::clear_activerootactions() {
  activerootactions_.Clear();
}
inline const ::naothmessages::XABSLAction& BehaviorStatus::activerootactions(int index) const {
  return activerootactions_.Get(index);
}
inline ::naothmessages::XABSLAction* BehaviorStatus::mutable_activerootactions(int index) {
  return activerootactions_.Mutable(index);
}
inline ::naothmessages::XABSLAction* BehaviorStatus::add_activerootactions() {
  return activerootactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >&
BehaviorStatus::activerootactions() const {
  return activerootactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >*
BehaviorStatus::mutable_activerootactions() {
  return &activerootactions_;
}

// repeated .naothmessages.XABSLParameter inputSymbols = 3;
inline int BehaviorStatus::inputsymbols_size() const {
  return inputsymbols_.size();
}
inline void BehaviorStatus::clear_inputsymbols() {
  inputsymbols_.Clear();
}
inline const ::naothmessages::XABSLParameter& BehaviorStatus::inputsymbols(int index) const {
  return inputsymbols_.Get(index);
}
inline ::naothmessages::XABSLParameter* BehaviorStatus::mutable_inputsymbols(int index) {
  return inputsymbols_.Mutable(index);
}
inline ::naothmessages::XABSLParameter* BehaviorStatus::add_inputsymbols() {
  return inputsymbols_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
BehaviorStatus::inputsymbols() const {
  return inputsymbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
BehaviorStatus::mutable_inputsymbols() {
  return &inputsymbols_;
}

// repeated .naothmessages.XABSLParameter outputSymbols = 4;
inline int BehaviorStatus::outputsymbols_size() const {
  return outputsymbols_.size();
}
inline void BehaviorStatus::clear_outputsymbols() {
  outputsymbols_.Clear();
}
inline const ::naothmessages::XABSLParameter& BehaviorStatus::outputsymbols(int index) const {
  return outputsymbols_.Get(index);
}
inline ::naothmessages::XABSLParameter* BehaviorStatus::mutable_outputsymbols(int index) {
  return outputsymbols_.Mutable(index);
}
inline ::naothmessages::XABSLParameter* BehaviorStatus::add_outputsymbols() {
  return outputsymbols_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
BehaviorStatus::outputsymbols() const {
  return outputsymbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
BehaviorStatus::mutable_outputsymbols() {
  return &outputsymbols_;
}

// optional uint32 frameNumber = 5;
inline bool BehaviorStatus::has_framenumber() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BehaviorStatus::set_has_framenumber() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BehaviorStatus::clear_has_framenumber() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BehaviorStatus::clear_framenumber() {
  framenumber_ = 0u;
  clear_has_framenumber();
}
inline ::google::protobuf::uint32 BehaviorStatus::framenumber() const {
  return framenumber_;
}
inline void BehaviorStatus::set_framenumber(::google::protobuf::uint32 value) {
  set_has_framenumber();
  framenumber_ = value;
}

// optional string errorMessage = 6;
inline bool BehaviorStatus::has_errormessage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BehaviorStatus::set_has_errormessage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BehaviorStatus::clear_has_errormessage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BehaviorStatus::clear_errormessage() {
  if (errormessage_ != &::google::protobuf::internal::kEmptyString) {
    errormessage_->clear();
  }
  clear_has_errormessage();
}
inline const ::std::string& BehaviorStatus::errormessage() const {
  return *errormessage_;
}
inline void BehaviorStatus::set_errormessage(const ::std::string& value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void BehaviorStatus::set_errormessage(const char* value) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(value);
}
inline void BehaviorStatus::set_errormessage(const char* value, size_t size) {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  errormessage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorStatus::mutable_errormessage() {
  set_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    errormessage_ = new ::std::string;
  }
  return errormessage_;
}
inline ::std::string* BehaviorStatus::release_errormessage() {
  clear_has_errormessage();
  if (errormessage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = errormessage_;
    errormessage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Module

// required string name = 1;
inline bool Module::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Module::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Module::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Module::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Module::name() const {
  return *name_;
}
inline void Module::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Module::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Module::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Module::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Module::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated string usedRepresentations = 2;
inline int Module::usedrepresentations_size() const {
  return usedrepresentations_.size();
}
inline void Module::clear_usedrepresentations() {
  usedrepresentations_.Clear();
}
inline const ::std::string& Module::usedrepresentations(int index) const {
  return usedrepresentations_.Get(index);
}
inline ::std::string* Module::mutable_usedrepresentations(int index) {
  return usedrepresentations_.Mutable(index);
}
inline void Module::set_usedrepresentations(int index, const ::std::string& value) {
  usedrepresentations_.Mutable(index)->assign(value);
}
inline void Module::set_usedrepresentations(int index, const char* value) {
  usedrepresentations_.Mutable(index)->assign(value);
}
inline void Module::set_usedrepresentations(int index, const char* value, size_t size) {
  usedrepresentations_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Module::add_usedrepresentations() {
  return usedrepresentations_.Add();
}
inline void Module::add_usedrepresentations(const ::std::string& value) {
  usedrepresentations_.Add()->assign(value);
}
inline void Module::add_usedrepresentations(const char* value) {
  usedrepresentations_.Add()->assign(value);
}
inline void Module::add_usedrepresentations(const char* value, size_t size) {
  usedrepresentations_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Module::usedrepresentations() const {
  return usedrepresentations_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Module::mutable_usedrepresentations() {
  return &usedrepresentations_;
}

// repeated string providedRepresentations = 3;
inline int Module::providedrepresentations_size() const {
  return providedrepresentations_.size();
}
inline void Module::clear_providedrepresentations() {
  providedrepresentations_.Clear();
}
inline const ::std::string& Module::providedrepresentations(int index) const {
  return providedrepresentations_.Get(index);
}
inline ::std::string* Module::mutable_providedrepresentations(int index) {
  return providedrepresentations_.Mutable(index);
}
inline void Module::set_providedrepresentations(int index, const ::std::string& value) {
  providedrepresentations_.Mutable(index)->assign(value);
}
inline void Module::set_providedrepresentations(int index, const char* value) {
  providedrepresentations_.Mutable(index)->assign(value);
}
inline void Module::set_providedrepresentations(int index, const char* value, size_t size) {
  providedrepresentations_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Module::add_providedrepresentations() {
  return providedrepresentations_.Add();
}
inline void Module::add_providedrepresentations(const ::std::string& value) {
  providedrepresentations_.Add()->assign(value);
}
inline void Module::add_providedrepresentations(const char* value) {
  providedrepresentations_.Add()->assign(value);
}
inline void Module::add_providedrepresentations(const char* value, size_t size) {
  providedrepresentations_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Module::providedrepresentations() const {
  return providedrepresentations_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Module::mutable_providedrepresentations() {
  return &providedrepresentations_;
}

// optional bool active = 4 [default = false];
inline bool Module::has_active() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Module::set_has_active() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Module::clear_has_active() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Module::clear_active() {
  active_ = false;
  clear_has_active();
}
inline bool Module::active() const {
  return active_;
}
inline void Module::set_active(bool value) {
  set_has_active();
  active_ = value;
}

// -------------------------------------------------------------------

// ModuleList

// repeated .naothmessages.Module modules = 1;
inline int ModuleList::modules_size() const {
  return modules_.size();
}
inline void ModuleList::clear_modules() {
  modules_.Clear();
}
inline const ::naothmessages::Module& ModuleList::modules(int index) const {
  return modules_.Get(index);
}
inline ::naothmessages::Module* ModuleList::mutable_modules(int index) {
  return modules_.Mutable(index);
}
inline ::naothmessages::Module* ModuleList::add_modules() {
  return modules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Module >&
ModuleList::modules() const {
  return modules_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Module >*
ModuleList::mutable_modules() {
  return &modules_;
}

// -------------------------------------------------------------------

// FeatureKeyPoint

// required .naothmessages.FloatVector2 pt = 1;
inline bool FeatureKeyPoint::has_pt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureKeyPoint::set_has_pt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureKeyPoint::clear_has_pt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureKeyPoint::clear_pt() {
  if (pt_ != NULL) pt_->::naothmessages::FloatVector2::Clear();
  clear_has_pt();
}
inline const ::naothmessages::FloatVector2& FeatureKeyPoint::pt() const {
  return pt_ != NULL ? *pt_ : *default_instance_->pt_;
}
inline ::naothmessages::FloatVector2* FeatureKeyPoint::mutable_pt() {
  set_has_pt();
  if (pt_ == NULL) pt_ = new ::naothmessages::FloatVector2;
  return pt_;
}
inline ::naothmessages::FloatVector2* FeatureKeyPoint::release_pt() {
  clear_has_pt();
  ::naothmessages::FloatVector2* temp = pt_;
  pt_ = NULL;
  return temp;
}

// required float size = 2;
inline bool FeatureKeyPoint::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureKeyPoint::set_has_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureKeyPoint::clear_has_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeatureKeyPoint::clear_size() {
  size_ = 0;
  clear_has_size();
}
inline float FeatureKeyPoint::size() const {
  return size_;
}
inline void FeatureKeyPoint::set_size(float value) {
  set_has_size();
  size_ = value;
}

// required float angle = 3;
inline bool FeatureKeyPoint::has_angle() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeatureKeyPoint::set_has_angle() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeatureKeyPoint::clear_has_angle() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeatureKeyPoint::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline float FeatureKeyPoint::angle() const {
  return angle_;
}
inline void FeatureKeyPoint::set_angle(float value) {
  set_has_angle();
  angle_ = value;
}

// required float response = 4;
inline bool FeatureKeyPoint::has_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FeatureKeyPoint::set_has_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FeatureKeyPoint::clear_has_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FeatureKeyPoint::clear_response() {
  response_ = 0;
  clear_has_response();
}
inline float FeatureKeyPoint::response() const {
  return response_;
}
inline void FeatureKeyPoint::set_response(float value) {
  set_has_response();
  response_ = value;
}

// required int32 octave = 5;
inline bool FeatureKeyPoint::has_octave() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeatureKeyPoint::set_has_octave() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeatureKeyPoint::clear_has_octave() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FeatureKeyPoint::clear_octave() {
  octave_ = 0;
  clear_has_octave();
}
inline ::google::protobuf::int32 FeatureKeyPoint::octave() const {
  return octave_;
}
inline void FeatureKeyPoint::set_octave(::google::protobuf::int32 value) {
  set_has_octave();
  octave_ = value;
}

// required int32 class_id = 6;
inline bool FeatureKeyPoint::has_class_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void FeatureKeyPoint::set_has_class_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void FeatureKeyPoint::clear_has_class_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void FeatureKeyPoint::clear_class_id() {
  class_id_ = 0;
  clear_has_class_id();
}
inline ::google::protobuf::int32 FeatureKeyPoint::class_id() const {
  return class_id_;
}
inline void FeatureKeyPoint::set_class_id(::google::protobuf::int32 value) {
  set_has_class_id();
  class_id_ = value;
}

// -------------------------------------------------------------------

// FeatureDetectionResult

// required bytes grayScaleImage = 1;
inline bool FeatureDetectionResult::has_grayscaleimage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureDetectionResult::set_has_grayscaleimage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureDetectionResult::clear_has_grayscaleimage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureDetectionResult::clear_grayscaleimage() {
  if (grayscaleimage_ != &::google::protobuf::internal::kEmptyString) {
    grayscaleimage_->clear();
  }
  clear_has_grayscaleimage();
}
inline const ::std::string& FeatureDetectionResult::grayscaleimage() const {
  return *grayscaleimage_;
}
inline void FeatureDetectionResult::set_grayscaleimage(const ::std::string& value) {
  set_has_grayscaleimage();
  if (grayscaleimage_ == &::google::protobuf::internal::kEmptyString) {
    grayscaleimage_ = new ::std::string;
  }
  grayscaleimage_->assign(value);
}
inline void FeatureDetectionResult::set_grayscaleimage(const char* value) {
  set_has_grayscaleimage();
  if (grayscaleimage_ == &::google::protobuf::internal::kEmptyString) {
    grayscaleimage_ = new ::std::string;
  }
  grayscaleimage_->assign(value);
}
inline void FeatureDetectionResult::set_grayscaleimage(const void* value, size_t size) {
  set_has_grayscaleimage();
  if (grayscaleimage_ == &::google::protobuf::internal::kEmptyString) {
    grayscaleimage_ = new ::std::string;
  }
  grayscaleimage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureDetectionResult::mutable_grayscaleimage() {
  set_has_grayscaleimage();
  if (grayscaleimage_ == &::google::protobuf::internal::kEmptyString) {
    grayscaleimage_ = new ::std::string;
  }
  return grayscaleimage_;
}
inline ::std::string* FeatureDetectionResult::release_grayscaleimage() {
  clear_has_grayscaleimage();
  if (grayscaleimage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = grayscaleimage_;
    grayscaleimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .naothmessages.FeatureKeyPoint keyPoints = 2;
inline int FeatureDetectionResult::keypoints_size() const {
  return keypoints_.size();
}
inline void FeatureDetectionResult::clear_keypoints() {
  keypoints_.Clear();
}
inline const ::naothmessages::FeatureKeyPoint& FeatureDetectionResult::keypoints(int index) const {
  return keypoints_.Get(index);
}
inline ::naothmessages::FeatureKeyPoint* FeatureDetectionResult::mutable_keypoints(int index) {
  return keypoints_.Mutable(index);
}
inline ::naothmessages::FeatureKeyPoint* FeatureDetectionResult::add_keypoints() {
  return keypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureKeyPoint >&
FeatureDetectionResult::keypoints() const {
  return keypoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureKeyPoint >*
FeatureDetectionResult::mutable_keypoints() {
  return &keypoints_;
}

// repeated .naothmessages.SingleDescriptor descriptors = 3;
inline int FeatureDetectionResult::descriptors_size() const {
  return descriptors_.size();
}
inline void FeatureDetectionResult::clear_descriptors() {
  descriptors_.Clear();
}
inline const ::naothmessages::SingleDescriptor& FeatureDetectionResult::descriptors(int index) const {
  return descriptors_.Get(index);
}
inline ::naothmessages::SingleDescriptor* FeatureDetectionResult::mutable_descriptors(int index) {
  return descriptors_.Mutable(index);
}
inline ::naothmessages::SingleDescriptor* FeatureDetectionResult::add_descriptors() {
  return descriptors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >&
FeatureDetectionResult::descriptors() const {
  return descriptors_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >*
FeatureDetectionResult::mutable_descriptors() {
  return &descriptors_;
}

// repeated string namesForKeyPoints = 4;
inline int FeatureDetectionResult::namesforkeypoints_size() const {
  return namesforkeypoints_.size();
}
inline void FeatureDetectionResult::clear_namesforkeypoints() {
  namesforkeypoints_.Clear();
}
inline const ::std::string& FeatureDetectionResult::namesforkeypoints(int index) const {
  return namesforkeypoints_.Get(index);
}
inline ::std::string* FeatureDetectionResult::mutable_namesforkeypoints(int index) {
  return namesforkeypoints_.Mutable(index);
}
inline void FeatureDetectionResult::set_namesforkeypoints(int index, const ::std::string& value) {
  namesforkeypoints_.Mutable(index)->assign(value);
}
inline void FeatureDetectionResult::set_namesforkeypoints(int index, const char* value) {
  namesforkeypoints_.Mutable(index)->assign(value);
}
inline void FeatureDetectionResult::set_namesforkeypoints(int index, const char* value, size_t size) {
  namesforkeypoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureDetectionResult::add_namesforkeypoints() {
  return namesforkeypoints_.Add();
}
inline void FeatureDetectionResult::add_namesforkeypoints(const ::std::string& value) {
  namesforkeypoints_.Add()->assign(value);
}
inline void FeatureDetectionResult::add_namesforkeypoints(const char* value) {
  namesforkeypoints_.Add()->assign(value);
}
inline void FeatureDetectionResult::add_namesforkeypoints(const char* value, size_t size) {
  namesforkeypoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FeatureDetectionResult::namesforkeypoints() const {
  return namesforkeypoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FeatureDetectionResult::mutable_namesforkeypoints() {
  return &namesforkeypoints_;
}

// optional int32 numberOfFeatureElements = 5 [default = 64];
inline bool FeatureDetectionResult::has_numberoffeatureelements() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FeatureDetectionResult::set_has_numberoffeatureelements() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FeatureDetectionResult::clear_has_numberoffeatureelements() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FeatureDetectionResult::clear_numberoffeatureelements() {
  numberoffeatureelements_ = 64;
  clear_has_numberoffeatureelements();
}
inline ::google::protobuf::int32 FeatureDetectionResult::numberoffeatureelements() const {
  return numberoffeatureelements_;
}
inline void FeatureDetectionResult::set_numberoffeatureelements(::google::protobuf::int32 value) {
  set_has_numberoffeatureelements();
  numberoffeatureelements_ = value;
}

// -------------------------------------------------------------------

// SingleDescriptor

// repeated float d = 1;
inline int SingleDescriptor::d_size() const {
  return d_.size();
}
inline void SingleDescriptor::clear_d() {
  d_.Clear();
}
inline float SingleDescriptor::d(int index) const {
  return d_.Get(index);
}
inline void SingleDescriptor::set_d(int index, float value) {
  d_.Set(index, value);
}
inline void SingleDescriptor::add_d(float value) {
  d_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SingleDescriptor::d() const {
  return d_;
}
inline ::google::protobuf::RepeatedField< float >*
SingleDescriptor::mutable_d() {
  return &d_;
}

// -------------------------------------------------------------------

// FeatureClass

// required string name = 1;
inline bool FeatureClass::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FeatureClass::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FeatureClass::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FeatureClass::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& FeatureClass::name() const {
  return *name_;
}
inline void FeatureClass::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FeatureClass::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FeatureClass::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureClass::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* FeatureClass::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// repeated .naothmessages.SingleDescriptor samples = 2;
inline int FeatureClass::samples_size() const {
  return samples_.size();
}
inline void FeatureClass::clear_samples() {
  samples_.Clear();
}
inline const ::naothmessages::SingleDescriptor& FeatureClass::samples(int index) const {
  return samples_.Get(index);
}
inline ::naothmessages::SingleDescriptor* FeatureClass::mutable_samples(int index) {
  return samples_.Mutable(index);
}
inline ::naothmessages::SingleDescriptor* FeatureClass::add_samples() {
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >&
FeatureClass::samples() const {
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >*
FeatureClass::mutable_samples() {
  return &samples_;
}

// optional double objectHeight = 3;
inline bool FeatureClass::has_objectheight() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FeatureClass::set_has_objectheight() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FeatureClass::clear_has_objectheight() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FeatureClass::clear_objectheight() {
  objectheight_ = 0;
  clear_has_objectheight();
}
inline double FeatureClass::objectheight() const {
  return objectheight_;
}
inline void FeatureClass::set_objectheight(double value) {
  set_has_objectheight();
  objectheight_ = value;
}

// -------------------------------------------------------------------

// FeatureTable

// repeated .naothmessages.FeatureClass classes = 1;
inline int FeatureTable::classes_size() const {
  return classes_.size();
}
inline void FeatureTable::clear_classes() {
  classes_.Clear();
}
inline const ::naothmessages::FeatureClass& FeatureTable::classes(int index) const {
  return classes_.Get(index);
}
inline ::naothmessages::FeatureClass* FeatureTable::mutable_classes(int index) {
  return classes_.Mutable(index);
}
inline ::naothmessages::FeatureClass* FeatureTable::add_classes() {
  return classes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureClass >&
FeatureTable::classes() const {
  return classes_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureClass >*
FeatureTable::mutable_classes() {
  return &classes_;
}

// optional int32 numberOfFeatureElements = 2 [default = 64];
inline bool FeatureTable::has_numberoffeatureelements() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FeatureTable::set_has_numberoffeatureelements() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FeatureTable::clear_has_numberoffeatureelements() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FeatureTable::clear_numberoffeatureelements() {
  numberoffeatureelements_ = 64;
  clear_has_numberoffeatureelements();
}
inline ::google::protobuf::int32 FeatureTable::numberoffeatureelements() const {
  return numberoffeatureelements_;
}
inline void FeatureTable::set_numberoffeatureelements(::google::protobuf::int32 value) {
  set_has_numberoffeatureelements();
  numberoffeatureelements_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace naothmessages

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::PlotItem_PlotType>() {
  return ::naothmessages::PlotItem_PlotType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::XABSLSymbol_SymbolType>() {
  return ::naothmessages::XABSLSymbol_SymbolType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::XABSLActionSparse_ActionType>() {
  return ::naothmessages::XABSLActionSparse_ActionType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::XABSLParameter_ParamType>() {
  return ::naothmessages::XABSLParameter_ParamType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::XABSLAction_ActionType>() {
  return ::naothmessages::XABSLAction_ActionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Messages_2eproto__INCLUDED


// added by NaoTH 
#if defined(__GNUC__) && defined(_NAOTH_CHECK_CONVERSION_)
#if __GNUC__ > 3 && __GNUC_MINOR__ > 5
#pragma GCC diagnostic pop
#else
#pragma GCC diagnostic error "-Wconversion"
#endif
#endif

