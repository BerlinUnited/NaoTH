// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Messages.proto

#ifndef PROTOBUF_Messages_2eproto__INCLUDED
#define PROTOBUF_Messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "CommonTypes.pb.h"
// @@protoc_insertion_point(includes)

namespace naothmessages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Messages_2eproto();
void protobuf_AssignDesc_Messages_2eproto();
void protobuf_ShutdownFile_Messages_2eproto();

class CMDArg;
class Command;
class CommandList;
class PlayerModel;
class TeamCommMessage;
class StopwatchItem;
class Stopwatches;
class PlotItem;
class Plots;
class XABSLParameter;
class XABSLAction;
class BehaviorStatus;
class Module;
class ModuleList;
class FeatureKeyPoint;
class FeatureDetectionResult;
class SingleDescriptor;
class FeatureClass;
class FeatureTable;

enum PlotItem_PlotType {
  PlotItem_PlotType_Default = 1,
  PlotItem_PlotType_Plot2D = 2,
  PlotItem_PlotType_Origin2D = 3
};
bool PlotItem_PlotType_IsValid(int value);
const PlotItem_PlotType PlotItem_PlotType_PlotType_MIN = PlotItem_PlotType_Default;
const PlotItem_PlotType PlotItem_PlotType_PlotType_MAX = PlotItem_PlotType_Origin2D;
const int PlotItem_PlotType_PlotType_ARRAYSIZE = PlotItem_PlotType_PlotType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PlotItem_PlotType_descriptor();
inline const ::std::string& PlotItem_PlotType_Name(PlotItem_PlotType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PlotItem_PlotType_descriptor(), value);
}
inline bool PlotItem_PlotType_Parse(
    const ::std::string& name, PlotItem_PlotType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PlotItem_PlotType>(
    PlotItem_PlotType_descriptor(), name, value);
}
enum XABSLParameter_ParamType {
  XABSLParameter_ParamType_Decimal = 0,
  XABSLParameter_ParamType_Boolean = 1,
  XABSLParameter_ParamType_Enum = 2,
  XABSLParameter_ParamType_Unknown = 3
};
bool XABSLParameter_ParamType_IsValid(int value);
const XABSLParameter_ParamType XABSLParameter_ParamType_ParamType_MIN = XABSLParameter_ParamType_Decimal;
const XABSLParameter_ParamType XABSLParameter_ParamType_ParamType_MAX = XABSLParameter_ParamType_Unknown;
const int XABSLParameter_ParamType_ParamType_ARRAYSIZE = XABSLParameter_ParamType_ParamType_MAX + 1;

const ::google::protobuf::EnumDescriptor* XABSLParameter_ParamType_descriptor();
inline const ::std::string& XABSLParameter_ParamType_Name(XABSLParameter_ParamType value) {
  return ::google::protobuf::internal::NameOfEnum(
    XABSLParameter_ParamType_descriptor(), value);
}
inline bool XABSLParameter_ParamType_Parse(
    const ::std::string& name, XABSLParameter_ParamType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XABSLParameter_ParamType>(
    XABSLParameter_ParamType_descriptor(), name, value);
}
enum XABSLAction_ActionType {
  XABSLAction_ActionType_Option = 0,
  XABSLAction_ActionType_BasicBehavior = 1,
  XABSLAction_ActionType_DecimalOutputSymbol = 2,
  XABSLAction_ActionType_BooleanOutputSymbol = 3,
  XABSLAction_ActionType_EnumOutputSymbol = 4,
  XABSLAction_ActionType_Unknown = 5
};
bool XABSLAction_ActionType_IsValid(int value);
const XABSLAction_ActionType XABSLAction_ActionType_ActionType_MIN = XABSLAction_ActionType_Option;
const XABSLAction_ActionType XABSLAction_ActionType_ActionType_MAX = XABSLAction_ActionType_Unknown;
const int XABSLAction_ActionType_ActionType_ARRAYSIZE = XABSLAction_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* XABSLAction_ActionType_descriptor();
inline const ::std::string& XABSLAction_ActionType_Name(XABSLAction_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    XABSLAction_ActionType_descriptor(), value);
}
inline bool XABSLAction_ActionType_Parse(
    const ::std::string& name, XABSLAction_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XABSLAction_ActionType>(
    XABSLAction_ActionType_descriptor(), name, value);
}
// ===================================================================

class CMDArg : public ::google::protobuf::Message {
 public:
  CMDArg();
  virtual ~CMDArg();
  
  CMDArg(const CMDArg& from);
  
  inline CMDArg& operator=(const CMDArg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CMDArg& default_instance();
  
  void Swap(CMDArg* other);
  
  // implements Message ----------------------------------------------
  
  CMDArg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CMDArg& from);
  void MergeFrom(const CMDArg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  
  // optional bytes value_bytes = 3;
  inline bool has_value_bytes() const;
  inline void clear_value_bytes();
  static const int kValueBytesFieldNumber = 3;
  inline const ::std::string& value_bytes() const;
  inline void set_value_bytes(const ::std::string& value);
  inline void set_value_bytes(const char* value);
  inline void set_value_bytes(const void* value, size_t size);
  inline ::std::string* mutable_value_bytes();
  
  // @@protoc_insertion_point(class_scope:naothmessages.CMDArg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::std::string* value_;
  static const ::std::string _default_value_;
  ::std::string* value_bytes_;
  static const ::std::string _default_value_bytes_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CMDArg* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();
  
  Command(const Command& from);
  
  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();
  
  void Swap(Command* other);
  
  // implements Message ----------------------------------------------
  
  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // repeated .naothmessages.CMDArg args = 2;
  inline int args_size() const;
  inline void clear_args();
  static const int kArgsFieldNumber = 2;
  inline const ::naothmessages::CMDArg& args(int index) const;
  inline ::naothmessages::CMDArg* mutable_args(int index);
  inline ::naothmessages::CMDArg* add_args();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::CMDArg >&
      args() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::CMDArg >*
      mutable_args();
  
  // @@protoc_insertion_point(class_scope:naothmessages.Command)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::CMDArg > args_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class CommandList : public ::google::protobuf::Message {
 public:
  CommandList();
  virtual ~CommandList();
  
  CommandList(const CommandList& from);
  
  inline CommandList& operator=(const CommandList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CommandList& default_instance();
  
  void Swap(CommandList* other);
  
  // implements Message ----------------------------------------------
  
  CommandList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CommandList& from);
  void MergeFrom(const CommandList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.Command cmd = 1;
  inline int cmd_size() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline const ::naothmessages::Command& cmd(int index) const;
  inline ::naothmessages::Command* mutable_cmd(int index);
  inline ::naothmessages::Command* add_cmd();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Command >&
      cmd() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Command >*
      mutable_cmd();
  
  // @@protoc_insertion_point(class_scope:naothmessages.CommandList)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::Command > cmd_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static CommandList* default_instance_;
};
// -------------------------------------------------------------------

class PlayerModel : public ::google::protobuf::Message {
 public:
  PlayerModel();
  virtual ~PlayerModel();
  
  PlayerModel(const PlayerModel& from);
  
  inline PlayerModel& operator=(const PlayerModel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerModel& default_instance();
  
  void Swap(PlayerModel* other);
  
  // implements Message ----------------------------------------------
  
  PlayerModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerModel& from);
  void MergeFrom(const PlayerModel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 number = 1;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 1;
  inline ::google::protobuf::int32 number() const;
  inline void set_number(::google::protobuf::int32 value);
  
  // optional .naothmessages.Pose2D poseOnField = 2;
  inline bool has_poseonfield() const;
  inline void clear_poseonfield();
  static const int kPoseOnFieldFieldNumber = 2;
  inline const ::naothmessages::Pose2D& poseonfield() const;
  inline ::naothmessages::Pose2D* mutable_poseonfield();
  
  // @@protoc_insertion_point(class_scope:naothmessages.PlayerModel)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 number_;
  ::naothmessages::Pose2D* poseonfield_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PlayerModel* default_instance_;
};
// -------------------------------------------------------------------

class TeamCommMessage : public ::google::protobuf::Message {
 public:
  TeamCommMessage();
  virtual ~TeamCommMessage();
  
  TeamCommMessage(const TeamCommMessage& from);
  
  inline TeamCommMessage& operator=(const TeamCommMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamCommMessage& default_instance();
  
  void Swap(TeamCommMessage* other);
  
  // implements Message ----------------------------------------------
  
  TeamCommMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamCommMessage& from);
  void MergeFrom(const TeamCommMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 playerNumber = 1;
  inline bool has_playernumber() const;
  inline void clear_playernumber();
  static const int kPlayerNumberFieldNumber = 1;
  inline ::google::protobuf::int32 playernumber() const;
  inline void set_playernumber(::google::protobuf::int32 value);
  
  // required int32 teamNumber = 2;
  inline bool has_teamnumber() const;
  inline void clear_teamnumber();
  static const int kTeamNumberFieldNumber = 2;
  inline ::google::protobuf::int32 teamnumber() const;
  inline void set_teamnumber(::google::protobuf::int32 value);
  
  // optional bool wasStriker = 3 [default = false];
  inline bool has_wasstriker() const;
  inline void clear_wasstriker();
  static const int kWasStrikerFieldNumber = 3;
  inline bool wasstriker() const;
  inline void set_wasstriker(bool value);
  
  // optional bool isPenalized = 4 [default = false];
  inline bool has_ispenalized() const;
  inline void clear_ispenalized();
  static const int kIsPenalizedFieldNumber = 4;
  inline bool ispenalized() const;
  inline void set_ispenalized(bool value);
  
  // optional double timeSinceBallWasSeen = 5;
  inline bool has_timesinceballwasseen() const;
  inline void clear_timesinceballwasseen();
  static const int kTimeSinceBallWasSeenFieldNumber = 5;
  inline double timesinceballwasseen() const;
  inline void set_timesinceballwasseen(double value);
  
  // optional .naothmessages.DoubleVector2 ballPosition = 6;
  inline bool has_ballposition() const;
  inline void clear_ballposition();
  static const int kBallPositionFieldNumber = 6;
  inline const ::naothmessages::DoubleVector2& ballposition() const;
  inline ::naothmessages::DoubleVector2* mutable_ballposition();
  
  // optional .naothmessages.Pose2D positionOnField = 7;
  inline bool has_positiononfield() const;
  inline void clear_positiononfield();
  static const int kPositionOnFieldFieldNumber = 7;
  inline const ::naothmessages::Pose2D& positiononfield() const;
  inline ::naothmessages::Pose2D* mutable_positiononfield();
  
  // optional .naothmessages.PlayerModel opponent = 8;
  inline bool has_opponent() const;
  inline void clear_opponent();
  static const int kOpponentFieldNumber = 8;
  inline const ::naothmessages::PlayerModel& opponent() const;
  inline ::naothmessages::PlayerModel* mutable_opponent();
  
  // @@protoc_insertion_point(class_scope:naothmessages.TeamCommMessage)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 playernumber_;
  ::google::protobuf::int32 teamnumber_;
  bool wasstriker_;
  bool ispenalized_;
  double timesinceballwasseen_;
  ::naothmessages::DoubleVector2* ballposition_;
  ::naothmessages::Pose2D* positiononfield_;
  ::naothmessages::PlayerModel* opponent_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static TeamCommMessage* default_instance_;
};
// -------------------------------------------------------------------

class StopwatchItem : public ::google::protobuf::Message {
 public:
  StopwatchItem();
  virtual ~StopwatchItem();
  
  StopwatchItem(const StopwatchItem& from);
  
  inline StopwatchItem& operator=(const StopwatchItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StopwatchItem& default_instance();
  
  void Swap(StopwatchItem* other);
  
  // implements Message ----------------------------------------------
  
  StopwatchItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopwatchItem& from);
  void MergeFrom(const StopwatchItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // required int32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::int32 time() const;
  inline void set_time(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.StopwatchItem)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 time_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static StopwatchItem* default_instance_;
};
// -------------------------------------------------------------------

class Stopwatches : public ::google::protobuf::Message {
 public:
  Stopwatches();
  virtual ~Stopwatches();
  
  Stopwatches(const Stopwatches& from);
  
  inline Stopwatches& operator=(const Stopwatches& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stopwatches& default_instance();
  
  void Swap(Stopwatches* other);
  
  // implements Message ----------------------------------------------
  
  Stopwatches* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stopwatches& from);
  void MergeFrom(const Stopwatches& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.StopwatchItem stopwatches = 1;
  inline int stopwatches_size() const;
  inline void clear_stopwatches();
  static const int kStopwatchesFieldNumber = 1;
  inline const ::naothmessages::StopwatchItem& stopwatches(int index) const;
  inline ::naothmessages::StopwatchItem* mutable_stopwatches(int index);
  inline ::naothmessages::StopwatchItem* add_stopwatches();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::StopwatchItem >&
      stopwatches() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::StopwatchItem >*
      mutable_stopwatches();
  
  // @@protoc_insertion_point(class_scope:naothmessages.Stopwatches)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::StopwatchItem > stopwatches_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Stopwatches* default_instance_;
};
// -------------------------------------------------------------------

class PlotItem : public ::google::protobuf::Message {
 public:
  PlotItem();
  virtual ~PlotItem();
  
  PlotItem(const PlotItem& from);
  
  inline PlotItem& operator=(const PlotItem& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PlotItem& default_instance();
  
  void Swap(PlotItem* other);
  
  // implements Message ----------------------------------------------
  
  PlotItem* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlotItem& from);
  void MergeFrom(const PlotItem& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef PlotItem_PlotType PlotType;
  static const PlotType Default = PlotItem_PlotType_Default;
  static const PlotType Plot2D = PlotItem_PlotType_Plot2D;
  static const PlotType Origin2D = PlotItem_PlotType_Origin2D;
  static inline bool PlotType_IsValid(int value) {
    return PlotItem_PlotType_IsValid(value);
  }
  static const PlotType PlotType_MIN =
    PlotItem_PlotType_PlotType_MIN;
  static const PlotType PlotType_MAX =
    PlotItem_PlotType_PlotType_MAX;
  static const int PlotType_ARRAYSIZE =
    PlotItem_PlotType_PlotType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PlotType_descriptor() {
    return PlotItem_PlotType_descriptor();
  }
  static inline const ::std::string& PlotType_Name(PlotType value) {
    return PlotItem_PlotType_Name(value);
  }
  static inline bool PlotType_Parse(const ::std::string& name,
      PlotType* value) {
    return PlotItem_PlotType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.PlotItem.PlotType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::naothmessages::PlotItem_PlotType type() const;
  inline void set_type(::naothmessages::PlotItem_PlotType value);
  
  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional double value = 3;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 3;
  inline double value() const;
  inline void set_value(double value);
  
  // optional double x = 4;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 4;
  inline double x() const;
  inline void set_x(double value);
  
  // optional double y = 5;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 5;
  inline double y() const;
  inline void set_y(double value);
  
  // optional double rotation = 6;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 6;
  inline double rotation() const;
  inline void set_rotation(double value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.PlotItem)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  double value_;
  double x_;
  double y_;
  double rotation_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static PlotItem* default_instance_;
};
// -------------------------------------------------------------------

class Plots : public ::google::protobuf::Message {
 public:
  Plots();
  virtual ~Plots();
  
  Plots(const Plots& from);
  
  inline Plots& operator=(const Plots& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Plots& default_instance();
  
  void Swap(Plots* other);
  
  // implements Message ----------------------------------------------
  
  Plots* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Plots& from);
  void MergeFrom(const Plots& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.PlotItem plots = 1;
  inline int plots_size() const;
  inline void clear_plots();
  static const int kPlotsFieldNumber = 1;
  inline const ::naothmessages::PlotItem& plots(int index) const;
  inline ::naothmessages::PlotItem* mutable_plots(int index);
  inline ::naothmessages::PlotItem* add_plots();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotItem >&
      plots() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotItem >*
      mutable_plots();
  
  // @@protoc_insertion_point(class_scope:naothmessages.Plots)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotItem > plots_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Plots* default_instance_;
};
// -------------------------------------------------------------------

class XABSLParameter : public ::google::protobuf::Message {
 public:
  XABSLParameter();
  virtual ~XABSLParameter();
  
  XABSLParameter(const XABSLParameter& from);
  
  inline XABSLParameter& operator=(const XABSLParameter& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLParameter& default_instance();
  
  void Swap(XABSLParameter* other);
  
  // implements Message ----------------------------------------------
  
  XABSLParameter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLParameter& from);
  void MergeFrom(const XABSLParameter& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef XABSLParameter_ParamType ParamType;
  static const ParamType Decimal = XABSLParameter_ParamType_Decimal;
  static const ParamType Boolean = XABSLParameter_ParamType_Boolean;
  static const ParamType Enum = XABSLParameter_ParamType_Enum;
  static const ParamType Unknown = XABSLParameter_ParamType_Unknown;
  static inline bool ParamType_IsValid(int value) {
    return XABSLParameter_ParamType_IsValid(value);
  }
  static const ParamType ParamType_MIN =
    XABSLParameter_ParamType_ParamType_MIN;
  static const ParamType ParamType_MAX =
    XABSLParameter_ParamType_ParamType_MAX;
  static const int ParamType_ARRAYSIZE =
    XABSLParameter_ParamType_ParamType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ParamType_descriptor() {
    return XABSLParameter_ParamType_descriptor();
  }
  static inline const ::std::string& ParamType_Name(ParamType value) {
    return XABSLParameter_ParamType_Name(value);
  }
  static inline bool ParamType_Parse(const ::std::string& name,
      ParamType* value) {
    return XABSLParameter_ParamType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional string name = 1 [default = "unknown"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional .naothmessages.XABSLParameter.ParamType type = 2 [default = Unknown];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::naothmessages::XABSLParameter_ParamType type() const;
  inline void set_type(::naothmessages::XABSLParameter_ParamType value);
  
  // optional double decimalValue = 3;
  inline bool has_decimalvalue() const;
  inline void clear_decimalvalue();
  static const int kDecimalValueFieldNumber = 3;
  inline double decimalvalue() const;
  inline void set_decimalvalue(double value);
  
  // optional bool boolValue = 4;
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 4;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);
  
  // optional string enumValue = 5;
  inline bool has_enumvalue() const;
  inline void clear_enumvalue();
  static const int kEnumValueFieldNumber = 5;
  inline const ::std::string& enumvalue() const;
  inline void set_enumvalue(const ::std::string& value);
  inline void set_enumvalue(const char* value);
  inline void set_enumvalue(const char* value, size_t size);
  inline ::std::string* mutable_enumvalue();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLParameter)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  int type_;
  double decimalvalue_;
  bool boolvalue_;
  ::std::string* enumvalue_;
  static const ::std::string _default_enumvalue_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static XABSLParameter* default_instance_;
};
// -------------------------------------------------------------------

class XABSLAction : public ::google::protobuf::Message {
 public:
  XABSLAction();
  virtual ~XABSLAction();
  
  XABSLAction(const XABSLAction& from);
  
  inline XABSLAction& operator=(const XABSLAction& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XABSLAction& default_instance();
  
  void Swap(XABSLAction* other);
  
  // implements Message ----------------------------------------------
  
  XABSLAction* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XABSLAction& from);
  void MergeFrom(const XABSLAction& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef XABSLAction_ActionType ActionType;
  static const ActionType Option = XABSLAction_ActionType_Option;
  static const ActionType BasicBehavior = XABSLAction_ActionType_BasicBehavior;
  static const ActionType DecimalOutputSymbol = XABSLAction_ActionType_DecimalOutputSymbol;
  static const ActionType BooleanOutputSymbol = XABSLAction_ActionType_BooleanOutputSymbol;
  static const ActionType EnumOutputSymbol = XABSLAction_ActionType_EnumOutputSymbol;
  static const ActionType Unknown = XABSLAction_ActionType_Unknown;
  static inline bool ActionType_IsValid(int value) {
    return XABSLAction_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    XABSLAction_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    XABSLAction_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    XABSLAction_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return XABSLAction_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return XABSLAction_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return XABSLAction_ActionType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .naothmessages.XABSLAction.ActionType type = 1 [default = Unknown];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::naothmessages::XABSLAction_ActionType type() const;
  inline void set_type(::naothmessages::XABSLAction_ActionType value);
  
  // optional string name = 2 [default = "unknown"];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // optional int64 timeOfExecution = 3 [default = 0];
  inline bool has_timeofexecution() const;
  inline void clear_timeofexecution();
  static const int kTimeOfExecutionFieldNumber = 3;
  inline ::google::protobuf::int64 timeofexecution() const;
  inline void set_timeofexecution(::google::protobuf::int64 value);
  
  // optional string activeState = 4;
  inline bool has_activestate() const;
  inline void clear_activestate();
  static const int kActiveStateFieldNumber = 4;
  inline const ::std::string& activestate() const;
  inline void set_activestate(const ::std::string& value);
  inline void set_activestate(const char* value);
  inline void set_activestate(const char* value, size_t size);
  inline ::std::string* mutable_activestate();
  
  // optional int64 stateTime = 5;
  inline bool has_statetime() const;
  inline void clear_statetime();
  static const int kStateTimeFieldNumber = 5;
  inline ::google::protobuf::int64 statetime() const;
  inline void set_statetime(::google::protobuf::int64 value);
  
  // repeated .naothmessages.XABSLParameter parameters = 6;
  inline int parameters_size() const;
  inline void clear_parameters();
  static const int kParametersFieldNumber = 6;
  inline const ::naothmessages::XABSLParameter& parameters(int index) const;
  inline ::naothmessages::XABSLParameter* mutable_parameters(int index);
  inline ::naothmessages::XABSLParameter* add_parameters();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
      parameters() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
      mutable_parameters();
  
  // repeated .naothmessages.XABSLAction activeSubActions = 7;
  inline int activesubactions_size() const;
  inline void clear_activesubactions();
  static const int kActiveSubActionsFieldNumber = 7;
  inline const ::naothmessages::XABSLAction& activesubactions(int index) const;
  inline ::naothmessages::XABSLAction* mutable_activesubactions(int index);
  inline ::naothmessages::XABSLAction* add_activesubactions();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >&
      activesubactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >*
      mutable_activesubactions();
  
  // optional double decimalValue = 8;
  inline bool has_decimalvalue() const;
  inline void clear_decimalvalue();
  static const int kDecimalValueFieldNumber = 8;
  inline double decimalvalue() const;
  inline void set_decimalvalue(double value);
  
  // optional bool boolValue = 9;
  inline bool has_boolvalue() const;
  inline void clear_boolvalue();
  static const int kBoolValueFieldNumber = 9;
  inline bool boolvalue() const;
  inline void set_boolvalue(bool value);
  
  // optional string enumValue = 10;
  inline bool has_enumvalue() const;
  inline void clear_enumvalue();
  static const int kEnumValueFieldNumber = 10;
  inline const ::std::string& enumvalue() const;
  inline void set_enumvalue(const ::std::string& value);
  inline void set_enumvalue(const char* value);
  inline void set_enumvalue(const char* value, size_t size);
  inline ::std::string* mutable_enumvalue();
  
  // @@protoc_insertion_point(class_scope:naothmessages.XABSLAction)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int64 timeofexecution_;
  ::std::string* activestate_;
  static const ::std::string _default_activestate_;
  ::google::protobuf::int64 statetime_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter > parameters_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction > activesubactions_;
  double decimalvalue_;
  bool boolvalue_;
  ::std::string* enumvalue_;
  static const ::std::string _default_enumvalue_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static XABSLAction* default_instance_;
};
// -------------------------------------------------------------------

class BehaviorStatus : public ::google::protobuf::Message {
 public:
  BehaviorStatus();
  virtual ~BehaviorStatus();
  
  BehaviorStatus(const BehaviorStatus& from);
  
  inline BehaviorStatus& operator=(const BehaviorStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BehaviorStatus& default_instance();
  
  void Swap(BehaviorStatus* other);
  
  // implements Message ----------------------------------------------
  
  BehaviorStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BehaviorStatus& from);
  void MergeFrom(const BehaviorStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string agent = 1;
  inline bool has_agent() const;
  inline void clear_agent();
  static const int kAgentFieldNumber = 1;
  inline const ::std::string& agent() const;
  inline void set_agent(const ::std::string& value);
  inline void set_agent(const char* value);
  inline void set_agent(const char* value, size_t size);
  inline ::std::string* mutable_agent();
  
  // repeated .naothmessages.XABSLAction activeRootActions = 2;
  inline int activerootactions_size() const;
  inline void clear_activerootactions();
  static const int kActiveRootActionsFieldNumber = 2;
  inline const ::naothmessages::XABSLAction& activerootactions(int index) const;
  inline ::naothmessages::XABSLAction* mutable_activerootactions(int index);
  inline ::naothmessages::XABSLAction* add_activerootactions();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >&
      activerootactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >*
      mutable_activerootactions();
  
  // repeated .naothmessages.XABSLParameter inputSymbols = 3;
  inline int inputsymbols_size() const;
  inline void clear_inputsymbols();
  static const int kInputSymbolsFieldNumber = 3;
  inline const ::naothmessages::XABSLParameter& inputsymbols(int index) const;
  inline ::naothmessages::XABSLParameter* mutable_inputsymbols(int index);
  inline ::naothmessages::XABSLParameter* add_inputsymbols();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
      inputsymbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
      mutable_inputsymbols();
  
  // repeated .naothmessages.XABSLParameter outputSymbols = 4;
  inline int outputsymbols_size() const;
  inline void clear_outputsymbols();
  static const int kOutputSymbolsFieldNumber = 4;
  inline const ::naothmessages::XABSLParameter& outputsymbols(int index) const;
  inline ::naothmessages::XABSLParameter* mutable_outputsymbols(int index);
  inline ::naothmessages::XABSLParameter* add_outputsymbols();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
      outputsymbols() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
      mutable_outputsymbols();
  
  // optional uint32 frameNumber = 5;
  inline bool has_framenumber() const;
  inline void clear_framenumber();
  static const int kFrameNumberFieldNumber = 5;
  inline ::google::protobuf::uint32 framenumber() const;
  inline void set_framenumber(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.BehaviorStatus)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* agent_;
  static const ::std::string _default_agent_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction > activerootactions_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter > inputsymbols_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter > outputsymbols_;
  ::google::protobuf::uint32 framenumber_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static BehaviorStatus* default_instance_;
};
// -------------------------------------------------------------------

class Module : public ::google::protobuf::Message {
 public:
  Module();
  virtual ~Module();
  
  Module(const Module& from);
  
  inline Module& operator=(const Module& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Module& default_instance();
  
  void Swap(Module* other);
  
  // implements Message ----------------------------------------------
  
  Module* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Module& from);
  void MergeFrom(const Module& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // repeated string usedRepresentations = 2;
  inline int usedrepresentations_size() const;
  inline void clear_usedrepresentations();
  static const int kUsedRepresentationsFieldNumber = 2;
  inline const ::std::string& usedrepresentations(int index) const;
  inline ::std::string* mutable_usedrepresentations(int index);
  inline void set_usedrepresentations(int index, const ::std::string& value);
  inline void set_usedrepresentations(int index, const char* value);
  inline void set_usedrepresentations(int index, const char* value, size_t size);
  inline ::std::string* add_usedrepresentations();
  inline void add_usedrepresentations(const ::std::string& value);
  inline void add_usedrepresentations(const char* value);
  inline void add_usedrepresentations(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& usedrepresentations() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_usedrepresentations();
  
  // repeated string providedRepresentations = 3;
  inline int providedrepresentations_size() const;
  inline void clear_providedrepresentations();
  static const int kProvidedRepresentationsFieldNumber = 3;
  inline const ::std::string& providedrepresentations(int index) const;
  inline ::std::string* mutable_providedrepresentations(int index);
  inline void set_providedrepresentations(int index, const ::std::string& value);
  inline void set_providedrepresentations(int index, const char* value);
  inline void set_providedrepresentations(int index, const char* value, size_t size);
  inline ::std::string* add_providedrepresentations();
  inline void add_providedrepresentations(const ::std::string& value);
  inline void add_providedrepresentations(const char* value);
  inline void add_providedrepresentations(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& providedrepresentations() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_providedrepresentations();
  
  // optional bool active = 4 [default = false];
  inline bool has_active() const;
  inline void clear_active();
  static const int kActiveFieldNumber = 4;
  inline bool active() const;
  inline void set_active(bool value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.Module)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::RepeatedPtrField< ::std::string> usedrepresentations_;
  ::google::protobuf::RepeatedPtrField< ::std::string> providedrepresentations_;
  bool active_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static Module* default_instance_;
};
// -------------------------------------------------------------------

class ModuleList : public ::google::protobuf::Message {
 public:
  ModuleList();
  virtual ~ModuleList();
  
  ModuleList(const ModuleList& from);
  
  inline ModuleList& operator=(const ModuleList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ModuleList& default_instance();
  
  void Swap(ModuleList* other);
  
  // implements Message ----------------------------------------------
  
  ModuleList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ModuleList& from);
  void MergeFrom(const ModuleList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.Module modules = 1;
  inline int modules_size() const;
  inline void clear_modules();
  static const int kModulesFieldNumber = 1;
  inline const ::naothmessages::Module& modules(int index) const;
  inline ::naothmessages::Module* mutable_modules(int index);
  inline ::naothmessages::Module* add_modules();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Module >&
      modules() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Module >*
      mutable_modules();
  
  // @@protoc_insertion_point(class_scope:naothmessages.ModuleList)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::Module > modules_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static ModuleList* default_instance_;
};
// -------------------------------------------------------------------

class FeatureKeyPoint : public ::google::protobuf::Message {
 public:
  FeatureKeyPoint();
  virtual ~FeatureKeyPoint();
  
  FeatureKeyPoint(const FeatureKeyPoint& from);
  
  inline FeatureKeyPoint& operator=(const FeatureKeyPoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureKeyPoint& default_instance();
  
  void Swap(FeatureKeyPoint* other);
  
  // implements Message ----------------------------------------------
  
  FeatureKeyPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureKeyPoint& from);
  void MergeFrom(const FeatureKeyPoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.FloatVector2 pt = 1;
  inline bool has_pt() const;
  inline void clear_pt();
  static const int kPtFieldNumber = 1;
  inline const ::naothmessages::FloatVector2& pt() const;
  inline ::naothmessages::FloatVector2* mutable_pt();
  
  // required float size = 2;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 2;
  inline float size() const;
  inline void set_size(float value);
  
  // required float angle = 3;
  inline bool has_angle() const;
  inline void clear_angle();
  static const int kAngleFieldNumber = 3;
  inline float angle() const;
  inline void set_angle(float value);
  
  // required float response = 4;
  inline bool has_response() const;
  inline void clear_response();
  static const int kResponseFieldNumber = 4;
  inline float response() const;
  inline void set_response(float value);
  
  // required int32 octave = 5;
  inline bool has_octave() const;
  inline void clear_octave();
  static const int kOctaveFieldNumber = 5;
  inline ::google::protobuf::int32 octave() const;
  inline void set_octave(::google::protobuf::int32 value);
  
  // required int32 class_id = 6;
  inline bool has_class_id() const;
  inline void clear_class_id();
  static const int kClassIdFieldNumber = 6;
  inline ::google::protobuf::int32 class_id() const;
  inline void set_class_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.FeatureKeyPoint)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::naothmessages::FloatVector2* pt_;
  float size_;
  float angle_;
  float response_;
  ::google::protobuf::int32 octave_;
  ::google::protobuf::int32 class_id_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FeatureKeyPoint* default_instance_;
};
// -------------------------------------------------------------------

class FeatureDetectionResult : public ::google::protobuf::Message {
 public:
  FeatureDetectionResult();
  virtual ~FeatureDetectionResult();
  
  FeatureDetectionResult(const FeatureDetectionResult& from);
  
  inline FeatureDetectionResult& operator=(const FeatureDetectionResult& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureDetectionResult& default_instance();
  
  void Swap(FeatureDetectionResult* other);
  
  // implements Message ----------------------------------------------
  
  FeatureDetectionResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureDetectionResult& from);
  void MergeFrom(const FeatureDetectionResult& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes grayScaleImage = 1;
  inline bool has_grayscaleimage() const;
  inline void clear_grayscaleimage();
  static const int kGrayScaleImageFieldNumber = 1;
  inline const ::std::string& grayscaleimage() const;
  inline void set_grayscaleimage(const ::std::string& value);
  inline void set_grayscaleimage(const char* value);
  inline void set_grayscaleimage(const void* value, size_t size);
  inline ::std::string* mutable_grayscaleimage();
  
  // repeated .naothmessages.FeatureKeyPoint keyPoints = 2;
  inline int keypoints_size() const;
  inline void clear_keypoints();
  static const int kKeyPointsFieldNumber = 2;
  inline const ::naothmessages::FeatureKeyPoint& keypoints(int index) const;
  inline ::naothmessages::FeatureKeyPoint* mutable_keypoints(int index);
  inline ::naothmessages::FeatureKeyPoint* add_keypoints();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureKeyPoint >&
      keypoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureKeyPoint >*
      mutable_keypoints();
  
  // repeated .naothmessages.SingleDescriptor descriptors = 3;
  inline int descriptors_size() const;
  inline void clear_descriptors();
  static const int kDescriptorsFieldNumber = 3;
  inline const ::naothmessages::SingleDescriptor& descriptors(int index) const;
  inline ::naothmessages::SingleDescriptor* mutable_descriptors(int index);
  inline ::naothmessages::SingleDescriptor* add_descriptors();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >&
      descriptors() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >*
      mutable_descriptors();
  
  // repeated string namesForKeyPoints = 4;
  inline int namesforkeypoints_size() const;
  inline void clear_namesforkeypoints();
  static const int kNamesForKeyPointsFieldNumber = 4;
  inline const ::std::string& namesforkeypoints(int index) const;
  inline ::std::string* mutable_namesforkeypoints(int index);
  inline void set_namesforkeypoints(int index, const ::std::string& value);
  inline void set_namesforkeypoints(int index, const char* value);
  inline void set_namesforkeypoints(int index, const char* value, size_t size);
  inline ::std::string* add_namesforkeypoints();
  inline void add_namesforkeypoints(const ::std::string& value);
  inline void add_namesforkeypoints(const char* value);
  inline void add_namesforkeypoints(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& namesforkeypoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_namesforkeypoints();
  
  // optional int32 numberOfFeatureElements = 5 [default = 64];
  inline bool has_numberoffeatureelements() const;
  inline void clear_numberoffeatureelements();
  static const int kNumberOfFeatureElementsFieldNumber = 5;
  inline ::google::protobuf::int32 numberoffeatureelements() const;
  inline void set_numberoffeatureelements(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.FeatureDetectionResult)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* grayscaleimage_;
  static const ::std::string _default_grayscaleimage_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureKeyPoint > keypoints_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor > descriptors_;
  ::google::protobuf::RepeatedPtrField< ::std::string> namesforkeypoints_;
  ::google::protobuf::int32 numberoffeatureelements_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FeatureDetectionResult* default_instance_;
};
// -------------------------------------------------------------------

class SingleDescriptor : public ::google::protobuf::Message {
 public:
  SingleDescriptor();
  virtual ~SingleDescriptor();
  
  SingleDescriptor(const SingleDescriptor& from);
  
  inline SingleDescriptor& operator=(const SingleDescriptor& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleDescriptor& default_instance();
  
  void Swap(SingleDescriptor* other);
  
  // implements Message ----------------------------------------------
  
  SingleDescriptor* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SingleDescriptor& from);
  void MergeFrom(const SingleDescriptor& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated float d = 1;
  inline int d_size() const;
  inline void clear_d();
  static const int kDFieldNumber = 1;
  inline float d(int index) const;
  inline void set_d(int index, float value);
  inline void add_d(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      d() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_d();
  
  // @@protoc_insertion_point(class_scope:naothmessages.SingleDescriptor)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedField< float > d_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static SingleDescriptor* default_instance_;
};
// -------------------------------------------------------------------

class FeatureClass : public ::google::protobuf::Message {
 public:
  FeatureClass();
  virtual ~FeatureClass();
  
  FeatureClass(const FeatureClass& from);
  
  inline FeatureClass& operator=(const FeatureClass& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureClass& default_instance();
  
  void Swap(FeatureClass* other);
  
  // implements Message ----------------------------------------------
  
  FeatureClass* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureClass& from);
  void MergeFrom(const FeatureClass& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  
  // repeated .naothmessages.SingleDescriptor samples = 2;
  inline int samples_size() const;
  inline void clear_samples();
  static const int kSamplesFieldNumber = 2;
  inline const ::naothmessages::SingleDescriptor& samples(int index) const;
  inline ::naothmessages::SingleDescriptor* mutable_samples(int index);
  inline ::naothmessages::SingleDescriptor* add_samples();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >&
      samples() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >*
      mutable_samples();
  
  // optional double objectHeight = 3;
  inline bool has_objectheight() const;
  inline void clear_objectheight();
  static const int kObjectHeightFieldNumber = 3;
  inline double objectheight() const;
  inline void set_objectheight(double value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.FeatureClass)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor > samples_;
  double objectheight_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FeatureClass* default_instance_;
};
// -------------------------------------------------------------------

class FeatureTable : public ::google::protobuf::Message {
 public:
  FeatureTable();
  virtual ~FeatureTable();
  
  FeatureTable(const FeatureTable& from);
  
  inline FeatureTable& operator=(const FeatureTable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FeatureTable& default_instance();
  
  void Swap(FeatureTable* other);
  
  // implements Message ----------------------------------------------
  
  FeatureTable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FeatureTable& from);
  void MergeFrom(const FeatureTable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.FeatureClass classes = 1;
  inline int classes_size() const;
  inline void clear_classes();
  static const int kClassesFieldNumber = 1;
  inline const ::naothmessages::FeatureClass& classes(int index) const;
  inline ::naothmessages::FeatureClass* mutable_classes(int index);
  inline ::naothmessages::FeatureClass* add_classes();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureClass >&
      classes() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureClass >*
      mutable_classes();
  
  // optional int32 numberOfFeatureElements = 2 [default = 64];
  inline bool has_numberoffeatureelements() const;
  inline void clear_numberoffeatureelements();
  static const int kNumberOfFeatureElementsFieldNumber = 2;
  inline ::google::protobuf::int32 numberoffeatureelements() const;
  inline void set_numberoffeatureelements(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.FeatureTable)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureClass > classes_;
  ::google::protobuf::int32 numberoffeatureelements_;
  friend void  protobuf_AddDesc_Messages_2eproto();
  friend void protobuf_AssignDesc_Messages_2eproto();
  friend void protobuf_ShutdownFile_Messages_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static FeatureTable* default_instance_;
};
// ===================================================================


// ===================================================================

// CMDArg

// required string name = 1;
inline bool CMDArg::has_name() const {
  return _has_bit(0);
}
inline void CMDArg::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& CMDArg::name() const {
  return *name_;
}
inline void CMDArg::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMDArg::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CMDArg::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMDArg::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional string value = 2;
inline bool CMDArg::has_value() const {
  return _has_bit(1);
}
inline void CMDArg::clear_value() {
  if (value_ != &_default_value_) {
    value_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& CMDArg::value() const {
  return *value_;
}
inline void CMDArg::set_value(const ::std::string& value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CMDArg::set_value(const char* value) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void CMDArg::set_value(const char* value, size_t size) {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMDArg::mutable_value() {
  _set_bit(1);
  if (value_ == &_default_value_) {
    value_ = new ::std::string;
  }
  return value_;
}

// optional bytes value_bytes = 3;
inline bool CMDArg::has_value_bytes() const {
  return _has_bit(2);
}
inline void CMDArg::clear_value_bytes() {
  if (value_bytes_ != &_default_value_bytes_) {
    value_bytes_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& CMDArg::value_bytes() const {
  return *value_bytes_;
}
inline void CMDArg::set_value_bytes(const ::std::string& value) {
  _set_bit(2);
  if (value_bytes_ == &_default_value_bytes_) {
    value_bytes_ = new ::std::string;
  }
  value_bytes_->assign(value);
}
inline void CMDArg::set_value_bytes(const char* value) {
  _set_bit(2);
  if (value_bytes_ == &_default_value_bytes_) {
    value_bytes_ = new ::std::string;
  }
  value_bytes_->assign(value);
}
inline void CMDArg::set_value_bytes(const void* value, size_t size) {
  _set_bit(2);
  if (value_bytes_ == &_default_value_bytes_) {
    value_bytes_ = new ::std::string;
  }
  value_bytes_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CMDArg::mutable_value_bytes() {
  _set_bit(2);
  if (value_bytes_ == &_default_value_bytes_) {
    value_bytes_ = new ::std::string;
  }
  return value_bytes_;
}

// -------------------------------------------------------------------

// Command

// required string name = 1;
inline bool Command::has_name() const {
  return _has_bit(0);
}
inline void Command::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Command::name() const {
  return *name_;
}
inline void Command::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Command::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Command::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Command::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// repeated .naothmessages.CMDArg args = 2;
inline int Command::args_size() const {
  return args_.size();
}
inline void Command::clear_args() {
  args_.Clear();
}
inline const ::naothmessages::CMDArg& Command::args(int index) const {
  return args_.Get(index);
}
inline ::naothmessages::CMDArg* Command::mutable_args(int index) {
  return args_.Mutable(index);
}
inline ::naothmessages::CMDArg* Command::add_args() {
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::CMDArg >&
Command::args() const {
  return args_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::CMDArg >*
Command::mutable_args() {
  return &args_;
}

// -------------------------------------------------------------------

// CommandList

// repeated .naothmessages.Command cmd = 1;
inline int CommandList::cmd_size() const {
  return cmd_.size();
}
inline void CommandList::clear_cmd() {
  cmd_.Clear();
}
inline const ::naothmessages::Command& CommandList::cmd(int index) const {
  return cmd_.Get(index);
}
inline ::naothmessages::Command* CommandList::mutable_cmd(int index) {
  return cmd_.Mutable(index);
}
inline ::naothmessages::Command* CommandList::add_cmd() {
  return cmd_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Command >&
CommandList::cmd() const {
  return cmd_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Command >*
CommandList::mutable_cmd() {
  return &cmd_;
}

// -------------------------------------------------------------------

// PlayerModel

// required int32 number = 1;
inline bool PlayerModel::has_number() const {
  return _has_bit(0);
}
inline void PlayerModel::clear_number() {
  number_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 PlayerModel::number() const {
  return number_;
}
inline void PlayerModel::set_number(::google::protobuf::int32 value) {
  _set_bit(0);
  number_ = value;
}

// optional .naothmessages.Pose2D poseOnField = 2;
inline bool PlayerModel::has_poseonfield() const {
  return _has_bit(1);
}
inline void PlayerModel::clear_poseonfield() {
  if (poseonfield_ != NULL) poseonfield_->::naothmessages::Pose2D::Clear();
  _clear_bit(1);
}
inline const ::naothmessages::Pose2D& PlayerModel::poseonfield() const {
  return poseonfield_ != NULL ? *poseonfield_ : *default_instance_->poseonfield_;
}
inline ::naothmessages::Pose2D* PlayerModel::mutable_poseonfield() {
  _set_bit(1);
  if (poseonfield_ == NULL) poseonfield_ = new ::naothmessages::Pose2D;
  return poseonfield_;
}

// -------------------------------------------------------------------

// TeamCommMessage

// required int32 playerNumber = 1;
inline bool TeamCommMessage::has_playernumber() const {
  return _has_bit(0);
}
inline void TeamCommMessage::clear_playernumber() {
  playernumber_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 TeamCommMessage::playernumber() const {
  return playernumber_;
}
inline void TeamCommMessage::set_playernumber(::google::protobuf::int32 value) {
  _set_bit(0);
  playernumber_ = value;
}

// required int32 teamNumber = 2;
inline bool TeamCommMessage::has_teamnumber() const {
  return _has_bit(1);
}
inline void TeamCommMessage::clear_teamnumber() {
  teamnumber_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 TeamCommMessage::teamnumber() const {
  return teamnumber_;
}
inline void TeamCommMessage::set_teamnumber(::google::protobuf::int32 value) {
  _set_bit(1);
  teamnumber_ = value;
}

// optional bool wasStriker = 3 [default = false];
inline bool TeamCommMessage::has_wasstriker() const {
  return _has_bit(2);
}
inline void TeamCommMessage::clear_wasstriker() {
  wasstriker_ = false;
  _clear_bit(2);
}
inline bool TeamCommMessage::wasstriker() const {
  return wasstriker_;
}
inline void TeamCommMessage::set_wasstriker(bool value) {
  _set_bit(2);
  wasstriker_ = value;
}

// optional bool isPenalized = 4 [default = false];
inline bool TeamCommMessage::has_ispenalized() const {
  return _has_bit(3);
}
inline void TeamCommMessage::clear_ispenalized() {
  ispenalized_ = false;
  _clear_bit(3);
}
inline bool TeamCommMessage::ispenalized() const {
  return ispenalized_;
}
inline void TeamCommMessage::set_ispenalized(bool value) {
  _set_bit(3);
  ispenalized_ = value;
}

// optional double timeSinceBallWasSeen = 5;
inline bool TeamCommMessage::has_timesinceballwasseen() const {
  return _has_bit(4);
}
inline void TeamCommMessage::clear_timesinceballwasseen() {
  timesinceballwasseen_ = 0;
  _clear_bit(4);
}
inline double TeamCommMessage::timesinceballwasseen() const {
  return timesinceballwasseen_;
}
inline void TeamCommMessage::set_timesinceballwasseen(double value) {
  _set_bit(4);
  timesinceballwasseen_ = value;
}

// optional .naothmessages.DoubleVector2 ballPosition = 6;
inline bool TeamCommMessage::has_ballposition() const {
  return _has_bit(5);
}
inline void TeamCommMessage::clear_ballposition() {
  if (ballposition_ != NULL) ballposition_->::naothmessages::DoubleVector2::Clear();
  _clear_bit(5);
}
inline const ::naothmessages::DoubleVector2& TeamCommMessage::ballposition() const {
  return ballposition_ != NULL ? *ballposition_ : *default_instance_->ballposition_;
}
inline ::naothmessages::DoubleVector2* TeamCommMessage::mutable_ballposition() {
  _set_bit(5);
  if (ballposition_ == NULL) ballposition_ = new ::naothmessages::DoubleVector2;
  return ballposition_;
}

// optional .naothmessages.Pose2D positionOnField = 7;
inline bool TeamCommMessage::has_positiononfield() const {
  return _has_bit(6);
}
inline void TeamCommMessage::clear_positiononfield() {
  if (positiononfield_ != NULL) positiononfield_->::naothmessages::Pose2D::Clear();
  _clear_bit(6);
}
inline const ::naothmessages::Pose2D& TeamCommMessage::positiononfield() const {
  return positiononfield_ != NULL ? *positiononfield_ : *default_instance_->positiononfield_;
}
inline ::naothmessages::Pose2D* TeamCommMessage::mutable_positiononfield() {
  _set_bit(6);
  if (positiononfield_ == NULL) positiononfield_ = new ::naothmessages::Pose2D;
  return positiononfield_;
}

// optional .naothmessages.PlayerModel opponent = 8;
inline bool TeamCommMessage::has_opponent() const {
  return _has_bit(7);
}
inline void TeamCommMessage::clear_opponent() {
  if (opponent_ != NULL) opponent_->::naothmessages::PlayerModel::Clear();
  _clear_bit(7);
}
inline const ::naothmessages::PlayerModel& TeamCommMessage::opponent() const {
  return opponent_ != NULL ? *opponent_ : *default_instance_->opponent_;
}
inline ::naothmessages::PlayerModel* TeamCommMessage::mutable_opponent() {
  _set_bit(7);
  if (opponent_ == NULL) opponent_ = new ::naothmessages::PlayerModel;
  return opponent_;
}

// -------------------------------------------------------------------

// StopwatchItem

// required string name = 1;
inline bool StopwatchItem::has_name() const {
  return _has_bit(0);
}
inline void StopwatchItem::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& StopwatchItem::name() const {
  return *name_;
}
inline void StopwatchItem::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StopwatchItem::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StopwatchItem::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StopwatchItem::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// required int32 time = 2;
inline bool StopwatchItem::has_time() const {
  return _has_bit(1);
}
inline void StopwatchItem::clear_time() {
  time_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 StopwatchItem::time() const {
  return time_;
}
inline void StopwatchItem::set_time(::google::protobuf::int32 value) {
  _set_bit(1);
  time_ = value;
}

// -------------------------------------------------------------------

// Stopwatches

// repeated .naothmessages.StopwatchItem stopwatches = 1;
inline int Stopwatches::stopwatches_size() const {
  return stopwatches_.size();
}
inline void Stopwatches::clear_stopwatches() {
  stopwatches_.Clear();
}
inline const ::naothmessages::StopwatchItem& Stopwatches::stopwatches(int index) const {
  return stopwatches_.Get(index);
}
inline ::naothmessages::StopwatchItem* Stopwatches::mutable_stopwatches(int index) {
  return stopwatches_.Mutable(index);
}
inline ::naothmessages::StopwatchItem* Stopwatches::add_stopwatches() {
  return stopwatches_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::StopwatchItem >&
Stopwatches::stopwatches() const {
  return stopwatches_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::StopwatchItem >*
Stopwatches::mutable_stopwatches() {
  return &stopwatches_;
}

// -------------------------------------------------------------------

// PlotItem

// required .naothmessages.PlotItem.PlotType type = 1;
inline bool PlotItem::has_type() const {
  return _has_bit(0);
}
inline void PlotItem::clear_type() {
  type_ = 1;
  _clear_bit(0);
}
inline ::naothmessages::PlotItem_PlotType PlotItem::type() const {
  return static_cast< ::naothmessages::PlotItem_PlotType >(type_);
}
inline void PlotItem::set_type(::naothmessages::PlotItem_PlotType value) {
  GOOGLE_DCHECK(::naothmessages::PlotItem_PlotType_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// required string name = 2;
inline bool PlotItem::has_name() const {
  return _has_bit(1);
}
inline void PlotItem::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& PlotItem::name() const {
  return *name_;
}
inline void PlotItem::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlotItem::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PlotItem::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PlotItem::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional double value = 3;
inline bool PlotItem::has_value() const {
  return _has_bit(2);
}
inline void PlotItem::clear_value() {
  value_ = 0;
  _clear_bit(2);
}
inline double PlotItem::value() const {
  return value_;
}
inline void PlotItem::set_value(double value) {
  _set_bit(2);
  value_ = value;
}

// optional double x = 4;
inline bool PlotItem::has_x() const {
  return _has_bit(3);
}
inline void PlotItem::clear_x() {
  x_ = 0;
  _clear_bit(3);
}
inline double PlotItem::x() const {
  return x_;
}
inline void PlotItem::set_x(double value) {
  _set_bit(3);
  x_ = value;
}

// optional double y = 5;
inline bool PlotItem::has_y() const {
  return _has_bit(4);
}
inline void PlotItem::clear_y() {
  y_ = 0;
  _clear_bit(4);
}
inline double PlotItem::y() const {
  return y_;
}
inline void PlotItem::set_y(double value) {
  _set_bit(4);
  y_ = value;
}

// optional double rotation = 6;
inline bool PlotItem::has_rotation() const {
  return _has_bit(5);
}
inline void PlotItem::clear_rotation() {
  rotation_ = 0;
  _clear_bit(5);
}
inline double PlotItem::rotation() const {
  return rotation_;
}
inline void PlotItem::set_rotation(double value) {
  _set_bit(5);
  rotation_ = value;
}

// -------------------------------------------------------------------

// Plots

// repeated .naothmessages.PlotItem plots = 1;
inline int Plots::plots_size() const {
  return plots_.size();
}
inline void Plots::clear_plots() {
  plots_.Clear();
}
inline const ::naothmessages::PlotItem& Plots::plots(int index) const {
  return plots_.Get(index);
}
inline ::naothmessages::PlotItem* Plots::mutable_plots(int index) {
  return plots_.Mutable(index);
}
inline ::naothmessages::PlotItem* Plots::add_plots() {
  return plots_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotItem >&
Plots::plots() const {
  return plots_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::PlotItem >*
Plots::mutable_plots() {
  return &plots_;
}

// -------------------------------------------------------------------

// XABSLParameter

// optional string name = 1 [default = "unknown"];
inline bool XABSLParameter::has_name() const {
  return _has_bit(0);
}
inline void XABSLParameter::clear_name() {
  if (name_ != &_default_name_) {
    name_->assign(_default_name_);
  }
  _clear_bit(0);
}
inline const ::std::string& XABSLParameter::name() const {
  return *name_;
}
inline void XABSLParameter::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLParameter::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLParameter::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLParameter::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string(_default_name_);
  }
  return name_;
}

// optional .naothmessages.XABSLParameter.ParamType type = 2 [default = Unknown];
inline bool XABSLParameter::has_type() const {
  return _has_bit(1);
}
inline void XABSLParameter::clear_type() {
  type_ = 3;
  _clear_bit(1);
}
inline ::naothmessages::XABSLParameter_ParamType XABSLParameter::type() const {
  return static_cast< ::naothmessages::XABSLParameter_ParamType >(type_);
}
inline void XABSLParameter::set_type(::naothmessages::XABSLParameter_ParamType value) {
  GOOGLE_DCHECK(::naothmessages::XABSLParameter_ParamType_IsValid(value));
  _set_bit(1);
  type_ = value;
}

// optional double decimalValue = 3;
inline bool XABSLParameter::has_decimalvalue() const {
  return _has_bit(2);
}
inline void XABSLParameter::clear_decimalvalue() {
  decimalvalue_ = 0;
  _clear_bit(2);
}
inline double XABSLParameter::decimalvalue() const {
  return decimalvalue_;
}
inline void XABSLParameter::set_decimalvalue(double value) {
  _set_bit(2);
  decimalvalue_ = value;
}

// optional bool boolValue = 4;
inline bool XABSLParameter::has_boolvalue() const {
  return _has_bit(3);
}
inline void XABSLParameter::clear_boolvalue() {
  boolvalue_ = false;
  _clear_bit(3);
}
inline bool XABSLParameter::boolvalue() const {
  return boolvalue_;
}
inline void XABSLParameter::set_boolvalue(bool value) {
  _set_bit(3);
  boolvalue_ = value;
}

// optional string enumValue = 5;
inline bool XABSLParameter::has_enumvalue() const {
  return _has_bit(4);
}
inline void XABSLParameter::clear_enumvalue() {
  if (enumvalue_ != &_default_enumvalue_) {
    enumvalue_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& XABSLParameter::enumvalue() const {
  return *enumvalue_;
}
inline void XABSLParameter::set_enumvalue(const ::std::string& value) {
  _set_bit(4);
  if (enumvalue_ == &_default_enumvalue_) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(value);
}
inline void XABSLParameter::set_enumvalue(const char* value) {
  _set_bit(4);
  if (enumvalue_ == &_default_enumvalue_) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(value);
}
inline void XABSLParameter::set_enumvalue(const char* value, size_t size) {
  _set_bit(4);
  if (enumvalue_ == &_default_enumvalue_) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLParameter::mutable_enumvalue() {
  _set_bit(4);
  if (enumvalue_ == &_default_enumvalue_) {
    enumvalue_ = new ::std::string;
  }
  return enumvalue_;
}

// -------------------------------------------------------------------

// XABSLAction

// optional .naothmessages.XABSLAction.ActionType type = 1 [default = Unknown];
inline bool XABSLAction::has_type() const {
  return _has_bit(0);
}
inline void XABSLAction::clear_type() {
  type_ = 5;
  _clear_bit(0);
}
inline ::naothmessages::XABSLAction_ActionType XABSLAction::type() const {
  return static_cast< ::naothmessages::XABSLAction_ActionType >(type_);
}
inline void XABSLAction::set_type(::naothmessages::XABSLAction_ActionType value) {
  GOOGLE_DCHECK(::naothmessages::XABSLAction_ActionType_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// optional string name = 2 [default = "unknown"];
inline bool XABSLAction::has_name() const {
  return _has_bit(1);
}
inline void XABSLAction::clear_name() {
  if (name_ != &_default_name_) {
    name_->assign(_default_name_);
  }
  _clear_bit(1);
}
inline const ::std::string& XABSLAction::name() const {
  return *name_;
}
inline void XABSLAction::set_name(const ::std::string& value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLAction::set_name(const char* value) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XABSLAction::set_name(const char* value, size_t size) {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLAction::mutable_name() {
  _set_bit(1);
  if (name_ == &_default_name_) {
    name_ = new ::std::string(_default_name_);
  }
  return name_;
}

// optional int64 timeOfExecution = 3 [default = 0];
inline bool XABSLAction::has_timeofexecution() const {
  return _has_bit(2);
}
inline void XABSLAction::clear_timeofexecution() {
  timeofexecution_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 XABSLAction::timeofexecution() const {
  return timeofexecution_;
}
inline void XABSLAction::set_timeofexecution(::google::protobuf::int64 value) {
  _set_bit(2);
  timeofexecution_ = value;
}

// optional string activeState = 4;
inline bool XABSLAction::has_activestate() const {
  return _has_bit(3);
}
inline void XABSLAction::clear_activestate() {
  if (activestate_ != &_default_activestate_) {
    activestate_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& XABSLAction::activestate() const {
  return *activestate_;
}
inline void XABSLAction::set_activestate(const ::std::string& value) {
  _set_bit(3);
  if (activestate_ == &_default_activestate_) {
    activestate_ = new ::std::string;
  }
  activestate_->assign(value);
}
inline void XABSLAction::set_activestate(const char* value) {
  _set_bit(3);
  if (activestate_ == &_default_activestate_) {
    activestate_ = new ::std::string;
  }
  activestate_->assign(value);
}
inline void XABSLAction::set_activestate(const char* value, size_t size) {
  _set_bit(3);
  if (activestate_ == &_default_activestate_) {
    activestate_ = new ::std::string;
  }
  activestate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLAction::mutable_activestate() {
  _set_bit(3);
  if (activestate_ == &_default_activestate_) {
    activestate_ = new ::std::string;
  }
  return activestate_;
}

// optional int64 stateTime = 5;
inline bool XABSLAction::has_statetime() const {
  return _has_bit(4);
}
inline void XABSLAction::clear_statetime() {
  statetime_ = GOOGLE_LONGLONG(0);
  _clear_bit(4);
}
inline ::google::protobuf::int64 XABSLAction::statetime() const {
  return statetime_;
}
inline void XABSLAction::set_statetime(::google::protobuf::int64 value) {
  _set_bit(4);
  statetime_ = value;
}

// repeated .naothmessages.XABSLParameter parameters = 6;
inline int XABSLAction::parameters_size() const {
  return parameters_.size();
}
inline void XABSLAction::clear_parameters() {
  parameters_.Clear();
}
inline const ::naothmessages::XABSLParameter& XABSLAction::parameters(int index) const {
  return parameters_.Get(index);
}
inline ::naothmessages::XABSLParameter* XABSLAction::mutable_parameters(int index) {
  return parameters_.Mutable(index);
}
inline ::naothmessages::XABSLParameter* XABSLAction::add_parameters() {
  return parameters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
XABSLAction::parameters() const {
  return parameters_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
XABSLAction::mutable_parameters() {
  return &parameters_;
}

// repeated .naothmessages.XABSLAction activeSubActions = 7;
inline int XABSLAction::activesubactions_size() const {
  return activesubactions_.size();
}
inline void XABSLAction::clear_activesubactions() {
  activesubactions_.Clear();
}
inline const ::naothmessages::XABSLAction& XABSLAction::activesubactions(int index) const {
  return activesubactions_.Get(index);
}
inline ::naothmessages::XABSLAction* XABSLAction::mutable_activesubactions(int index) {
  return activesubactions_.Mutable(index);
}
inline ::naothmessages::XABSLAction* XABSLAction::add_activesubactions() {
  return activesubactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >&
XABSLAction::activesubactions() const {
  return activesubactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >*
XABSLAction::mutable_activesubactions() {
  return &activesubactions_;
}

// optional double decimalValue = 8;
inline bool XABSLAction::has_decimalvalue() const {
  return _has_bit(7);
}
inline void XABSLAction::clear_decimalvalue() {
  decimalvalue_ = 0;
  _clear_bit(7);
}
inline double XABSLAction::decimalvalue() const {
  return decimalvalue_;
}
inline void XABSLAction::set_decimalvalue(double value) {
  _set_bit(7);
  decimalvalue_ = value;
}

// optional bool boolValue = 9;
inline bool XABSLAction::has_boolvalue() const {
  return _has_bit(8);
}
inline void XABSLAction::clear_boolvalue() {
  boolvalue_ = false;
  _clear_bit(8);
}
inline bool XABSLAction::boolvalue() const {
  return boolvalue_;
}
inline void XABSLAction::set_boolvalue(bool value) {
  _set_bit(8);
  boolvalue_ = value;
}

// optional string enumValue = 10;
inline bool XABSLAction::has_enumvalue() const {
  return _has_bit(9);
}
inline void XABSLAction::clear_enumvalue() {
  if (enumvalue_ != &_default_enumvalue_) {
    enumvalue_->clear();
  }
  _clear_bit(9);
}
inline const ::std::string& XABSLAction::enumvalue() const {
  return *enumvalue_;
}
inline void XABSLAction::set_enumvalue(const ::std::string& value) {
  _set_bit(9);
  if (enumvalue_ == &_default_enumvalue_) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(value);
}
inline void XABSLAction::set_enumvalue(const char* value) {
  _set_bit(9);
  if (enumvalue_ == &_default_enumvalue_) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(value);
}
inline void XABSLAction::set_enumvalue(const char* value, size_t size) {
  _set_bit(9);
  if (enumvalue_ == &_default_enumvalue_) {
    enumvalue_ = new ::std::string;
  }
  enumvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XABSLAction::mutable_enumvalue() {
  _set_bit(9);
  if (enumvalue_ == &_default_enumvalue_) {
    enumvalue_ = new ::std::string;
  }
  return enumvalue_;
}

// -------------------------------------------------------------------

// BehaviorStatus

// optional string agent = 1;
inline bool BehaviorStatus::has_agent() const {
  return _has_bit(0);
}
inline void BehaviorStatus::clear_agent() {
  if (agent_ != &_default_agent_) {
    agent_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& BehaviorStatus::agent() const {
  return *agent_;
}
inline void BehaviorStatus::set_agent(const ::std::string& value) {
  _set_bit(0);
  if (agent_ == &_default_agent_) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void BehaviorStatus::set_agent(const char* value) {
  _set_bit(0);
  if (agent_ == &_default_agent_) {
    agent_ = new ::std::string;
  }
  agent_->assign(value);
}
inline void BehaviorStatus::set_agent(const char* value, size_t size) {
  _set_bit(0);
  if (agent_ == &_default_agent_) {
    agent_ = new ::std::string;
  }
  agent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BehaviorStatus::mutable_agent() {
  _set_bit(0);
  if (agent_ == &_default_agent_) {
    agent_ = new ::std::string;
  }
  return agent_;
}

// repeated .naothmessages.XABSLAction activeRootActions = 2;
inline int BehaviorStatus::activerootactions_size() const {
  return activerootactions_.size();
}
inline void BehaviorStatus::clear_activerootactions() {
  activerootactions_.Clear();
}
inline const ::naothmessages::XABSLAction& BehaviorStatus::activerootactions(int index) const {
  return activerootactions_.Get(index);
}
inline ::naothmessages::XABSLAction* BehaviorStatus::mutable_activerootactions(int index) {
  return activerootactions_.Mutable(index);
}
inline ::naothmessages::XABSLAction* BehaviorStatus::add_activerootactions() {
  return activerootactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >&
BehaviorStatus::activerootactions() const {
  return activerootactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLAction >*
BehaviorStatus::mutable_activerootactions() {
  return &activerootactions_;
}

// repeated .naothmessages.XABSLParameter inputSymbols = 3;
inline int BehaviorStatus::inputsymbols_size() const {
  return inputsymbols_.size();
}
inline void BehaviorStatus::clear_inputsymbols() {
  inputsymbols_.Clear();
}
inline const ::naothmessages::XABSLParameter& BehaviorStatus::inputsymbols(int index) const {
  return inputsymbols_.Get(index);
}
inline ::naothmessages::XABSLParameter* BehaviorStatus::mutable_inputsymbols(int index) {
  return inputsymbols_.Mutable(index);
}
inline ::naothmessages::XABSLParameter* BehaviorStatus::add_inputsymbols() {
  return inputsymbols_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
BehaviorStatus::inputsymbols() const {
  return inputsymbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
BehaviorStatus::mutable_inputsymbols() {
  return &inputsymbols_;
}

// repeated .naothmessages.XABSLParameter outputSymbols = 4;
inline int BehaviorStatus::outputsymbols_size() const {
  return outputsymbols_.size();
}
inline void BehaviorStatus::clear_outputsymbols() {
  outputsymbols_.Clear();
}
inline const ::naothmessages::XABSLParameter& BehaviorStatus::outputsymbols(int index) const {
  return outputsymbols_.Get(index);
}
inline ::naothmessages::XABSLParameter* BehaviorStatus::mutable_outputsymbols(int index) {
  return outputsymbols_.Mutable(index);
}
inline ::naothmessages::XABSLParameter* BehaviorStatus::add_outputsymbols() {
  return outputsymbols_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >&
BehaviorStatus::outputsymbols() const {
  return outputsymbols_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::XABSLParameter >*
BehaviorStatus::mutable_outputsymbols() {
  return &outputsymbols_;
}

// optional uint32 frameNumber = 5;
inline bool BehaviorStatus::has_framenumber() const {
  return _has_bit(4);
}
inline void BehaviorStatus::clear_framenumber() {
  framenumber_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 BehaviorStatus::framenumber() const {
  return framenumber_;
}
inline void BehaviorStatus::set_framenumber(::google::protobuf::uint32 value) {
  _set_bit(4);
  framenumber_ = value;
}

// -------------------------------------------------------------------

// Module

// required string name = 1;
inline bool Module::has_name() const {
  return _has_bit(0);
}
inline void Module::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& Module::name() const {
  return *name_;
}
inline void Module::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Module::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Module::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Module::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// repeated string usedRepresentations = 2;
inline int Module::usedrepresentations_size() const {
  return usedrepresentations_.size();
}
inline void Module::clear_usedrepresentations() {
  usedrepresentations_.Clear();
}
inline const ::std::string& Module::usedrepresentations(int index) const {
  return usedrepresentations_.Get(index);
}
inline ::std::string* Module::mutable_usedrepresentations(int index) {
  return usedrepresentations_.Mutable(index);
}
inline void Module::set_usedrepresentations(int index, const ::std::string& value) {
  usedrepresentations_.Mutable(index)->assign(value);
}
inline void Module::set_usedrepresentations(int index, const char* value) {
  usedrepresentations_.Mutable(index)->assign(value);
}
inline void Module::set_usedrepresentations(int index, const char* value, size_t size) {
  usedrepresentations_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Module::add_usedrepresentations() {
  return usedrepresentations_.Add();
}
inline void Module::add_usedrepresentations(const ::std::string& value) {
  usedrepresentations_.Add()->assign(value);
}
inline void Module::add_usedrepresentations(const char* value) {
  usedrepresentations_.Add()->assign(value);
}
inline void Module::add_usedrepresentations(const char* value, size_t size) {
  usedrepresentations_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Module::usedrepresentations() const {
  return usedrepresentations_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Module::mutable_usedrepresentations() {
  return &usedrepresentations_;
}

// repeated string providedRepresentations = 3;
inline int Module::providedrepresentations_size() const {
  return providedrepresentations_.size();
}
inline void Module::clear_providedrepresentations() {
  providedrepresentations_.Clear();
}
inline const ::std::string& Module::providedrepresentations(int index) const {
  return providedrepresentations_.Get(index);
}
inline ::std::string* Module::mutable_providedrepresentations(int index) {
  return providedrepresentations_.Mutable(index);
}
inline void Module::set_providedrepresentations(int index, const ::std::string& value) {
  providedrepresentations_.Mutable(index)->assign(value);
}
inline void Module::set_providedrepresentations(int index, const char* value) {
  providedrepresentations_.Mutable(index)->assign(value);
}
inline void Module::set_providedrepresentations(int index, const char* value, size_t size) {
  providedrepresentations_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Module::add_providedrepresentations() {
  return providedrepresentations_.Add();
}
inline void Module::add_providedrepresentations(const ::std::string& value) {
  providedrepresentations_.Add()->assign(value);
}
inline void Module::add_providedrepresentations(const char* value) {
  providedrepresentations_.Add()->assign(value);
}
inline void Module::add_providedrepresentations(const char* value, size_t size) {
  providedrepresentations_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Module::providedrepresentations() const {
  return providedrepresentations_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Module::mutable_providedrepresentations() {
  return &providedrepresentations_;
}

// optional bool active = 4 [default = false];
inline bool Module::has_active() const {
  return _has_bit(3);
}
inline void Module::clear_active() {
  active_ = false;
  _clear_bit(3);
}
inline bool Module::active() const {
  return active_;
}
inline void Module::set_active(bool value) {
  _set_bit(3);
  active_ = value;
}

// -------------------------------------------------------------------

// ModuleList

// repeated .naothmessages.Module modules = 1;
inline int ModuleList::modules_size() const {
  return modules_.size();
}
inline void ModuleList::clear_modules() {
  modules_.Clear();
}
inline const ::naothmessages::Module& ModuleList::modules(int index) const {
  return modules_.Get(index);
}
inline ::naothmessages::Module* ModuleList::mutable_modules(int index) {
  return modules_.Mutable(index);
}
inline ::naothmessages::Module* ModuleList::add_modules() {
  return modules_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Module >&
ModuleList::modules() const {
  return modules_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Module >*
ModuleList::mutable_modules() {
  return &modules_;
}

// -------------------------------------------------------------------

// FeatureKeyPoint

// required .naothmessages.FloatVector2 pt = 1;
inline bool FeatureKeyPoint::has_pt() const {
  return _has_bit(0);
}
inline void FeatureKeyPoint::clear_pt() {
  if (pt_ != NULL) pt_->::naothmessages::FloatVector2::Clear();
  _clear_bit(0);
}
inline const ::naothmessages::FloatVector2& FeatureKeyPoint::pt() const {
  return pt_ != NULL ? *pt_ : *default_instance_->pt_;
}
inline ::naothmessages::FloatVector2* FeatureKeyPoint::mutable_pt() {
  _set_bit(0);
  if (pt_ == NULL) pt_ = new ::naothmessages::FloatVector2;
  return pt_;
}

// required float size = 2;
inline bool FeatureKeyPoint::has_size() const {
  return _has_bit(1);
}
inline void FeatureKeyPoint::clear_size() {
  size_ = 0;
  _clear_bit(1);
}
inline float FeatureKeyPoint::size() const {
  return size_;
}
inline void FeatureKeyPoint::set_size(float value) {
  _set_bit(1);
  size_ = value;
}

// required float angle = 3;
inline bool FeatureKeyPoint::has_angle() const {
  return _has_bit(2);
}
inline void FeatureKeyPoint::clear_angle() {
  angle_ = 0;
  _clear_bit(2);
}
inline float FeatureKeyPoint::angle() const {
  return angle_;
}
inline void FeatureKeyPoint::set_angle(float value) {
  _set_bit(2);
  angle_ = value;
}

// required float response = 4;
inline bool FeatureKeyPoint::has_response() const {
  return _has_bit(3);
}
inline void FeatureKeyPoint::clear_response() {
  response_ = 0;
  _clear_bit(3);
}
inline float FeatureKeyPoint::response() const {
  return response_;
}
inline void FeatureKeyPoint::set_response(float value) {
  _set_bit(3);
  response_ = value;
}

// required int32 octave = 5;
inline bool FeatureKeyPoint::has_octave() const {
  return _has_bit(4);
}
inline void FeatureKeyPoint::clear_octave() {
  octave_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 FeatureKeyPoint::octave() const {
  return octave_;
}
inline void FeatureKeyPoint::set_octave(::google::protobuf::int32 value) {
  _set_bit(4);
  octave_ = value;
}

// required int32 class_id = 6;
inline bool FeatureKeyPoint::has_class_id() const {
  return _has_bit(5);
}
inline void FeatureKeyPoint::clear_class_id() {
  class_id_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 FeatureKeyPoint::class_id() const {
  return class_id_;
}
inline void FeatureKeyPoint::set_class_id(::google::protobuf::int32 value) {
  _set_bit(5);
  class_id_ = value;
}

// -------------------------------------------------------------------

// FeatureDetectionResult

// required bytes grayScaleImage = 1;
inline bool FeatureDetectionResult::has_grayscaleimage() const {
  return _has_bit(0);
}
inline void FeatureDetectionResult::clear_grayscaleimage() {
  if (grayscaleimage_ != &_default_grayscaleimage_) {
    grayscaleimage_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FeatureDetectionResult::grayscaleimage() const {
  return *grayscaleimage_;
}
inline void FeatureDetectionResult::set_grayscaleimage(const ::std::string& value) {
  _set_bit(0);
  if (grayscaleimage_ == &_default_grayscaleimage_) {
    grayscaleimage_ = new ::std::string;
  }
  grayscaleimage_->assign(value);
}
inline void FeatureDetectionResult::set_grayscaleimage(const char* value) {
  _set_bit(0);
  if (grayscaleimage_ == &_default_grayscaleimage_) {
    grayscaleimage_ = new ::std::string;
  }
  grayscaleimage_->assign(value);
}
inline void FeatureDetectionResult::set_grayscaleimage(const void* value, size_t size) {
  _set_bit(0);
  if (grayscaleimage_ == &_default_grayscaleimage_) {
    grayscaleimage_ = new ::std::string;
  }
  grayscaleimage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureDetectionResult::mutable_grayscaleimage() {
  _set_bit(0);
  if (grayscaleimage_ == &_default_grayscaleimage_) {
    grayscaleimage_ = new ::std::string;
  }
  return grayscaleimage_;
}

// repeated .naothmessages.FeatureKeyPoint keyPoints = 2;
inline int FeatureDetectionResult::keypoints_size() const {
  return keypoints_.size();
}
inline void FeatureDetectionResult::clear_keypoints() {
  keypoints_.Clear();
}
inline const ::naothmessages::FeatureKeyPoint& FeatureDetectionResult::keypoints(int index) const {
  return keypoints_.Get(index);
}
inline ::naothmessages::FeatureKeyPoint* FeatureDetectionResult::mutable_keypoints(int index) {
  return keypoints_.Mutable(index);
}
inline ::naothmessages::FeatureKeyPoint* FeatureDetectionResult::add_keypoints() {
  return keypoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureKeyPoint >&
FeatureDetectionResult::keypoints() const {
  return keypoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureKeyPoint >*
FeatureDetectionResult::mutable_keypoints() {
  return &keypoints_;
}

// repeated .naothmessages.SingleDescriptor descriptors = 3;
inline int FeatureDetectionResult::descriptors_size() const {
  return descriptors_.size();
}
inline void FeatureDetectionResult::clear_descriptors() {
  descriptors_.Clear();
}
inline const ::naothmessages::SingleDescriptor& FeatureDetectionResult::descriptors(int index) const {
  return descriptors_.Get(index);
}
inline ::naothmessages::SingleDescriptor* FeatureDetectionResult::mutable_descriptors(int index) {
  return descriptors_.Mutable(index);
}
inline ::naothmessages::SingleDescriptor* FeatureDetectionResult::add_descriptors() {
  return descriptors_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >&
FeatureDetectionResult::descriptors() const {
  return descriptors_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >*
FeatureDetectionResult::mutable_descriptors() {
  return &descriptors_;
}

// repeated string namesForKeyPoints = 4;
inline int FeatureDetectionResult::namesforkeypoints_size() const {
  return namesforkeypoints_.size();
}
inline void FeatureDetectionResult::clear_namesforkeypoints() {
  namesforkeypoints_.Clear();
}
inline const ::std::string& FeatureDetectionResult::namesforkeypoints(int index) const {
  return namesforkeypoints_.Get(index);
}
inline ::std::string* FeatureDetectionResult::mutable_namesforkeypoints(int index) {
  return namesforkeypoints_.Mutable(index);
}
inline void FeatureDetectionResult::set_namesforkeypoints(int index, const ::std::string& value) {
  namesforkeypoints_.Mutable(index)->assign(value);
}
inline void FeatureDetectionResult::set_namesforkeypoints(int index, const char* value) {
  namesforkeypoints_.Mutable(index)->assign(value);
}
inline void FeatureDetectionResult::set_namesforkeypoints(int index, const char* value, size_t size) {
  namesforkeypoints_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureDetectionResult::add_namesforkeypoints() {
  return namesforkeypoints_.Add();
}
inline void FeatureDetectionResult::add_namesforkeypoints(const ::std::string& value) {
  namesforkeypoints_.Add()->assign(value);
}
inline void FeatureDetectionResult::add_namesforkeypoints(const char* value) {
  namesforkeypoints_.Add()->assign(value);
}
inline void FeatureDetectionResult::add_namesforkeypoints(const char* value, size_t size) {
  namesforkeypoints_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FeatureDetectionResult::namesforkeypoints() const {
  return namesforkeypoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FeatureDetectionResult::mutable_namesforkeypoints() {
  return &namesforkeypoints_;
}

// optional int32 numberOfFeatureElements = 5 [default = 64];
inline bool FeatureDetectionResult::has_numberoffeatureelements() const {
  return _has_bit(4);
}
inline void FeatureDetectionResult::clear_numberoffeatureelements() {
  numberoffeatureelements_ = 64;
  _clear_bit(4);
}
inline ::google::protobuf::int32 FeatureDetectionResult::numberoffeatureelements() const {
  return numberoffeatureelements_;
}
inline void FeatureDetectionResult::set_numberoffeatureelements(::google::protobuf::int32 value) {
  _set_bit(4);
  numberoffeatureelements_ = value;
}

// -------------------------------------------------------------------

// SingleDescriptor

// repeated float d = 1;
inline int SingleDescriptor::d_size() const {
  return d_.size();
}
inline void SingleDescriptor::clear_d() {
  d_.Clear();
}
inline float SingleDescriptor::d(int index) const {
  return d_.Get(index);
}
inline void SingleDescriptor::set_d(int index, float value) {
  d_.Set(index, value);
}
inline void SingleDescriptor::add_d(float value) {
  d_.Add(value);
}
inline const ::google::protobuf::RepeatedField< float >&
SingleDescriptor::d() const {
  return d_;
}
inline ::google::protobuf::RepeatedField< float >*
SingleDescriptor::mutable_d() {
  return &d_;
}

// -------------------------------------------------------------------

// FeatureClass

// required string name = 1;
inline bool FeatureClass::has_name() const {
  return _has_bit(0);
}
inline void FeatureClass::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& FeatureClass::name() const {
  return *name_;
}
inline void FeatureClass::set_name(const ::std::string& value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FeatureClass::set_name(const char* value) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void FeatureClass::set_name(const char* value, size_t size) {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FeatureClass::mutable_name() {
  _set_bit(0);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// repeated .naothmessages.SingleDescriptor samples = 2;
inline int FeatureClass::samples_size() const {
  return samples_.size();
}
inline void FeatureClass::clear_samples() {
  samples_.Clear();
}
inline const ::naothmessages::SingleDescriptor& FeatureClass::samples(int index) const {
  return samples_.Get(index);
}
inline ::naothmessages::SingleDescriptor* FeatureClass::mutable_samples(int index) {
  return samples_.Mutable(index);
}
inline ::naothmessages::SingleDescriptor* FeatureClass::add_samples() {
  return samples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >&
FeatureClass::samples() const {
  return samples_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::SingleDescriptor >*
FeatureClass::mutable_samples() {
  return &samples_;
}

// optional double objectHeight = 3;
inline bool FeatureClass::has_objectheight() const {
  return _has_bit(2);
}
inline void FeatureClass::clear_objectheight() {
  objectheight_ = 0;
  _clear_bit(2);
}
inline double FeatureClass::objectheight() const {
  return objectheight_;
}
inline void FeatureClass::set_objectheight(double value) {
  _set_bit(2);
  objectheight_ = value;
}

// -------------------------------------------------------------------

// FeatureTable

// repeated .naothmessages.FeatureClass classes = 1;
inline int FeatureTable::classes_size() const {
  return classes_.size();
}
inline void FeatureTable::clear_classes() {
  classes_.Clear();
}
inline const ::naothmessages::FeatureClass& FeatureTable::classes(int index) const {
  return classes_.Get(index);
}
inline ::naothmessages::FeatureClass* FeatureTable::mutable_classes(int index) {
  return classes_.Mutable(index);
}
inline ::naothmessages::FeatureClass* FeatureTable::add_classes() {
  return classes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureClass >&
FeatureTable::classes() const {
  return classes_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::FeatureClass >*
FeatureTable::mutable_classes() {
  return &classes_;
}

// optional int32 numberOfFeatureElements = 2 [default = 64];
inline bool FeatureTable::has_numberoffeatureelements() const {
  return _has_bit(1);
}
inline void FeatureTable::clear_numberoffeatureelements() {
  numberoffeatureelements_ = 64;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FeatureTable::numberoffeatureelements() const {
  return numberoffeatureelements_;
}
inline void FeatureTable::set_numberoffeatureelements(::google::protobuf::int32 value) {
  _set_bit(1);
  numberoffeatureelements_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace naothmessages

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::PlotItem_PlotType>() {
  return ::naothmessages::PlotItem_PlotType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::XABSLParameter_ParamType>() {
  return ::naothmessages::XABSLParameter_ParamType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::XABSLAction_ActionType>() {
  return ::naothmessages::XABSLAction_ActionType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Messages_2eproto__INCLUDED
