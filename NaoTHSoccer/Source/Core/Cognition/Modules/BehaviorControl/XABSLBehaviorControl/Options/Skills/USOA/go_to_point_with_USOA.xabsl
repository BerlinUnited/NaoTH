option go_to_point_with_USOA
{
 /** x position of the point to walk to on the field */
 float @x; //[-4500..4500] "mm";

 /** y position of the point to walk to on the field */
 float @y; // [-3000..3000] "mm";

 /** absolute rotation on field */
 float @rot; // -180...180 "deg";

 initial state go
  {
  
    decision
    {
      if ((vector.abs(x=locator.field_to_relative.x(x=@x, y=@y), y=locator.field_to_relative.y(x=@x, y=@y)) < obstacle.ultrasound.distance)
            &&(obstacle.ultrasound.distance<400) && (obstacle.ultrasound.blockedtime > 200))
          goto approach_carefully;
      else if(obstacle.ultrasound.left.distance < 400 && (obstacle.ultrasound.blockedtime > 200))
          goto avoid_left;
      else if(obstacle.ultrasound.right.distance < 400 && (obstacle.ultrasound.blockedtime > 200))
          goto avoid_right;
      else if(action_done)
        goto finish;
      else
        stay;
    }
    action 
    {
      go_to_point(x=@x,y=@y,rot=@rot);
    }
  }

  state avoid_left
  {
    decision
    { if ((vector.abs(x=locator.field_to_relative.x(x=@x, y=@y), y=locator.field_to_relative.y(x=@x, y=@y)) < obstacle.ultrasound.distance)
            &&(obstacle.ultrasound.distance<400) && (obstacle.ultrasound.blockedtime > 200))
        goto approach_carefully;
      else if(state_time > 3000)
        goto push;
      else if(obstacle.ultrasound.left.distance < 400 && (obstacle.ultrasound.blockedtime > 200))
        stay;
      else if(obstacle.ultrasound.right.distance < 400 && (obstacle.ultrasound.blockedtime > 200))
        goto avoid_right;
      else
        goto go;
    }
    action 
    {
      head.control_mode = search_for_ball;
      
      motion.type = walk;
      motion.walk.coordinate = hip;
      motion.walk.style = normal;

      motion.walk_speed.x = 0;
      motion.walk_speed.y = -60;
      motion.walk_speed.rot = 0;//(vector.abs(x=ball.preview.x, y=ball.preview.y) > 250) ? atan2(y = ball.preview.y, x = ball.preview.x) : 0;

    }
  }


  state avoid_right
  {
    decision
    { if ((vector.abs(x=locator.field_to_relative.x(x=@x, y=@y), y=locator.field_to_relative.y(x=@x, y=@y)) < obstacle.ultrasound.distance)
            &&(obstacle.ultrasound.distance<400) && (obstacle.ultrasound.blockedtime > 200))
        goto approach_carefully;
      else if(state_time > 3000)
        goto push;
      else if(obstacle.ultrasound.right.distance < 400 && (obstacle.ultrasound.blockedtime > 200))
        stay;
      else if(obstacle.ultrasound.left.distance < 400 && (obstacle.ultrasound.blockedtime > 200))
        goto avoid_left;
      else
        goto go;
    }
    action 
    {
      head.control_mode = search_for_ball;
      
      motion.type = walk;
      motion.walk.coordinate = hip;
      motion.walk.style = normal;

      motion.walk_speed.x = 0;
      motion.walk_speed.y = 60;
      motion.walk_speed.rot =0; //(vector.abs(x=ball.preview.x, y=ball.preview.y) > 250) ? atan2(y = ball.preview.y, x = ball.preview.x) : 0;

    }
  }

  state push {
  decision
  {
      if ( vector.abs(x=robot_pose.planned.x - @x, y=robot_pose.planned.y - @y) < 30
          && abs(value=robot_pose.planned.rotation - @rot) < 10 )
        goto finish;
      else if((obstacle.ultrasound.left.distance < 400)&&(state_time>1500) && (obstacle.ultrasound.blockedtime > 200))
        goto avoid_left;
      else if((obstacle.ultrasound.right.distance < 400)&&(state_time>1500) && (obstacle.ultrasound.blockedtime > 200))
        goto avoid_right;
      else if(obstacle.ultrasound.distance>400)
        goto go;
      else
        stay;
  }

  action
  {
      motion.type = walk;
      motion.walk.style = stable;
      
      motion.walk.coordinate = hip;
      motion.walk_speed.rot = normalize(angle=atan2(y = @y - robot_pose.planned.y, x = @x - robot_pose.planned.x) - robot_pose.planned.rotation);
      motion.walk_speed.x = clip(value=vector.abs(x = @x - robot_pose.planned.x, y = @y - robot_pose.planned.y) * cos(angle=motion.walk_speed.rot), min=-15, max=15);
      motion.walk_speed.y = clip(value=vector.abs(x = @x - robot_pose.planned.x, y = @y - robot_pose.planned.y) * sin(angle=motion.walk_speed.rot), min=-15, max=15);
  }
}

  state approach_carefully{

    decision{
      if ( vector.abs(x=robot_pose.planned.x - @x, y=robot_pose.planned.y - @y) < 30
          && abs(value=robot_pose.planned.rotation - @rot) < 10 )
        goto finish;
      else if(vector.abs(x=locator.field_to_relative.x(x=@x, y=@y), y=locator.field_to_relative.y(x=@x, y=@y))  > obstacle.ultrasound.distance)
        goto push;
      else if (obstacle.ultrasound.distance>400)
        goto go;
      else
        stay;
    }

    action{
      head.control_mode = search_for_ball;
      
      motion.type = walk;
      motion.walk.style = stable;

      motion.walk.coordinate = hip;
      motion.walk_speed.rot = normalize(angle=atan2(y = @y - robot_pose.planned.y, x = @x - robot_pose.planned.x) - robot_pose.planned.rotation);
      motion.walk_speed.x = clip(value=vector.abs(x = @x - robot_pose.planned.x, y = @y - robot_pose.planned.y) * cos(angle=motion.walk_speed.rot), min=-15, max=15);
      motion.walk_speed.y = clip(value=vector.abs(x = @x - robot_pose.planned.x, y = @y - robot_pose.planned.y) * sin(angle=motion.walk_speed.rot), min=-15, max=15);
  }
  }

  target state finish{
    decision
    {
      if ( vector.abs(x=robot_pose.planned.x - @x, y=robot_pose.planned.y - @y) > 30
          || abs(value=robot_pose.planned.rotation - @rot) > 10 )
        goto go;
      else
        stay;
    }
    action
    {
      head.control_mode = search_for_ball;
      
      motion.type = stand;
    }
  }
  

}