// added by NaoTH 
#if defined(__GNUC__) && defined(_NAOTH_CHECK_CONVERSION_)
#if __GNUC__ > 3 && __GNUC_MINOR__ > 5
#pragma GCC diagnostic push
#endif
#pragma GCC diagnostic ignored "-Wconversion"
#endif

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Representations.proto

#ifndef PROTOBUF_Representations_2eproto__INCLUDED
#define PROTOBUF_Representations_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
#include "CommonTypes.pb.h"
#include "Framework-Representations.pb.h"
// @@protoc_insertion_point(includes)

namespace naothmessages {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Representations_2eproto();
void protobuf_AssignDesc_Representations_2eproto();
void protobuf_ShutdownFile_Representations_2eproto();

class CameraMatrix;
class BallPercept;
class GoalPercept;
class HeadMotionRequest;
class StepControlRequest;
class WalkRequest;
class KickRequest;
class GraspRequest;
class ArmMotionRequest;
class MotionRequest;
class LinePercept;
class ScanLineEndPoint;
class Edgel;
class EdgelPair;
class ScanLineEdgelPercept;
class StepControlStatus;
class MotionStatus;
class OdometryData;
class CalibrationData;
class InertialModel;
class TeamMessageCollection;
class TeamMessage;
class BUUserTeamMessage;
class Opponent;
class CameraMatrixCalibration;

enum TeamColor {
  blueTeam = 0,
  redTeam = 1,
  invalidTeam = 2
};
bool TeamColor_IsValid(int value);
const TeamColor TeamColor_MIN = blueTeam;
const TeamColor TeamColor_MAX = invalidTeam;
const int TeamColor_ARRAYSIZE = TeamColor_MAX + 1;

const ::google::protobuf::EnumDescriptor* TeamColor_descriptor();
inline const ::std::string& TeamColor_Name(TeamColor value) {
  return ::google::protobuf::internal::NameOfEnum(
    TeamColor_descriptor(), value);
}
inline bool TeamColor_Parse(
    const ::std::string& name, TeamColor* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TeamColor>(
    TeamColor_descriptor(), name, value);
}
// ===================================================================

class CameraMatrix : public ::google::protobuf::Message {
 public:
  CameraMatrix();
  virtual ~CameraMatrix();
  
  CameraMatrix(const CameraMatrix& from);
  
  inline CameraMatrix& operator=(const CameraMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraMatrix& default_instance();
  
  void Swap(CameraMatrix* other);
  
  // implements Message ----------------------------------------------
  
  CameraMatrix* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraMatrix& from);
  void MergeFrom(const CameraMatrix& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.Pose3D pose = 1;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 1;
  inline const ::naothmessages::Pose3D& pose() const;
  inline ::naothmessages::Pose3D* mutable_pose();
  inline ::naothmessages::Pose3D* release_pose();
  
  // optional .naothmessages.CameraID cameraID = 2 [default = bottom];
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraIDFieldNumber = 2;
  inline naothmessages::CameraID cameraid() const;
  inline void set_cameraid(naothmessages::CameraID value);
  
  // optional bool valid = 3;
  inline bool has_valid() const;
  inline void clear_valid();
  static const int kValidFieldNumber = 3;
  inline bool valid() const;
  inline void set_valid(bool value);
  
  // optional uint32 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.CameraMatrix)
 private:
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_cameraid();
  inline void clear_has_cameraid();
  inline void set_has_valid();
  inline void clear_has_valid();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::Pose3D* pose_;
  int cameraid_;
  bool valid_;
  ::google::protobuf::uint32 timestamp_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static CameraMatrix* default_instance_;
};
// -------------------------------------------------------------------

class BallPercept : public ::google::protobuf::Message {
 public:
  BallPercept();
  virtual ~BallPercept();
  
  BallPercept(const BallPercept& from);
  
  inline BallPercept& operator=(const BallPercept& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BallPercept& default_instance();
  
  void Swap(BallPercept* other);
  
  // implements Message ----------------------------------------------
  
  BallPercept* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BallPercept& from);
  void MergeFrom(const BallPercept& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool ballWasSeen = 1;
  inline bool has_ballwasseen() const;
  inline void clear_ballwasseen();
  static const int kBallWasSeenFieldNumber = 1;
  inline bool ballwasseen() const;
  inline void set_ballwasseen(bool value);
  
  // optional .naothmessages.DoubleVector2 centerInImage = 2;
  inline bool has_centerinimage() const;
  inline void clear_centerinimage();
  static const int kCenterInImageFieldNumber = 2;
  inline const ::naothmessages::DoubleVector2& centerinimage() const;
  inline ::naothmessages::DoubleVector2* mutable_centerinimage();
  inline ::naothmessages::DoubleVector2* release_centerinimage();
  
  // optional double radiusInImage = 3;
  inline bool has_radiusinimage() const;
  inline void clear_radiusinimage();
  static const int kRadiusInImageFieldNumber = 3;
  inline double radiusinimage() const;
  inline void set_radiusinimage(double value);
  
  // optional .naothmessages.Color ballColor = 4;
  inline bool has_ballcolor() const;
  inline void clear_ballcolor();
  static const int kBallColorFieldNumber = 4;
  inline naothmessages::Color ballcolor() const;
  inline void set_ballcolor(naothmessages::Color value);
  
  // optional .naothmessages.DoubleVector2 bearingBasedOffsetOnField = 5;
  inline bool has_bearingbasedoffsetonfield() const;
  inline void clear_bearingbasedoffsetonfield();
  static const int kBearingBasedOffsetOnFieldFieldNumber = 5;
  inline const ::naothmessages::DoubleVector2& bearingbasedoffsetonfield() const;
  inline ::naothmessages::DoubleVector2* mutable_bearingbasedoffsetonfield();
  inline ::naothmessages::DoubleVector2* release_bearingbasedoffsetonfield();
  
  // optional .naothmessages.FrameInfo frameInfoWhenBallWasSeen = 6;
  inline bool has_frameinfowhenballwasseen() const;
  inline void clear_frameinfowhenballwasseen();
  static const int kFrameInfoWhenBallWasSeenFieldNumber = 6;
  inline const ::naothmessages::FrameInfo& frameinfowhenballwasseen() const;
  inline ::naothmessages::FrameInfo* mutable_frameinfowhenballwasseen();
  inline ::naothmessages::FrameInfo* release_frameinfowhenballwasseen();
  
  // @@protoc_insertion_point(class_scope:naothmessages.BallPercept)
 private:
  inline void set_has_ballwasseen();
  inline void clear_has_ballwasseen();
  inline void set_has_centerinimage();
  inline void clear_has_centerinimage();
  inline void set_has_radiusinimage();
  inline void clear_has_radiusinimage();
  inline void set_has_ballcolor();
  inline void clear_has_ballcolor();
  inline void set_has_bearingbasedoffsetonfield();
  inline void clear_has_bearingbasedoffsetonfield();
  inline void set_has_frameinfowhenballwasseen();
  inline void clear_has_frameinfowhenballwasseen();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::DoubleVector2* centerinimage_;
  bool ballwasseen_;
  int ballcolor_;
  double radiusinimage_;
  ::naothmessages::DoubleVector2* bearingbasedoffsetonfield_;
  ::naothmessages::FrameInfo* frameinfowhenballwasseen_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static BallPercept* default_instance_;
};
// -------------------------------------------------------------------

class GoalPercept : public ::google::protobuf::Message {
 public:
  GoalPercept();
  virtual ~GoalPercept();
  
  GoalPercept(const GoalPercept& from);
  
  inline GoalPercept& operator=(const GoalPercept& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GoalPercept& default_instance();
  
  void Swap(GoalPercept* other);
  
  // implements Message ----------------------------------------------
  
  GoalPercept* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GoalPercept& from);
  void MergeFrom(const GoalPercept& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional double angleToSeenGoal = 1;
  inline bool has_angletoseengoal() const;
  inline void clear_angletoseengoal();
  static const int kAngleToSeenGoalFieldNumber = 1;
  inline double angletoseengoal() const;
  inline void set_angletoseengoal(double value);
  
  // optional .naothmessages.DoubleVector3 goalCentroid = 2;
  inline bool has_goalcentroid() const;
  inline void clear_goalcentroid();
  static const int kGoalCentroidFieldNumber = 2;
  inline const ::naothmessages::DoubleVector3& goalcentroid() const;
  inline ::naothmessages::DoubleVector3* mutable_goalcentroid();
  inline ::naothmessages::DoubleVector3* release_goalcentroid();
  
  // optional int32 numberOfSeenPosts = 3;
  inline bool has_numberofseenposts() const;
  inline void clear_numberofseenposts();
  static const int kNumberOfSeenPostsFieldNumber = 3;
  inline ::google::protobuf::int32 numberofseenposts() const;
  inline void set_numberofseenposts(::google::protobuf::int32 value);
  
  // repeated .naothmessages.GoalPost post = 4;
  inline int post_size() const;
  inline void clear_post();
  static const int kPostFieldNumber = 4;
  inline const ::naothmessages::GoalPost& post(int index) const;
  inline ::naothmessages::GoalPost* mutable_post(int index);
  inline ::naothmessages::GoalPost* add_post();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::GoalPost >&
      post() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::GoalPost >*
      mutable_post();
  
  // @@protoc_insertion_point(class_scope:naothmessages.GoalPercept)
 private:
  inline void set_has_angletoseengoal();
  inline void clear_has_angletoseengoal();
  inline void set_has_goalcentroid();
  inline void clear_has_goalcentroid();
  inline void set_has_numberofseenposts();
  inline void clear_has_numberofseenposts();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double angletoseengoal_;
  ::naothmessages::DoubleVector3* goalcentroid_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::GoalPost > post_;
  ::google::protobuf::int32 numberofseenposts_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static GoalPercept* default_instance_;
};
// -------------------------------------------------------------------

class HeadMotionRequest : public ::google::protobuf::Message {
 public:
  HeadMotionRequest();
  virtual ~HeadMotionRequest();
  
  HeadMotionRequest(const HeadMotionRequest& from);
  
  inline HeadMotionRequest& operator=(const HeadMotionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeadMotionRequest& default_instance();
  
  void Swap(HeadMotionRequest* other);
  
  // implements Message ----------------------------------------------
  
  HeadMotionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeadMotionRequest& from);
  void MergeFrom(const HeadMotionRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required uint32 cameraID = 2;
  inline bool has_cameraid() const;
  inline void clear_cameraid();
  static const int kCameraIDFieldNumber = 2;
  inline ::google::protobuf::uint32 cameraid() const;
  inline void set_cameraid(::google::protobuf::uint32 value);
  
  // optional .naothmessages.DoubleVector2 targetJointPosition = 3;
  inline bool has_targetjointposition() const;
  inline void clear_targetjointposition();
  static const int kTargetJointPositionFieldNumber = 3;
  inline const ::naothmessages::DoubleVector2& targetjointposition() const;
  inline ::naothmessages::DoubleVector2* mutable_targetjointposition();
  inline ::naothmessages::DoubleVector2* release_targetjointposition();
  
  // optional .naothmessages.DoubleVector2 targetPointInImage = 4;
  inline bool has_targetpointinimage() const;
  inline void clear_targetpointinimage();
  static const int kTargetPointInImageFieldNumber = 4;
  inline const ::naothmessages::DoubleVector2& targetpointinimage() const;
  inline ::naothmessages::DoubleVector2* mutable_targetpointinimage();
  inline ::naothmessages::DoubleVector2* release_targetpointinimage();
  
  // optional .naothmessages.DoubleVector3 targetPointInTheWorld = 5;
  inline bool has_targetpointintheworld() const;
  inline void clear_targetpointintheworld();
  static const int kTargetPointInTheWorldFieldNumber = 5;
  inline const ::naothmessages::DoubleVector3& targetpointintheworld() const;
  inline ::naothmessages::DoubleVector3* mutable_targetpointintheworld();
  inline ::naothmessages::DoubleVector3* release_targetpointintheworld();
  
  // optional .naothmessages.DoubleVector3 searchCenter = 6;
  inline bool has_searchcenter() const;
  inline void clear_searchcenter();
  static const int kSearchCenterFieldNumber = 6;
  inline const ::naothmessages::DoubleVector3& searchcenter() const;
  inline ::naothmessages::DoubleVector3* mutable_searchcenter();
  inline ::naothmessages::DoubleVector3* release_searchcenter();
  
  // optional .naothmessages.DoubleVector3 searchSize = 7;
  inline bool has_searchsize() const;
  inline void clear_searchsize();
  static const int kSearchSizeFieldNumber = 7;
  inline const ::naothmessages::DoubleVector3& searchsize() const;
  inline ::naothmessages::DoubleVector3* mutable_searchsize();
  inline ::naothmessages::DoubleVector3* release_searchsize();
  
  // optional bool searchDirection = 8;
  inline bool has_searchdirection() const;
  inline void clear_searchdirection();
  static const int kSearchDirectionFieldNumber = 8;
  inline bool searchdirection() const;
  inline void set_searchdirection(bool value);
  
  // optional .naothmessages.DoubleVector2 targetPointOnTheGround = 9;
  inline bool has_targetpointontheground() const;
  inline void clear_targetpointontheground();
  static const int kTargetPointOnTheGroundFieldNumber = 9;
  inline const ::naothmessages::DoubleVector2& targetpointontheground() const;
  inline ::naothmessages::DoubleVector2* mutable_targetpointontheground();
  inline ::naothmessages::DoubleVector2* release_targetpointontheground();
  
  // optional uint32 coordinate = 10;
  inline bool has_coordinate() const;
  inline void clear_coordinate();
  static const int kCoordinateFieldNumber = 10;
  inline ::google::protobuf::uint32 coordinate() const;
  inline void set_coordinate(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.HeadMotionRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_cameraid();
  inline void clear_has_cameraid();
  inline void set_has_targetjointposition();
  inline void clear_has_targetjointposition();
  inline void set_has_targetpointinimage();
  inline void clear_has_targetpointinimage();
  inline void set_has_targetpointintheworld();
  inline void clear_has_targetpointintheworld();
  inline void set_has_searchcenter();
  inline void clear_has_searchcenter();
  inline void set_has_searchsize();
  inline void clear_has_searchsize();
  inline void set_has_searchdirection();
  inline void clear_has_searchdirection();
  inline void set_has_targetpointontheground();
  inline void clear_has_targetpointontheground();
  inline void set_has_coordinate();
  inline void clear_has_coordinate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 cameraid_;
  ::naothmessages::DoubleVector2* targetjointposition_;
  ::naothmessages::DoubleVector2* targetpointinimage_;
  ::naothmessages::DoubleVector3* targetpointintheworld_;
  ::naothmessages::DoubleVector3* searchcenter_;
  ::naothmessages::DoubleVector3* searchsize_;
  ::naothmessages::DoubleVector2* targetpointontheground_;
  bool searchdirection_;
  ::google::protobuf::uint32 coordinate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static HeadMotionRequest* default_instance_;
};
// -------------------------------------------------------------------

class StepControlRequest : public ::google::protobuf::Message {
 public:
  StepControlRequest();
  virtual ~StepControlRequest();
  
  StepControlRequest(const StepControlRequest& from);
  
  inline StepControlRequest& operator=(const StepControlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StepControlRequest& default_instance();
  
  void Swap(StepControlRequest* other);
  
  // implements Message ----------------------------------------------
  
  StepControlRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StepControlRequest& from);
  void MergeFrom(const StepControlRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 stepID = 1;
  inline bool has_stepid() const;
  inline void clear_stepid();
  static const int kStepIDFieldNumber = 1;
  inline ::google::protobuf::uint32 stepid() const;
  inline void set_stepid(::google::protobuf::uint32 value);
  
  // required bool moveLeftFoot = 2;
  inline bool has_moveleftfoot() const;
  inline void clear_moveleftfoot();
  static const int kMoveLeftFootFieldNumber = 2;
  inline bool moveleftfoot() const;
  inline void set_moveleftfoot(bool value);
  
  // required .naothmessages.Pose2D target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::naothmessages::Pose2D& target() const;
  inline ::naothmessages::Pose2D* mutable_target();
  inline ::naothmessages::Pose2D* release_target();
  
  // required uint32 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 4;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);
  
  // required double speedDirection = 5;
  inline bool has_speeddirection() const;
  inline void clear_speeddirection();
  static const int kSpeedDirectionFieldNumber = 5;
  inline double speeddirection() const;
  inline void set_speeddirection(double value);
  
  // required double scale = 6;
  inline bool has_scale() const;
  inline void clear_scale();
  static const int kScaleFieldNumber = 6;
  inline double scale() const;
  inline void set_scale(double value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.StepControlRequest)
 private:
  inline void set_has_stepid();
  inline void clear_has_stepid();
  inline void set_has_moveleftfoot();
  inline void clear_has_moveleftfoot();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_speeddirection();
  inline void clear_has_speeddirection();
  inline void set_has_scale();
  inline void clear_has_scale();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 stepid_;
  bool moveleftfoot_;
  ::naothmessages::Pose2D* target_;
  double speeddirection_;
  double scale_;
  ::google::protobuf::uint32 time_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static StepControlRequest* default_instance_;
};
// -------------------------------------------------------------------

class WalkRequest : public ::google::protobuf::Message {
 public:
  WalkRequest();
  virtual ~WalkRequest();
  
  WalkRequest(const WalkRequest& from);
  
  inline WalkRequest& operator=(const WalkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const WalkRequest& default_instance();
  
  void Swap(WalkRequest* other);
  
  // implements Message ----------------------------------------------
  
  WalkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WalkRequest& from);
  void MergeFrom(const WalkRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 coordinate = 1;
  inline bool has_coordinate() const;
  inline void clear_coordinate();
  static const int kCoordinateFieldNumber = 1;
  inline ::google::protobuf::uint32 coordinate() const;
  inline void set_coordinate(::google::protobuf::uint32 value);
  
  // required double character = 2;
  inline bool has_character() const;
  inline void clear_character();
  static const int kCharacterFieldNumber = 2;
  inline double character() const;
  inline void set_character(double value);
  
  // required .naothmessages.Pose2D target = 3;
  inline bool has_target() const;
  inline void clear_target();
  static const int kTargetFieldNumber = 3;
  inline const ::naothmessages::Pose2D& target() const;
  inline ::naothmessages::Pose2D* mutable_target();
  inline ::naothmessages::Pose2D* release_target();
  
  // optional .naothmessages.StepControlRequest stepControl = 4;
  inline bool has_stepcontrol() const;
  inline void clear_stepcontrol();
  static const int kStepControlFieldNumber = 4;
  inline const ::naothmessages::StepControlRequest& stepcontrol() const;
  inline ::naothmessages::StepControlRequest* mutable_stepcontrol();
  inline ::naothmessages::StepControlRequest* release_stepcontrol();
  
  // required .naothmessages.Pose2D offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline const ::naothmessages::Pose2D& offset() const;
  inline ::naothmessages::Pose2D* mutable_offset();
  inline ::naothmessages::Pose2D* release_offset();
  
  // @@protoc_insertion_point(class_scope:naothmessages.WalkRequest)
 private:
  inline void set_has_coordinate();
  inline void clear_has_coordinate();
  inline void set_has_character();
  inline void clear_has_character();
  inline void set_has_target();
  inline void clear_has_target();
  inline void set_has_stepcontrol();
  inline void clear_has_stepcontrol();
  inline void set_has_offset();
  inline void clear_has_offset();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  double character_;
  ::naothmessages::Pose2D* target_;
  ::naothmessages::StepControlRequest* stepcontrol_;
  ::naothmessages::Pose2D* offset_;
  ::google::protobuf::uint32 coordinate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static WalkRequest* default_instance_;
};
// -------------------------------------------------------------------

class KickRequest : public ::google::protobuf::Message {
 public:
  KickRequest();
  virtual ~KickRequest();
  
  KickRequest(const KickRequest& from);
  
  inline KickRequest& operator=(const KickRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const KickRequest& default_instance();
  
  void Swap(KickRequest* other);
  
  // implements Message ----------------------------------------------
  
  KickRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KickRequest& from);
  void MergeFrom(const KickRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.DoubleVector3 kickPoint = 1;
  inline bool has_kickpoint() const;
  inline void clear_kickpoint();
  static const int kKickPointFieldNumber = 1;
  inline const ::naothmessages::DoubleVector3& kickpoint() const;
  inline ::naothmessages::DoubleVector3* mutable_kickpoint();
  inline ::naothmessages::DoubleVector3* release_kickpoint();
  
  // required double kickDirection = 2;
  inline bool has_kickdirection() const;
  inline void clear_kickdirection();
  static const int kKickDirectionFieldNumber = 2;
  inline double kickdirection() const;
  inline void set_kickdirection(double value);
  
  // required int32 kickFoot = 3;
  inline bool has_kickfoot() const;
  inline void clear_kickfoot();
  static const int kKickFootFieldNumber = 3;
  inline ::google::protobuf::int32 kickfoot() const;
  inline void set_kickfoot(::google::protobuf::int32 value);
  
  // required bool finishKick = 4;
  inline bool has_finishkick() const;
  inline void clear_finishkick();
  static const int kFinishKickFieldNumber = 4;
  inline bool finishkick() const;
  inline void set_finishkick(bool value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.KickRequest)
 private:
  inline void set_has_kickpoint();
  inline void clear_has_kickpoint();
  inline void set_has_kickdirection();
  inline void clear_has_kickdirection();
  inline void set_has_kickfoot();
  inline void clear_has_kickfoot();
  inline void set_has_finishkick();
  inline void clear_has_finishkick();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::DoubleVector3* kickpoint_;
  double kickdirection_;
  ::google::protobuf::int32 kickfoot_;
  bool finishkick_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static KickRequest* default_instance_;
};
// -------------------------------------------------------------------

class GraspRequest : public ::google::protobuf::Message {
 public:
  GraspRequest();
  virtual ~GraspRequest();
  
  GraspRequest(const GraspRequest& from);
  
  inline GraspRequest& operator=(const GraspRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const GraspRequest& default_instance();
  
  void Swap(GraspRequest* other);
  
  // implements Message ----------------------------------------------
  
  GraspRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GraspRequest& from);
  void MergeFrom(const GraspRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.DoubleVector3 graspingPoint = 1;
  inline bool has_graspingpoint() const;
  inline void clear_graspingpoint();
  static const int kGraspingPointFieldNumber = 1;
  inline const ::naothmessages::DoubleVector3& graspingpoint() const;
  inline ::naothmessages::DoubleVector3* mutable_graspingpoint();
  inline ::naothmessages::DoubleVector3* release_graspingpoint();
  
  // required uint32 graspingState = 2;
  inline bool has_graspingstate() const;
  inline void clear_graspingstate();
  static const int kGraspingStateFieldNumber = 2;
  inline ::google::protobuf::uint32 graspingstate() const;
  inline void set_graspingstate(::google::protobuf::uint32 value);
  
  // required uint32 graspDistState = 3;
  inline bool has_graspdiststate() const;
  inline void clear_graspdiststate();
  static const int kGraspDistStateFieldNumber = 3;
  inline ::google::protobuf::uint32 graspdiststate() const;
  inline void set_graspdiststate(::google::protobuf::uint32 value);
  
  // required uint32 graspStiffState = 4;
  inline bool has_graspstiffstate() const;
  inline void clear_graspstiffstate();
  static const int kGraspStiffStateFieldNumber = 4;
  inline ::google::protobuf::uint32 graspstiffstate() const;
  inline void set_graspstiffstate(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.GraspRequest)
 private:
  inline void set_has_graspingpoint();
  inline void clear_has_graspingpoint();
  inline void set_has_graspingstate();
  inline void clear_has_graspingstate();
  inline void set_has_graspdiststate();
  inline void clear_has_graspdiststate();
  inline void set_has_graspstiffstate();
  inline void clear_has_graspstiffstate();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::DoubleVector3* graspingpoint_;
  ::google::protobuf::uint32 graspingstate_;
  ::google::protobuf::uint32 graspdiststate_;
  ::google::protobuf::uint32 graspstiffstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static GraspRequest* default_instance_;
};
// -------------------------------------------------------------------

class ArmMotionRequest : public ::google::protobuf::Message {
 public:
  ArmMotionRequest();
  virtual ~ArmMotionRequest();
  
  ArmMotionRequest(const ArmMotionRequest& from);
  
  inline ArmMotionRequest& operator=(const ArmMotionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ArmMotionRequest& default_instance();
  
  void Swap(ArmMotionRequest* other);
  
  // implements Message ----------------------------------------------
  
  ArmMotionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ArmMotionRequest& from);
  void MergeFrom(const ArmMotionRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // optional .naothmessages.DoubleVector2 lShoulderPosition = 2;
  inline bool has_lshoulderposition() const;
  inline void clear_lshoulderposition();
  static const int kLShoulderPositionFieldNumber = 2;
  inline const ::naothmessages::DoubleVector2& lshoulderposition() const;
  inline ::naothmessages::DoubleVector2* mutable_lshoulderposition();
  inline ::naothmessages::DoubleVector2* release_lshoulderposition();
  
  // optional .naothmessages.DoubleVector2 lShoulderStiffness = 3;
  inline bool has_lshoulderstiffness() const;
  inline void clear_lshoulderstiffness();
  static const int kLShoulderStiffnessFieldNumber = 3;
  inline const ::naothmessages::DoubleVector2& lshoulderstiffness() const;
  inline ::naothmessages::DoubleVector2* mutable_lshoulderstiffness();
  inline ::naothmessages::DoubleVector2* release_lshoulderstiffness();
  
  // optional .naothmessages.DoubleVector2 lElbowPosition = 4;
  inline bool has_lelbowposition() const;
  inline void clear_lelbowposition();
  static const int kLElbowPositionFieldNumber = 4;
  inline const ::naothmessages::DoubleVector2& lelbowposition() const;
  inline ::naothmessages::DoubleVector2* mutable_lelbowposition();
  inline ::naothmessages::DoubleVector2* release_lelbowposition();
  
  // optional .naothmessages.DoubleVector2 lElbowStiffness = 5;
  inline bool has_lelbowstiffness() const;
  inline void clear_lelbowstiffness();
  static const int kLElbowStiffnessFieldNumber = 5;
  inline const ::naothmessages::DoubleVector2& lelbowstiffness() const;
  inline ::naothmessages::DoubleVector2* mutable_lelbowstiffness();
  inline ::naothmessages::DoubleVector2* release_lelbowstiffness();
  
  // optional .naothmessages.DoubleVector2 rShoulderPosition = 6;
  inline bool has_rshoulderposition() const;
  inline void clear_rshoulderposition();
  static const int kRShoulderPositionFieldNumber = 6;
  inline const ::naothmessages::DoubleVector2& rshoulderposition() const;
  inline ::naothmessages::DoubleVector2* mutable_rshoulderposition();
  inline ::naothmessages::DoubleVector2* release_rshoulderposition();
  
  // optional .naothmessages.DoubleVector2 rShoulderStiffness = 7;
  inline bool has_rshoulderstiffness() const;
  inline void clear_rshoulderstiffness();
  static const int kRShoulderStiffnessFieldNumber = 7;
  inline const ::naothmessages::DoubleVector2& rshoulderstiffness() const;
  inline ::naothmessages::DoubleVector2* mutable_rshoulderstiffness();
  inline ::naothmessages::DoubleVector2* release_rshoulderstiffness();
  
  // optional .naothmessages.DoubleVector2 rElbowPosition = 8;
  inline bool has_relbowposition() const;
  inline void clear_relbowposition();
  static const int kRElbowPositionFieldNumber = 8;
  inline const ::naothmessages::DoubleVector2& relbowposition() const;
  inline ::naothmessages::DoubleVector2* mutable_relbowposition();
  inline ::naothmessages::DoubleVector2* release_relbowposition();
  
  // optional .naothmessages.DoubleVector2 rElbowStiffness = 9;
  inline bool has_relbowstiffness() const;
  inline void clear_relbowstiffness();
  static const int kRElbowStiffnessFieldNumber = 9;
  inline const ::naothmessages::DoubleVector2& relbowstiffness() const;
  inline ::naothmessages::DoubleVector2* mutable_relbowstiffness();
  inline ::naothmessages::DoubleVector2* release_relbowstiffness();
  
  // @@protoc_insertion_point(class_scope:naothmessages.ArmMotionRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_lshoulderposition();
  inline void clear_has_lshoulderposition();
  inline void set_has_lshoulderstiffness();
  inline void clear_has_lshoulderstiffness();
  inline void set_has_lelbowposition();
  inline void clear_has_lelbowposition();
  inline void set_has_lelbowstiffness();
  inline void clear_has_lelbowstiffness();
  inline void set_has_rshoulderposition();
  inline void clear_has_rshoulderposition();
  inline void set_has_rshoulderstiffness();
  inline void clear_has_rshoulderstiffness();
  inline void set_has_relbowposition();
  inline void clear_has_relbowposition();
  inline void set_has_relbowstiffness();
  inline void clear_has_relbowstiffness();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::DoubleVector2* lshoulderposition_;
  ::naothmessages::DoubleVector2* lshoulderstiffness_;
  ::naothmessages::DoubleVector2* lelbowposition_;
  ::naothmessages::DoubleVector2* lelbowstiffness_;
  ::naothmessages::DoubleVector2* rshoulderposition_;
  ::naothmessages::DoubleVector2* rshoulderstiffness_;
  ::naothmessages::DoubleVector2* relbowposition_;
  ::naothmessages::DoubleVector2* relbowstiffness_;
  ::google::protobuf::uint32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static ArmMotionRequest* default_instance_;
};
// -------------------------------------------------------------------

class MotionRequest : public ::google::protobuf::Message {
 public:
  MotionRequest();
  virtual ~MotionRequest();
  
  MotionRequest(const MotionRequest& from);
  
  inline MotionRequest& operator=(const MotionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MotionRequest& default_instance();
  
  void Swap(MotionRequest* other);
  
  // implements Message ----------------------------------------------
  
  MotionRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MotionRequest& from);
  void MergeFrom(const MotionRequest& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);
  
  // required uint32 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 2;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);
  
  // required bool forced = 3;
  inline bool has_forced() const;
  inline void clear_forced();
  static const int kForcedFieldNumber = 3;
  inline bool forced() const;
  inline void set_forced(bool value);
  
  // optional .naothmessages.WalkRequest walkRequest = 4;
  inline bool has_walkrequest() const;
  inline void clear_walkrequest();
  static const int kWalkRequestFieldNumber = 4;
  inline const ::naothmessages::WalkRequest& walkrequest() const;
  inline ::naothmessages::WalkRequest* mutable_walkrequest();
  inline ::naothmessages::WalkRequest* release_walkrequest();
  
  // optional bool starndardStand = 5;
  inline bool has_starndardstand() const;
  inline void clear_starndardstand();
  static const int kStarndardStandFieldNumber = 5;
  inline bool starndardstand() const;
  inline void set_starndardstand(bool value);
  
  // optional .naothmessages.KickRequest kickRequest = 6;
  inline bool has_kickrequest() const;
  inline void clear_kickrequest();
  static const int kKickRequestFieldNumber = 6;
  inline const ::naothmessages::KickRequest& kickrequest() const;
  inline ::naothmessages::KickRequest* mutable_kickrequest();
  inline ::naothmessages::KickRequest* release_kickrequest();
  
  // optional double standHeight = 7;
  inline bool has_standheight() const;
  inline void clear_standheight();
  static const int kStandHeightFieldNumber = 7;
  inline double standheight() const;
  inline void set_standheight(double value);
  
  // optional bool calibrateFootTouchDetector = 8;
  inline bool has_calibratefoottouchdetector() const;
  inline void clear_calibratefoottouchdetector();
  static const int kCalibrateFootTouchDetectorFieldNumber = 8;
  inline bool calibratefoottouchdetector() const;
  inline void set_calibratefoottouchdetector(bool value);
  
  // optional uint32 cognitionFrameNumber = 9;
  inline bool has_cognitionframenumber() const;
  inline void clear_cognitionframenumber();
  static const int kCognitionFrameNumberFieldNumber = 9;
  inline ::google::protobuf::uint32 cognitionframenumber() const;
  inline void set_cognitionframenumber(::google::protobuf::uint32 value);
  
  // optional .naothmessages.GraspRequest graspRequest = 10;
  inline bool has_grasprequest() const;
  inline void clear_grasprequest();
  static const int kGraspRequestFieldNumber = 10;
  inline const ::naothmessages::GraspRequest& grasprequest() const;
  inline ::naothmessages::GraspRequest* mutable_grasprequest();
  inline ::naothmessages::GraspRequest* release_grasprequest();
  
  // optional .naothmessages.ArmMotionRequest armMotionRequest = 11;
  inline bool has_armmotionrequest() const;
  inline void clear_armmotionrequest();
  static const int kArmMotionRequestFieldNumber = 11;
  inline const ::naothmessages::ArmMotionRequest& armmotionrequest() const;
  inline ::naothmessages::ArmMotionRequest* mutable_armmotionrequest();
  inline ::naothmessages::ArmMotionRequest* release_armmotionrequest();
  
  // @@protoc_insertion_point(class_scope:naothmessages.MotionRequest)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_forced();
  inline void clear_has_forced();
  inline void set_has_walkrequest();
  inline void clear_has_walkrequest();
  inline void set_has_starndardstand();
  inline void clear_has_starndardstand();
  inline void set_has_kickrequest();
  inline void clear_has_kickrequest();
  inline void set_has_standheight();
  inline void clear_has_standheight();
  inline void set_has_calibratefoottouchdetector();
  inline void clear_has_calibratefoottouchdetector();
  inline void set_has_cognitionframenumber();
  inline void clear_has_cognitionframenumber();
  inline void set_has_grasprequest();
  inline void clear_has_grasprequest();
  inline void set_has_armmotionrequest();
  inline void clear_has_armmotionrequest();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 time_;
  ::naothmessages::WalkRequest* walkrequest_;
  ::naothmessages::KickRequest* kickrequest_;
  bool forced_;
  bool starndardstand_;
  bool calibratefoottouchdetector_;
  ::google::protobuf::uint32 cognitionframenumber_;
  double standheight_;
  ::naothmessages::GraspRequest* grasprequest_;
  ::naothmessages::ArmMotionRequest* armmotionrequest_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static MotionRequest* default_instance_;
};
// -------------------------------------------------------------------

class LinePercept : public ::google::protobuf::Message {
 public:
  LinePercept();
  virtual ~LinePercept();
  
  LinePercept(const LinePercept& from);
  
  inline LinePercept& operator=(const LinePercept& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LinePercept& default_instance();
  
  void Swap(LinePercept* other);
  
  // implements Message ----------------------------------------------
  
  LinePercept* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LinePercept& from);
  void MergeFrom(const LinePercept& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.FieldLineSegment lines = 1;
  inline int lines_size() const;
  inline void clear_lines();
  static const int kLinesFieldNumber = 1;
  inline const ::naothmessages::FieldLineSegment& lines(int index) const;
  inline ::naothmessages::FieldLineSegment* mutable_lines(int index);
  inline ::naothmessages::FieldLineSegment* add_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::FieldLineSegment >&
      lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::FieldLineSegment >*
      mutable_lines();
  
  // repeated .naothmessages.Intersection intersections = 2;
  inline int intersections_size() const;
  inline void clear_intersections();
  static const int kIntersectionsFieldNumber = 2;
  inline const ::naothmessages::Intersection& intersections(int index) const;
  inline ::naothmessages::Intersection* mutable_intersections(int index);
  inline ::naothmessages::Intersection* add_intersections();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Intersection >&
      intersections() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Intersection >*
      mutable_intersections();
  
  // optional .naothmessages.DoubleVector2 middleCircleCenter = 3;
  inline bool has_middlecirclecenter() const;
  inline void clear_middlecirclecenter();
  static const int kMiddleCircleCenterFieldNumber = 3;
  inline const ::naothmessages::DoubleVector2& middlecirclecenter() const;
  inline ::naothmessages::DoubleVector2* mutable_middlecirclecenter();
  inline ::naothmessages::DoubleVector2* release_middlecirclecenter();
  
  // @@protoc_insertion_point(class_scope:naothmessages.LinePercept)
 private:
  inline void set_has_middlecirclecenter();
  inline void clear_has_middlecirclecenter();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::FieldLineSegment > lines_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::Intersection > intersections_;
  ::naothmessages::DoubleVector2* middlecirclecenter_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static LinePercept* default_instance_;
};
// -------------------------------------------------------------------

class ScanLineEndPoint : public ::google::protobuf::Message {
 public:
  ScanLineEndPoint();
  virtual ~ScanLineEndPoint();
  
  ScanLineEndPoint(const ScanLineEndPoint& from);
  
  inline ScanLineEndPoint& operator=(const ScanLineEndPoint& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanLineEndPoint& default_instance();
  
  void Swap(ScanLineEndPoint* other);
  
  // implements Message ----------------------------------------------
  
  ScanLineEndPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanLineEndPoint& from);
  void MergeFrom(const ScanLineEndPoint& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.IntVector2 posInImage = 1;
  inline bool has_posinimage() const;
  inline void clear_posinimage();
  static const int kPosInImageFieldNumber = 1;
  inline const ::naothmessages::IntVector2& posinimage() const;
  inline ::naothmessages::IntVector2* mutable_posinimage();
  inline ::naothmessages::IntVector2* release_posinimage();
  
  // required .naothmessages.DoubleVector2 posOnField = 2;
  inline bool has_posonfield() const;
  inline void clear_posonfield();
  static const int kPosOnFieldFieldNumber = 2;
  inline const ::naothmessages::DoubleVector2& posonfield() const;
  inline ::naothmessages::DoubleVector2* mutable_posonfield();
  inline ::naothmessages::DoubleVector2* release_posonfield();
  
  // required .naothmessages.Color color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline naothmessages::Color color() const;
  inline void set_color(naothmessages::Color value);
  
  // required uint32 ScanLineID = 4;
  inline bool has_scanlineid() const;
  inline void clear_scanlineid();
  static const int kScanLineIDFieldNumber = 4;
  inline ::google::protobuf::uint32 scanlineid() const;
  inline void set_scanlineid(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.ScanLineEndPoint)
 private:
  inline void set_has_posinimage();
  inline void clear_has_posinimage();
  inline void set_has_posonfield();
  inline void clear_has_posonfield();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_scanlineid();
  inline void clear_has_scanlineid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::IntVector2* posinimage_;
  ::naothmessages::DoubleVector2* posonfield_;
  int color_;
  ::google::protobuf::uint32 scanlineid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static ScanLineEndPoint* default_instance_;
};
// -------------------------------------------------------------------

class Edgel : public ::google::protobuf::Message {
 public:
  Edgel();
  virtual ~Edgel();
  
  Edgel(const Edgel& from);
  
  inline Edgel& operator=(const Edgel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Edgel& default_instance();
  
  void Swap(Edgel* other);
  
  // implements Message ----------------------------------------------
  
  Edgel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Edgel& from);
  void MergeFrom(const Edgel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.IntVector2 point = 1;
  inline bool has_point() const;
  inline void clear_point();
  static const int kPointFieldNumber = 1;
  inline const ::naothmessages::IntVector2& point() const;
  inline ::naothmessages::IntVector2* mutable_point();
  inline ::naothmessages::IntVector2* release_point();
  
  // required .naothmessages.DoubleVector2 direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 2;
  inline const ::naothmessages::DoubleVector2& direction() const;
  inline ::naothmessages::DoubleVector2* mutable_direction();
  inline ::naothmessages::DoubleVector2* release_direction();
  
  // @@protoc_insertion_point(class_scope:naothmessages.Edgel)
 private:
  inline void set_has_point();
  inline void clear_has_point();
  inline void set_has_direction();
  inline void clear_has_direction();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::IntVector2* point_;
  ::naothmessages::DoubleVector2* direction_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static Edgel* default_instance_;
};
// -------------------------------------------------------------------

class EdgelPair : public ::google::protobuf::Message {
 public:
  EdgelPair();
  virtual ~EdgelPair();
  
  EdgelPair(const EdgelPair& from);
  
  inline EdgelPair& operator=(const EdgelPair& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgelPair& default_instance();
  
  void Swap(EdgelPair* other);
  
  // implements Message ----------------------------------------------
  
  EdgelPair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EdgelPair& from);
  void MergeFrom(const EdgelPair& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 begin = 1;
  inline bool has_begin() const;
  inline void clear_begin();
  static const int kBeginFieldNumber = 1;
  inline ::google::protobuf::int32 begin() const;
  inline void set_begin(::google::protobuf::int32 value);
  
  // required int32 end = 2;
  inline bool has_end() const;
  inline void clear_end();
  static const int kEndFieldNumber = 2;
  inline ::google::protobuf::int32 end() const;
  inline void set_end(::google::protobuf::int32 value);
  
  // required int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.EdgelPair)
 private:
  inline void set_has_begin();
  inline void clear_has_begin();
  inline void set_has_end();
  inline void clear_has_end();
  inline void set_has_id();
  inline void clear_has_id();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::int32 begin_;
  ::google::protobuf::int32 end_;
  ::google::protobuf::int32 id_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static EdgelPair* default_instance_;
};
// -------------------------------------------------------------------

class ScanLineEdgelPercept : public ::google::protobuf::Message {
 public:
  ScanLineEdgelPercept();
  virtual ~ScanLineEdgelPercept();
  
  ScanLineEdgelPercept(const ScanLineEdgelPercept& from);
  
  inline ScanLineEdgelPercept& operator=(const ScanLineEdgelPercept& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanLineEdgelPercept& default_instance();
  
  void Swap(ScanLineEdgelPercept* other);
  
  // implements Message ----------------------------------------------
  
  ScanLineEdgelPercept* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ScanLineEdgelPercept& from);
  void MergeFrom(const ScanLineEdgelPercept& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.Edgel edgels = 1;
  inline int edgels_size() const;
  inline void clear_edgels();
  static const int kEdgelsFieldNumber = 1;
  inline const ::naothmessages::Edgel& edgels(int index) const;
  inline ::naothmessages::Edgel* mutable_edgels(int index);
  inline ::naothmessages::Edgel* add_edgels();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >&
      edgels() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >*
      mutable_edgels();
  
  // repeated .naothmessages.EdgelPair pairs = 3;
  inline int pairs_size() const;
  inline void clear_pairs();
  static const int kPairsFieldNumber = 3;
  inline const ::naothmessages::EdgelPair& pairs(int index) const;
  inline ::naothmessages::EdgelPair* mutable_pairs(int index);
  inline ::naothmessages::EdgelPair* add_pairs();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::EdgelPair >&
      pairs() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::EdgelPair >*
      mutable_pairs();
  
  // repeated .naothmessages.ScanLineEndPoint endPoints = 2;
  inline int endpoints_size() const;
  inline void clear_endpoints();
  static const int kEndPointsFieldNumber = 2;
  inline const ::naothmessages::ScanLineEndPoint& endpoints(int index) const;
  inline ::naothmessages::ScanLineEndPoint* mutable_endpoints(int index);
  inline ::naothmessages::ScanLineEndPoint* add_endpoints();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::ScanLineEndPoint >&
      endpoints() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::ScanLineEndPoint >*
      mutable_endpoints();
  
  // @@protoc_insertion_point(class_scope:naothmessages.ScanLineEdgelPercept)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel > edgels_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::EdgelPair > pairs_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::ScanLineEndPoint > endpoints_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static ScanLineEdgelPercept* default_instance_;
};
// -------------------------------------------------------------------

class StepControlStatus : public ::google::protobuf::Message {
 public:
  StepControlStatus();
  virtual ~StepControlStatus();
  
  StepControlStatus(const StepControlStatus& from);
  
  inline StepControlStatus& operator=(const StepControlStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const StepControlStatus& default_instance();
  
  void Swap(StepControlStatus* other);
  
  // implements Message ----------------------------------------------
  
  StepControlStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StepControlStatus& from);
  void MergeFrom(const StepControlStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 stepID = 1;
  inline bool has_stepid() const;
  inline void clear_stepid();
  static const int kStepIDFieldNumber = 1;
  inline ::google::protobuf::uint32 stepid() const;
  inline void set_stepid(::google::protobuf::uint32 value);
  
  // required uint32 moveableFoot = 2;
  inline bool has_moveablefoot() const;
  inline void clear_moveablefoot();
  static const int kMoveableFootFieldNumber = 2;
  inline ::google::protobuf::uint32 moveablefoot() const;
  inline void set_moveablefoot(::google::protobuf::uint32 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.StepControlStatus)
 private:
  inline void set_has_stepid();
  inline void clear_has_stepid();
  inline void set_has_moveablefoot();
  inline void clear_has_moveablefoot();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 stepid_;
  ::google::protobuf::uint32 moveablefoot_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static StepControlStatus* default_instance_;
};
// -------------------------------------------------------------------

class MotionStatus : public ::google::protobuf::Message {
 public:
  MotionStatus();
  virtual ~MotionStatus();
  
  MotionStatus(const MotionStatus& from);
  
  inline MotionStatus& operator=(const MotionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MotionStatus& default_instance();
  
  void Swap(MotionStatus* other);
  
  // implements Message ----------------------------------------------
  
  MotionStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MotionStatus& from);
  void MergeFrom(const MotionStatus& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required uint32 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);
  
  // required uint32 lastMotion = 2;
  inline bool has_lastmotion() const;
  inline void clear_lastmotion();
  static const int kLastMotionFieldNumber = 2;
  inline ::google::protobuf::uint32 lastmotion() const;
  inline void set_lastmotion(::google::protobuf::uint32 value);
  
  // required uint32 currentMotion = 3;
  inline bool has_currentmotion() const;
  inline void clear_currentmotion();
  static const int kCurrentMotionFieldNumber = 3;
  inline ::google::protobuf::uint32 currentmotion() const;
  inline void set_currentmotion(::google::protobuf::uint32 value);
  
  // required uint32 headMotion = 4;
  inline bool has_headmotion() const;
  inline void clear_headmotion();
  static const int kHeadMotionFieldNumber = 4;
  inline ::google::protobuf::uint32 headmotion() const;
  inline void set_headmotion(::google::protobuf::uint32 value);
  
  // required uint32 currentMotionState = 5;
  inline bool has_currentmotionstate() const;
  inline void clear_currentmotionstate();
  static const int kCurrentMotionStateFieldNumber = 5;
  inline ::google::protobuf::uint32 currentmotionstate() const;
  inline void set_currentmotionstate(::google::protobuf::uint32 value);
  
  // required .naothmessages.Pose2D plannedMotionLeftFoot = 6;
  inline bool has_plannedmotionleftfoot() const;
  inline void clear_plannedmotionleftfoot();
  static const int kPlannedMotionLeftFootFieldNumber = 6;
  inline const ::naothmessages::Pose2D& plannedmotionleftfoot() const;
  inline ::naothmessages::Pose2D* mutable_plannedmotionleftfoot();
  inline ::naothmessages::Pose2D* release_plannedmotionleftfoot();
  
  // required .naothmessages.Pose2D plannedMotionRightFoot = 7;
  inline bool has_plannedmotionrightfoot() const;
  inline void clear_plannedmotionrightfoot();
  static const int kPlannedMotionRightFootFieldNumber = 7;
  inline const ::naothmessages::Pose2D& plannedmotionrightfoot() const;
  inline ::naothmessages::Pose2D* mutable_plannedmotionrightfoot();
  inline ::naothmessages::Pose2D* release_plannedmotionrightfoot();
  
  // required .naothmessages.Pose2D plannedMotionHip = 8;
  inline bool has_plannedmotionhip() const;
  inline void clear_plannedmotionhip();
  static const int kPlannedMotionHipFieldNumber = 8;
  inline const ::naothmessages::Pose2D& plannedmotionhip() const;
  inline ::naothmessages::Pose2D* mutable_plannedmotionhip();
  inline ::naothmessages::Pose2D* release_plannedmotionhip();
  
  // optional .naothmessages.StepControlStatus stepControlStatus = 9;
  inline bool has_stepcontrolstatus() const;
  inline void clear_stepcontrolstatus();
  static const int kStepControlStatusFieldNumber = 9;
  inline const ::naothmessages::StepControlStatus& stepcontrolstatus() const;
  inline ::naothmessages::StepControlStatus* mutable_stepcontrolstatus();
  inline ::naothmessages::StepControlStatus* release_stepcontrolstatus();
  
  // @@protoc_insertion_point(class_scope:naothmessages.MotionStatus)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_lastmotion();
  inline void clear_has_lastmotion();
  inline void set_has_currentmotion();
  inline void clear_has_currentmotion();
  inline void set_has_headmotion();
  inline void clear_has_headmotion();
  inline void set_has_currentmotionstate();
  inline void clear_has_currentmotionstate();
  inline void set_has_plannedmotionleftfoot();
  inline void clear_has_plannedmotionleftfoot();
  inline void set_has_plannedmotionrightfoot();
  inline void clear_has_plannedmotionrightfoot();
  inline void set_has_plannedmotionhip();
  inline void clear_has_plannedmotionhip();
  inline void set_has_stepcontrolstatus();
  inline void clear_has_stepcontrolstatus();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 lastmotion_;
  ::google::protobuf::uint32 currentmotion_;
  ::google::protobuf::uint32 headmotion_;
  ::naothmessages::Pose2D* plannedmotionleftfoot_;
  ::naothmessages::Pose2D* plannedmotionrightfoot_;
  ::naothmessages::Pose2D* plannedmotionhip_;
  ::naothmessages::StepControlStatus* stepcontrolstatus_;
  ::google::protobuf::uint32 currentmotionstate_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static MotionStatus* default_instance_;
};
// -------------------------------------------------------------------

class OdometryData : public ::google::protobuf::Message {
 public:
  OdometryData();
  virtual ~OdometryData();
  
  OdometryData(const OdometryData& from);
  
  inline OdometryData& operator=(const OdometryData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const OdometryData& default_instance();
  
  void Swap(OdometryData* other);
  
  // implements Message ----------------------------------------------
  
  OdometryData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OdometryData& from);
  void MergeFrom(const OdometryData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .naothmessages.Pose2D pose = 1;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 1;
  inline const ::naothmessages::Pose2D& pose() const;
  inline ::naothmessages::Pose2D* mutable_pose();
  inline ::naothmessages::Pose2D* release_pose();
  
  // @@protoc_insertion_point(class_scope:naothmessages.OdometryData)
 private:
  inline void set_has_pose();
  inline void clear_has_pose();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::Pose2D* pose_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static OdometryData* default_instance_;
};
// -------------------------------------------------------------------

class CalibrationData : public ::google::protobuf::Message {
 public:
  CalibrationData();
  virtual ~CalibrationData();
  
  CalibrationData(const CalibrationData& from);
  
  inline CalibrationData& operator=(const CalibrationData& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationData& default_instance();
  
  void Swap(CalibrationData* other);
  
  // implements Message ----------------------------------------------
  
  CalibrationData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CalibrationData& from);
  void MergeFrom(const CalibrationData& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .naothmessages.DoubleVector2 inertialSensorOffset = 1;
  inline bool has_inertialsensoroffset() const;
  inline void clear_inertialsensoroffset();
  static const int kInertialSensorOffsetFieldNumber = 1;
  inline const ::naothmessages::DoubleVector2& inertialsensoroffset() const;
  inline ::naothmessages::DoubleVector2* mutable_inertialsensoroffset();
  inline ::naothmessages::DoubleVector2* release_inertialsensoroffset();
  
  // optional .naothmessages.DoubleVector2 gyroSensorOffset = 2;
  inline bool has_gyrosensoroffset() const;
  inline void clear_gyrosensoroffset();
  static const int kGyroSensorOffsetFieldNumber = 2;
  inline const ::naothmessages::DoubleVector2& gyrosensoroffset() const;
  inline ::naothmessages::DoubleVector2* mutable_gyrosensoroffset();
  inline ::naothmessages::DoubleVector2* release_gyrosensoroffset();
  
  // optional .naothmessages.DoubleVector3 accSensorOffset = 3;
  inline bool has_accsensoroffset() const;
  inline void clear_accsensoroffset();
  static const int kAccSensorOffsetFieldNumber = 3;
  inline const ::naothmessages::DoubleVector3& accsensoroffset() const;
  inline ::naothmessages::DoubleVector3* mutable_accsensoroffset();
  inline ::naothmessages::DoubleVector3* release_accsensoroffset();
  
  // required bool calibrated = 4;
  inline bool has_calibrated() const;
  inline void clear_calibrated();
  static const int kCalibratedFieldNumber = 4;
  inline bool calibrated() const;
  inline void set_calibrated(bool value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.CalibrationData)
 private:
  inline void set_has_inertialsensoroffset();
  inline void clear_has_inertialsensoroffset();
  inline void set_has_gyrosensoroffset();
  inline void clear_has_gyrosensoroffset();
  inline void set_has_accsensoroffset();
  inline void clear_has_accsensoroffset();
  inline void set_has_calibrated();
  inline void clear_has_calibrated();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::DoubleVector2* inertialsensoroffset_;
  ::naothmessages::DoubleVector2* gyrosensoroffset_;
  ::naothmessages::DoubleVector3* accsensoroffset_;
  bool calibrated_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static CalibrationData* default_instance_;
};
// -------------------------------------------------------------------

class InertialModel : public ::google::protobuf::Message {
 public:
  InertialModel();
  virtual ~InertialModel();
  
  InertialModel(const InertialModel& from);
  
  inline InertialModel& operator=(const InertialModel& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const InertialModel& default_instance();
  
  void Swap(InertialModel* other);
  
  // implements Message ----------------------------------------------
  
  InertialModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InertialModel& from);
  void MergeFrom(const InertialModel& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .naothmessages.DoubleVector2 orientation = 1;
  inline bool has_orientation() const;
  inline void clear_orientation();
  static const int kOrientationFieldNumber = 1;
  inline const ::naothmessages::DoubleVector2& orientation() const;
  inline ::naothmessages::DoubleVector2* mutable_orientation();
  inline ::naothmessages::DoubleVector2* release_orientation();
  
  // @@protoc_insertion_point(class_scope:naothmessages.InertialModel)
 private:
  inline void set_has_orientation();
  inline void clear_has_orientation();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::DoubleVector2* orientation_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static InertialModel* default_instance_;
};
// -------------------------------------------------------------------

class TeamMessageCollection : public ::google::protobuf::Message {
 public:
  TeamMessageCollection();
  virtual ~TeamMessageCollection();
  
  TeamMessageCollection(const TeamMessageCollection& from);
  
  inline TeamMessageCollection& operator=(const TeamMessageCollection& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamMessageCollection& default_instance();
  
  void Swap(TeamMessageCollection* other);
  
  // implements Message ----------------------------------------------
  
  TeamMessageCollection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamMessageCollection& from);
  void MergeFrom(const TeamMessageCollection& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.TeamMessage data = 1;
  inline int data_size() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::naothmessages::TeamMessage& data(int index) const;
  inline ::naothmessages::TeamMessage* mutable_data(int index);
  inline ::naothmessages::TeamMessage* add_data();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::TeamMessage >&
      data() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::TeamMessage >*
      mutable_data();
  
  // @@protoc_insertion_point(class_scope:naothmessages.TeamMessageCollection)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::TeamMessage > data_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static TeamMessageCollection* default_instance_;
};
// -------------------------------------------------------------------

class TeamMessage : public ::google::protobuf::Message {
 public:
  TeamMessage();
  virtual ~TeamMessage();
  
  TeamMessage(const TeamMessage& from);
  
  inline TeamMessage& operator=(const TeamMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const TeamMessage& default_instance();
  
  void Swap(TeamMessage* other);
  
  // implements Message ----------------------------------------------
  
  TeamMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TeamMessage& from);
  void MergeFrom(const TeamMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 playerNum = 1 [default = 0];
  inline bool has_playernum() const;
  inline void clear_playernum();
  static const int kPlayerNumFieldNumber = 1;
  inline ::google::protobuf::uint32 playernum() const;
  inline void set_playernum(::google::protobuf::uint32 value);
  
  // optional .naothmessages.TeamColor teamColor = 11 [default = blueTeam];
  inline bool has_teamcolor() const;
  inline void clear_teamcolor();
  static const int kTeamColorFieldNumber = 11;
  inline naothmessages::TeamColor teamcolor() const;
  inline void set_teamcolor(naothmessages::TeamColor value);
  
  // optional .naothmessages.Pose2D pose = 3;
  inline bool has_pose() const;
  inline void clear_pose();
  static const int kPoseFieldNumber = 3;
  inline const ::naothmessages::Pose2D& pose() const;
  inline ::naothmessages::Pose2D* mutable_pose();
  inline ::naothmessages::Pose2D* release_pose();
  
  // optional int32 ballAge = 4 [default = -1];
  inline bool has_ballage() const;
  inline void clear_ballage();
  static const int kBallAgeFieldNumber = 4;
  inline ::google::protobuf::int32 ballage() const;
  inline void set_ballage(::google::protobuf::int32 value);
  
  // optional .naothmessages.DoubleVector2 ballPosition = 5;
  inline bool has_ballposition() const;
  inline void clear_ballposition();
  static const int kBallPositionFieldNumber = 5;
  inline const ::naothmessages::DoubleVector2& ballposition() const;
  inline ::naothmessages::DoubleVector2* mutable_ballposition();
  inline ::naothmessages::DoubleVector2* release_ballposition();
  
  // optional .naothmessages.DoubleVector2 ballVelocity = 6;
  inline bool has_ballvelocity() const;
  inline void clear_ballvelocity();
  static const int kBallVelocityFieldNumber = 6;
  inline const ::naothmessages::DoubleVector2& ballvelocity() const;
  inline ::naothmessages::DoubleVector2* mutable_ballvelocity();
  inline ::naothmessages::DoubleVector2* release_ballvelocity();
  
  // optional bool fallen = 10 [default = false];
  inline bool has_fallen() const;
  inline void clear_fallen();
  static const int kFallenFieldNumber = 10;
  inline bool fallen() const;
  inline void set_fallen(bool value);
  
  // optional .naothmessages.BUUserTeamMessage user = 8;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 8;
  inline const ::naothmessages::BUUserTeamMessage& user() const;
  inline ::naothmessages::BUUserTeamMessage* mutable_user();
  inline ::naothmessages::BUUserTeamMessage* release_user();
  
  // optional .naothmessages.FrameInfo frameInfo = 9;
  inline bool has_frameinfo() const;
  inline void clear_frameinfo();
  static const int kFrameInfoFieldNumber = 9;
  inline const ::naothmessages::FrameInfo& frameinfo() const;
  inline ::naothmessages::FrameInfo* mutable_frameinfo();
  inline ::naothmessages::FrameInfo* release_frameinfo();
  
  // @@protoc_insertion_point(class_scope:naothmessages.TeamMessage)
 private:
  inline void set_has_playernum();
  inline void clear_has_playernum();
  inline void set_has_teamcolor();
  inline void clear_has_teamcolor();
  inline void set_has_pose();
  inline void clear_has_pose();
  inline void set_has_ballage();
  inline void clear_has_ballage();
  inline void set_has_ballposition();
  inline void clear_has_ballposition();
  inline void set_has_ballvelocity();
  inline void clear_has_ballvelocity();
  inline void set_has_fallen();
  inline void clear_has_fallen();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_frameinfo();
  inline void clear_has_frameinfo();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::uint32 playernum_;
  int teamcolor_;
  ::naothmessages::Pose2D* pose_;
  ::naothmessages::DoubleVector2* ballposition_;
  ::google::protobuf::int32 ballage_;
  bool fallen_;
  ::naothmessages::DoubleVector2* ballvelocity_;
  ::naothmessages::BUUserTeamMessage* user_;
  ::naothmessages::FrameInfo* frameinfo_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static TeamMessage* default_instance_;
};
// -------------------------------------------------------------------

class BUUserTeamMessage : public ::google::protobuf::Message {
 public:
  BUUserTeamMessage();
  virtual ~BUUserTeamMessage();
  
  BUUserTeamMessage(const BUUserTeamMessage& from);
  
  inline BUUserTeamMessage& operator=(const BUUserTeamMessage& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const BUUserTeamMessage& default_instance();
  
  void Swap(BUUserTeamMessage* other);
  
  // implements Message ----------------------------------------------
  
  BUUserTeamMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const BUUserTeamMessage& from);
  void MergeFrom(const BUUserTeamMessage& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string bodyID = 1 [default = "unknown"];
  inline bool has_bodyid() const;
  inline void clear_bodyid();
  static const int kBodyIDFieldNumber = 1;
  inline const ::std::string& bodyid() const;
  inline void set_bodyid(const ::std::string& value);
  inline void set_bodyid(const char* value);
  inline void set_bodyid(const char* value, size_t size);
  inline ::std::string* mutable_bodyid();
  inline ::std::string* release_bodyid();
  
  // optional uint32 timeToBall = 2;
  inline bool has_timetoball() const;
  inline void clear_timetoball();
  static const int kTimeToBallFieldNumber = 2;
  inline ::google::protobuf::uint32 timetoball() const;
  inline void set_timetoball(::google::protobuf::uint32 value);
  
  // optional bool wasStriker = 3 [default = false];
  inline bool has_wasstriker() const;
  inline void clear_wasstriker();
  static const int kWasStrikerFieldNumber = 3;
  inline bool wasstriker() const;
  inline void set_wasstriker(bool value);
  
  // optional bool isPenalized = 4 [default = false];
  inline bool has_ispenalized() const;
  inline void clear_ispenalized();
  static const int kIsPenalizedFieldNumber = 4;
  inline bool ispenalized() const;
  inline void set_ispenalized(bool value);
  
  // repeated .naothmessages.Opponent opponents = 5;
  inline int opponents_size() const;
  inline void clear_opponents();
  static const int kOpponentsFieldNumber = 5;
  inline const ::naothmessages::Opponent& opponents(int index) const;
  inline ::naothmessages::Opponent* mutable_opponents(int index);
  inline ::naothmessages::Opponent* add_opponents();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Opponent >&
      opponents() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Opponent >*
      mutable_opponents();
  
  // optional uint32 teamNumber = 6 [default = 0];
  inline bool has_teamnumber() const;
  inline void clear_teamnumber();
  static const int kTeamNumberFieldNumber = 6;
  inline ::google::protobuf::uint32 teamnumber() const;
  inline void set_teamnumber(::google::protobuf::uint32 value);
  
  // optional float batteryCharge = 7 [default = 1];
  inline bool has_batterycharge() const;
  inline void clear_batterycharge();
  static const int kBatteryChargeFieldNumber = 7;
  inline float batterycharge() const;
  inline void set_batterycharge(float value);
  
  // optional float temperature = 8 [default = 0];
  inline bool has_temperature() const;
  inline void clear_temperature();
  static const int kTemperatureFieldNumber = 8;
  inline float temperature() const;
  inline void set_temperature(float value);
  
  // optional uint64 timestamp = 9 [default = 0];
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 9;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);
  
  // @@protoc_insertion_point(class_scope:naothmessages.BUUserTeamMessage)
 private:
  inline void set_has_bodyid();
  inline void clear_has_bodyid();
  inline void set_has_timetoball();
  inline void clear_has_timetoball();
  inline void set_has_wasstriker();
  inline void clear_has_wasstriker();
  inline void set_has_ispenalized();
  inline void clear_has_ispenalized();
  inline void set_has_teamnumber();
  inline void clear_has_teamnumber();
  inline void set_has_batterycharge();
  inline void clear_has_batterycharge();
  inline void set_has_temperature();
  inline void clear_has_temperature();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* bodyid_;
  static const ::std::string _default_bodyid_;
  ::google::protobuf::uint32 timetoball_;
  bool wasstriker_;
  bool ispenalized_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::Opponent > opponents_;
  ::google::protobuf::uint32 teamnumber_;
  float batterycharge_;
  ::google::protobuf::uint64 timestamp_;
  float temperature_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static BUUserTeamMessage* default_instance_;
};
// -------------------------------------------------------------------

class Opponent : public ::google::protobuf::Message {
 public:
  Opponent();
  virtual ~Opponent();
  
  Opponent(const Opponent& from);
  
  inline Opponent& operator=(const Opponent& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Opponent& default_instance();
  
  void Swap(Opponent* other);
  
  // implements Message ----------------------------------------------
  
  Opponent* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Opponent& from);
  void MergeFrom(const Opponent& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 playerNum = 1 [default = 0];
  inline bool has_playernum() const;
  inline void clear_playernum();
  static const int kPlayerNumFieldNumber = 1;
  inline ::google::protobuf::int32 playernum() const;
  inline void set_playernum(::google::protobuf::int32 value);
  
  // optional .naothmessages.Pose2D poseOnField = 2;
  inline bool has_poseonfield() const;
  inline void clear_poseonfield();
  static const int kPoseOnFieldFieldNumber = 2;
  inline const ::naothmessages::Pose2D& poseonfield() const;
  inline ::naothmessages::Pose2D* mutable_poseonfield();
  inline ::naothmessages::Pose2D* release_poseonfield();
  
  // @@protoc_insertion_point(class_scope:naothmessages.Opponent)
 private:
  inline void set_has_playernum();
  inline void clear_has_playernum();
  inline void set_has_poseonfield();
  inline void clear_has_poseonfield();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::naothmessages::Pose2D* poseonfield_;
  ::google::protobuf::int32 playernum_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static Opponent* default_instance_;
};
// -------------------------------------------------------------------

class CameraMatrixCalibration : public ::google::protobuf::Message {
 public:
  CameraMatrixCalibration();
  virtual ~CameraMatrixCalibration();
  
  CameraMatrixCalibration(const CameraMatrixCalibration& from);
  
  inline CameraMatrixCalibration& operator=(const CameraMatrixCalibration& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraMatrixCalibration& default_instance();
  
  void Swap(CameraMatrixCalibration* other);
  
  // implements Message ----------------------------------------------
  
  CameraMatrixCalibration* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraMatrixCalibration& from);
  void MergeFrom(const CameraMatrixCalibration& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .naothmessages.DoubleVector2 correctionOffset = 1;
  inline int correctionoffset_size() const;
  inline void clear_correctionoffset();
  static const int kCorrectionOffsetFieldNumber = 1;
  inline const ::naothmessages::DoubleVector2& correctionoffset(int index) const;
  inline ::naothmessages::DoubleVector2* mutable_correctionoffset(int index);
  inline ::naothmessages::DoubleVector2* add_correctionoffset();
  inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
      correctionoffset() const;
  inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
      mutable_correctionoffset();
  
  // @@protoc_insertion_point(class_scope:naothmessages.CameraMatrixCalibration)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 > correctionoffset_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_Representations_2eproto();
  friend void protobuf_AssignDesc_Representations_2eproto();
  friend void protobuf_ShutdownFile_Representations_2eproto();
  
  void InitAsDefaultInstance();
  static CameraMatrixCalibration* default_instance_;
};
// ===================================================================


// ===================================================================

// CameraMatrix

// required .naothmessages.Pose3D pose = 1;
inline bool CameraMatrix::has_pose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraMatrix::set_has_pose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraMatrix::clear_has_pose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraMatrix::clear_pose() {
  if (pose_ != NULL) pose_->::naothmessages::Pose3D::Clear();
  clear_has_pose();
}
inline const ::naothmessages::Pose3D& CameraMatrix::pose() const {
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::naothmessages::Pose3D* CameraMatrix::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::naothmessages::Pose3D;
  return pose_;
}
inline ::naothmessages::Pose3D* CameraMatrix::release_pose() {
  clear_has_pose();
  ::naothmessages::Pose3D* temp = pose_;
  pose_ = NULL;
  return temp;
}

// optional .naothmessages.CameraID cameraID = 2 [default = bottom];
inline bool CameraMatrix::has_cameraid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraMatrix::set_has_cameraid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraMatrix::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraMatrix::clear_cameraid() {
  cameraid_ = 1;
  clear_has_cameraid();
}
inline naothmessages::CameraID CameraMatrix::cameraid() const {
  return static_cast< naothmessages::CameraID >(cameraid_);
}
inline void CameraMatrix::set_cameraid(naothmessages::CameraID value) {
  GOOGLE_DCHECK(naothmessages::CameraID_IsValid(value));
  set_has_cameraid();
  cameraid_ = value;
}

// optional bool valid = 3;
inline bool CameraMatrix::has_valid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraMatrix::set_has_valid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraMatrix::clear_has_valid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraMatrix::clear_valid() {
  valid_ = false;
  clear_has_valid();
}
inline bool CameraMatrix::valid() const {
  return valid_;
}
inline void CameraMatrix::set_valid(bool value) {
  set_has_valid();
  valid_ = value;
}

// optional uint32 timestamp = 4;
inline bool CameraMatrix::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraMatrix::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraMatrix::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraMatrix::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CameraMatrix::timestamp() const {
  return timestamp_;
}
inline void CameraMatrix::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// BallPercept

// optional bool ballWasSeen = 1;
inline bool BallPercept::has_ballwasseen() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BallPercept::set_has_ballwasseen() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BallPercept::clear_has_ballwasseen() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BallPercept::clear_ballwasseen() {
  ballwasseen_ = false;
  clear_has_ballwasseen();
}
inline bool BallPercept::ballwasseen() const {
  return ballwasseen_;
}
inline void BallPercept::set_ballwasseen(bool value) {
  set_has_ballwasseen();
  ballwasseen_ = value;
}

// optional .naothmessages.DoubleVector2 centerInImage = 2;
inline bool BallPercept::has_centerinimage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BallPercept::set_has_centerinimage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BallPercept::clear_has_centerinimage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BallPercept::clear_centerinimage() {
  if (centerinimage_ != NULL) centerinimage_->::naothmessages::DoubleVector2::Clear();
  clear_has_centerinimage();
}
inline const ::naothmessages::DoubleVector2& BallPercept::centerinimage() const {
  return centerinimage_ != NULL ? *centerinimage_ : *default_instance_->centerinimage_;
}
inline ::naothmessages::DoubleVector2* BallPercept::mutable_centerinimage() {
  set_has_centerinimage();
  if (centerinimage_ == NULL) centerinimage_ = new ::naothmessages::DoubleVector2;
  return centerinimage_;
}
inline ::naothmessages::DoubleVector2* BallPercept::release_centerinimage() {
  clear_has_centerinimage();
  ::naothmessages::DoubleVector2* temp = centerinimage_;
  centerinimage_ = NULL;
  return temp;
}

// optional double radiusInImage = 3;
inline bool BallPercept::has_radiusinimage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BallPercept::set_has_radiusinimage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BallPercept::clear_has_radiusinimage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BallPercept::clear_radiusinimage() {
  radiusinimage_ = 0;
  clear_has_radiusinimage();
}
inline double BallPercept::radiusinimage() const {
  return radiusinimage_;
}
inline void BallPercept::set_radiusinimage(double value) {
  set_has_radiusinimage();
  radiusinimage_ = value;
}

// optional .naothmessages.Color ballColor = 4;
inline bool BallPercept::has_ballcolor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BallPercept::set_has_ballcolor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BallPercept::clear_has_ballcolor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BallPercept::clear_ballcolor() {
  ballcolor_ = 0;
  clear_has_ballcolor();
}
inline naothmessages::Color BallPercept::ballcolor() const {
  return static_cast< naothmessages::Color >(ballcolor_);
}
inline void BallPercept::set_ballcolor(naothmessages::Color value) {
  GOOGLE_DCHECK(naothmessages::Color_IsValid(value));
  set_has_ballcolor();
  ballcolor_ = value;
}

// optional .naothmessages.DoubleVector2 bearingBasedOffsetOnField = 5;
inline bool BallPercept::has_bearingbasedoffsetonfield() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BallPercept::set_has_bearingbasedoffsetonfield() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BallPercept::clear_has_bearingbasedoffsetonfield() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BallPercept::clear_bearingbasedoffsetonfield() {
  if (bearingbasedoffsetonfield_ != NULL) bearingbasedoffsetonfield_->::naothmessages::DoubleVector2::Clear();
  clear_has_bearingbasedoffsetonfield();
}
inline const ::naothmessages::DoubleVector2& BallPercept::bearingbasedoffsetonfield() const {
  return bearingbasedoffsetonfield_ != NULL ? *bearingbasedoffsetonfield_ : *default_instance_->bearingbasedoffsetonfield_;
}
inline ::naothmessages::DoubleVector2* BallPercept::mutable_bearingbasedoffsetonfield() {
  set_has_bearingbasedoffsetonfield();
  if (bearingbasedoffsetonfield_ == NULL) bearingbasedoffsetonfield_ = new ::naothmessages::DoubleVector2;
  return bearingbasedoffsetonfield_;
}
inline ::naothmessages::DoubleVector2* BallPercept::release_bearingbasedoffsetonfield() {
  clear_has_bearingbasedoffsetonfield();
  ::naothmessages::DoubleVector2* temp = bearingbasedoffsetonfield_;
  bearingbasedoffsetonfield_ = NULL;
  return temp;
}

// optional .naothmessages.FrameInfo frameInfoWhenBallWasSeen = 6;
inline bool BallPercept::has_frameinfowhenballwasseen() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BallPercept::set_has_frameinfowhenballwasseen() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BallPercept::clear_has_frameinfowhenballwasseen() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BallPercept::clear_frameinfowhenballwasseen() {
  if (frameinfowhenballwasseen_ != NULL) frameinfowhenballwasseen_->::naothmessages::FrameInfo::Clear();
  clear_has_frameinfowhenballwasseen();
}
inline const ::naothmessages::FrameInfo& BallPercept::frameinfowhenballwasseen() const {
  return frameinfowhenballwasseen_ != NULL ? *frameinfowhenballwasseen_ : *default_instance_->frameinfowhenballwasseen_;
}
inline ::naothmessages::FrameInfo* BallPercept::mutable_frameinfowhenballwasseen() {
  set_has_frameinfowhenballwasseen();
  if (frameinfowhenballwasseen_ == NULL) frameinfowhenballwasseen_ = new ::naothmessages::FrameInfo;
  return frameinfowhenballwasseen_;
}
inline ::naothmessages::FrameInfo* BallPercept::release_frameinfowhenballwasseen() {
  clear_has_frameinfowhenballwasseen();
  ::naothmessages::FrameInfo* temp = frameinfowhenballwasseen_;
  frameinfowhenballwasseen_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// GoalPercept

// optional double angleToSeenGoal = 1;
inline bool GoalPercept::has_angletoseengoal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoalPercept::set_has_angletoseengoal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoalPercept::clear_has_angletoseengoal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoalPercept::clear_angletoseengoal() {
  angletoseengoal_ = 0;
  clear_has_angletoseengoal();
}
inline double GoalPercept::angletoseengoal() const {
  return angletoseengoal_;
}
inline void GoalPercept::set_angletoseengoal(double value) {
  set_has_angletoseengoal();
  angletoseengoal_ = value;
}

// optional .naothmessages.DoubleVector3 goalCentroid = 2;
inline bool GoalPercept::has_goalcentroid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoalPercept::set_has_goalcentroid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoalPercept::clear_has_goalcentroid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoalPercept::clear_goalcentroid() {
  if (goalcentroid_ != NULL) goalcentroid_->::naothmessages::DoubleVector3::Clear();
  clear_has_goalcentroid();
}
inline const ::naothmessages::DoubleVector3& GoalPercept::goalcentroid() const {
  return goalcentroid_ != NULL ? *goalcentroid_ : *default_instance_->goalcentroid_;
}
inline ::naothmessages::DoubleVector3* GoalPercept::mutable_goalcentroid() {
  set_has_goalcentroid();
  if (goalcentroid_ == NULL) goalcentroid_ = new ::naothmessages::DoubleVector3;
  return goalcentroid_;
}
inline ::naothmessages::DoubleVector3* GoalPercept::release_goalcentroid() {
  clear_has_goalcentroid();
  ::naothmessages::DoubleVector3* temp = goalcentroid_;
  goalcentroid_ = NULL;
  return temp;
}

// optional int32 numberOfSeenPosts = 3;
inline bool GoalPercept::has_numberofseenposts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoalPercept::set_has_numberofseenposts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoalPercept::clear_has_numberofseenposts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoalPercept::clear_numberofseenposts() {
  numberofseenposts_ = 0;
  clear_has_numberofseenposts();
}
inline ::google::protobuf::int32 GoalPercept::numberofseenposts() const {
  return numberofseenposts_;
}
inline void GoalPercept::set_numberofseenposts(::google::protobuf::int32 value) {
  set_has_numberofseenposts();
  numberofseenposts_ = value;
}

// repeated .naothmessages.GoalPost post = 4;
inline int GoalPercept::post_size() const {
  return post_.size();
}
inline void GoalPercept::clear_post() {
  post_.Clear();
}
inline const ::naothmessages::GoalPost& GoalPercept::post(int index) const {
  return post_.Get(index);
}
inline ::naothmessages::GoalPost* GoalPercept::mutable_post(int index) {
  return post_.Mutable(index);
}
inline ::naothmessages::GoalPost* GoalPercept::add_post() {
  return post_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::GoalPost >&
GoalPercept::post() const {
  return post_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::GoalPost >*
GoalPercept::mutable_post() {
  return &post_;
}

// -------------------------------------------------------------------

// HeadMotionRequest

// required uint32 id = 1;
inline bool HeadMotionRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeadMotionRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeadMotionRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeadMotionRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 HeadMotionRequest::id() const {
  return id_;
}
inline void HeadMotionRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 cameraID = 2;
inline bool HeadMotionRequest::has_cameraid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeadMotionRequest::set_has_cameraid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeadMotionRequest::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeadMotionRequest::clear_cameraid() {
  cameraid_ = 0u;
  clear_has_cameraid();
}
inline ::google::protobuf::uint32 HeadMotionRequest::cameraid() const {
  return cameraid_;
}
inline void HeadMotionRequest::set_cameraid(::google::protobuf::uint32 value) {
  set_has_cameraid();
  cameraid_ = value;
}

// optional .naothmessages.DoubleVector2 targetJointPosition = 3;
inline bool HeadMotionRequest::has_targetjointposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeadMotionRequest::set_has_targetjointposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeadMotionRequest::clear_has_targetjointposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeadMotionRequest::clear_targetjointposition() {
  if (targetjointposition_ != NULL) targetjointposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_targetjointposition();
}
inline const ::naothmessages::DoubleVector2& HeadMotionRequest::targetjointposition() const {
  return targetjointposition_ != NULL ? *targetjointposition_ : *default_instance_->targetjointposition_;
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::mutable_targetjointposition() {
  set_has_targetjointposition();
  if (targetjointposition_ == NULL) targetjointposition_ = new ::naothmessages::DoubleVector2;
  return targetjointposition_;
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::release_targetjointposition() {
  clear_has_targetjointposition();
  ::naothmessages::DoubleVector2* temp = targetjointposition_;
  targetjointposition_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector2 targetPointInImage = 4;
inline bool HeadMotionRequest::has_targetpointinimage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeadMotionRequest::set_has_targetpointinimage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeadMotionRequest::clear_has_targetpointinimage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeadMotionRequest::clear_targetpointinimage() {
  if (targetpointinimage_ != NULL) targetpointinimage_->::naothmessages::DoubleVector2::Clear();
  clear_has_targetpointinimage();
}
inline const ::naothmessages::DoubleVector2& HeadMotionRequest::targetpointinimage() const {
  return targetpointinimage_ != NULL ? *targetpointinimage_ : *default_instance_->targetpointinimage_;
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::mutable_targetpointinimage() {
  set_has_targetpointinimage();
  if (targetpointinimage_ == NULL) targetpointinimage_ = new ::naothmessages::DoubleVector2;
  return targetpointinimage_;
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::release_targetpointinimage() {
  clear_has_targetpointinimage();
  ::naothmessages::DoubleVector2* temp = targetpointinimage_;
  targetpointinimage_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector3 targetPointInTheWorld = 5;
inline bool HeadMotionRequest::has_targetpointintheworld() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeadMotionRequest::set_has_targetpointintheworld() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeadMotionRequest::clear_has_targetpointintheworld() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeadMotionRequest::clear_targetpointintheworld() {
  if (targetpointintheworld_ != NULL) targetpointintheworld_->::naothmessages::DoubleVector3::Clear();
  clear_has_targetpointintheworld();
}
inline const ::naothmessages::DoubleVector3& HeadMotionRequest::targetpointintheworld() const {
  return targetpointintheworld_ != NULL ? *targetpointintheworld_ : *default_instance_->targetpointintheworld_;
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::mutable_targetpointintheworld() {
  set_has_targetpointintheworld();
  if (targetpointintheworld_ == NULL) targetpointintheworld_ = new ::naothmessages::DoubleVector3;
  return targetpointintheworld_;
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::release_targetpointintheworld() {
  clear_has_targetpointintheworld();
  ::naothmessages::DoubleVector3* temp = targetpointintheworld_;
  targetpointintheworld_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector3 searchCenter = 6;
inline bool HeadMotionRequest::has_searchcenter() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeadMotionRequest::set_has_searchcenter() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeadMotionRequest::clear_has_searchcenter() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeadMotionRequest::clear_searchcenter() {
  if (searchcenter_ != NULL) searchcenter_->::naothmessages::DoubleVector3::Clear();
  clear_has_searchcenter();
}
inline const ::naothmessages::DoubleVector3& HeadMotionRequest::searchcenter() const {
  return searchcenter_ != NULL ? *searchcenter_ : *default_instance_->searchcenter_;
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::mutable_searchcenter() {
  set_has_searchcenter();
  if (searchcenter_ == NULL) searchcenter_ = new ::naothmessages::DoubleVector3;
  return searchcenter_;
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::release_searchcenter() {
  clear_has_searchcenter();
  ::naothmessages::DoubleVector3* temp = searchcenter_;
  searchcenter_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector3 searchSize = 7;
inline bool HeadMotionRequest::has_searchsize() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HeadMotionRequest::set_has_searchsize() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HeadMotionRequest::clear_has_searchsize() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HeadMotionRequest::clear_searchsize() {
  if (searchsize_ != NULL) searchsize_->::naothmessages::DoubleVector3::Clear();
  clear_has_searchsize();
}
inline const ::naothmessages::DoubleVector3& HeadMotionRequest::searchsize() const {
  return searchsize_ != NULL ? *searchsize_ : *default_instance_->searchsize_;
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::mutable_searchsize() {
  set_has_searchsize();
  if (searchsize_ == NULL) searchsize_ = new ::naothmessages::DoubleVector3;
  return searchsize_;
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::release_searchsize() {
  clear_has_searchsize();
  ::naothmessages::DoubleVector3* temp = searchsize_;
  searchsize_ = NULL;
  return temp;
}

// optional bool searchDirection = 8;
inline bool HeadMotionRequest::has_searchdirection() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HeadMotionRequest::set_has_searchdirection() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HeadMotionRequest::clear_has_searchdirection() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HeadMotionRequest::clear_searchdirection() {
  searchdirection_ = false;
  clear_has_searchdirection();
}
inline bool HeadMotionRequest::searchdirection() const {
  return searchdirection_;
}
inline void HeadMotionRequest::set_searchdirection(bool value) {
  set_has_searchdirection();
  searchdirection_ = value;
}

// optional .naothmessages.DoubleVector2 targetPointOnTheGround = 9;
inline bool HeadMotionRequest::has_targetpointontheground() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HeadMotionRequest::set_has_targetpointontheground() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HeadMotionRequest::clear_has_targetpointontheground() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HeadMotionRequest::clear_targetpointontheground() {
  if (targetpointontheground_ != NULL) targetpointontheground_->::naothmessages::DoubleVector2::Clear();
  clear_has_targetpointontheground();
}
inline const ::naothmessages::DoubleVector2& HeadMotionRequest::targetpointontheground() const {
  return targetpointontheground_ != NULL ? *targetpointontheground_ : *default_instance_->targetpointontheground_;
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::mutable_targetpointontheground() {
  set_has_targetpointontheground();
  if (targetpointontheground_ == NULL) targetpointontheground_ = new ::naothmessages::DoubleVector2;
  return targetpointontheground_;
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::release_targetpointontheground() {
  clear_has_targetpointontheground();
  ::naothmessages::DoubleVector2* temp = targetpointontheground_;
  targetpointontheground_ = NULL;
  return temp;
}

// optional uint32 coordinate = 10;
inline bool HeadMotionRequest::has_coordinate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HeadMotionRequest::set_has_coordinate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HeadMotionRequest::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HeadMotionRequest::clear_coordinate() {
  coordinate_ = 0u;
  clear_has_coordinate();
}
inline ::google::protobuf::uint32 HeadMotionRequest::coordinate() const {
  return coordinate_;
}
inline void HeadMotionRequest::set_coordinate(::google::protobuf::uint32 value) {
  set_has_coordinate();
  coordinate_ = value;
}

// -------------------------------------------------------------------

// StepControlRequest

// required uint32 stepID = 1;
inline bool StepControlRequest::has_stepid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StepControlRequest::set_has_stepid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StepControlRequest::clear_has_stepid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StepControlRequest::clear_stepid() {
  stepid_ = 0u;
  clear_has_stepid();
}
inline ::google::protobuf::uint32 StepControlRequest::stepid() const {
  return stepid_;
}
inline void StepControlRequest::set_stepid(::google::protobuf::uint32 value) {
  set_has_stepid();
  stepid_ = value;
}

// required bool moveLeftFoot = 2;
inline bool StepControlRequest::has_moveleftfoot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StepControlRequest::set_has_moveleftfoot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StepControlRequest::clear_has_moveleftfoot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StepControlRequest::clear_moveleftfoot() {
  moveleftfoot_ = false;
  clear_has_moveleftfoot();
}
inline bool StepControlRequest::moveleftfoot() const {
  return moveleftfoot_;
}
inline void StepControlRequest::set_moveleftfoot(bool value) {
  set_has_moveleftfoot();
  moveleftfoot_ = value;
}

// required .naothmessages.Pose2D target = 3;
inline bool StepControlRequest::has_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StepControlRequest::set_has_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StepControlRequest::clear_has_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StepControlRequest::clear_target() {
  if (target_ != NULL) target_->::naothmessages::Pose2D::Clear();
  clear_has_target();
}
inline const ::naothmessages::Pose2D& StepControlRequest::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::naothmessages::Pose2D* StepControlRequest::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::naothmessages::Pose2D;
  return target_;
}
inline ::naothmessages::Pose2D* StepControlRequest::release_target() {
  clear_has_target();
  ::naothmessages::Pose2D* temp = target_;
  target_ = NULL;
  return temp;
}

// required uint32 time = 4;
inline bool StepControlRequest::has_time() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StepControlRequest::set_has_time() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StepControlRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StepControlRequest::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 StepControlRequest::time() const {
  return time_;
}
inline void StepControlRequest::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required double speedDirection = 5;
inline bool StepControlRequest::has_speeddirection() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StepControlRequest::set_has_speeddirection() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StepControlRequest::clear_has_speeddirection() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StepControlRequest::clear_speeddirection() {
  speeddirection_ = 0;
  clear_has_speeddirection();
}
inline double StepControlRequest::speeddirection() const {
  return speeddirection_;
}
inline void StepControlRequest::set_speeddirection(double value) {
  set_has_speeddirection();
  speeddirection_ = value;
}

// required double scale = 6;
inline bool StepControlRequest::has_scale() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StepControlRequest::set_has_scale() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StepControlRequest::clear_has_scale() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StepControlRequest::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline double StepControlRequest::scale() const {
  return scale_;
}
inline void StepControlRequest::set_scale(double value) {
  set_has_scale();
  scale_ = value;
}

// -------------------------------------------------------------------

// WalkRequest

// required uint32 coordinate = 1;
inline bool WalkRequest::has_coordinate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WalkRequest::set_has_coordinate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WalkRequest::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WalkRequest::clear_coordinate() {
  coordinate_ = 0u;
  clear_has_coordinate();
}
inline ::google::protobuf::uint32 WalkRequest::coordinate() const {
  return coordinate_;
}
inline void WalkRequest::set_coordinate(::google::protobuf::uint32 value) {
  set_has_coordinate();
  coordinate_ = value;
}

// required double character = 2;
inline bool WalkRequest::has_character() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WalkRequest::set_has_character() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WalkRequest::clear_has_character() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WalkRequest::clear_character() {
  character_ = 0;
  clear_has_character();
}
inline double WalkRequest::character() const {
  return character_;
}
inline void WalkRequest::set_character(double value) {
  set_has_character();
  character_ = value;
}

// required .naothmessages.Pose2D target = 3;
inline bool WalkRequest::has_target() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WalkRequest::set_has_target() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WalkRequest::clear_has_target() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WalkRequest::clear_target() {
  if (target_ != NULL) target_->::naothmessages::Pose2D::Clear();
  clear_has_target();
}
inline const ::naothmessages::Pose2D& WalkRequest::target() const {
  return target_ != NULL ? *target_ : *default_instance_->target_;
}
inline ::naothmessages::Pose2D* WalkRequest::mutable_target() {
  set_has_target();
  if (target_ == NULL) target_ = new ::naothmessages::Pose2D;
  return target_;
}
inline ::naothmessages::Pose2D* WalkRequest::release_target() {
  clear_has_target();
  ::naothmessages::Pose2D* temp = target_;
  target_ = NULL;
  return temp;
}

// optional .naothmessages.StepControlRequest stepControl = 4;
inline bool WalkRequest::has_stepcontrol() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WalkRequest::set_has_stepcontrol() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WalkRequest::clear_has_stepcontrol() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WalkRequest::clear_stepcontrol() {
  if (stepcontrol_ != NULL) stepcontrol_->::naothmessages::StepControlRequest::Clear();
  clear_has_stepcontrol();
}
inline const ::naothmessages::StepControlRequest& WalkRequest::stepcontrol() const {
  return stepcontrol_ != NULL ? *stepcontrol_ : *default_instance_->stepcontrol_;
}
inline ::naothmessages::StepControlRequest* WalkRequest::mutable_stepcontrol() {
  set_has_stepcontrol();
  if (stepcontrol_ == NULL) stepcontrol_ = new ::naothmessages::StepControlRequest;
  return stepcontrol_;
}
inline ::naothmessages::StepControlRequest* WalkRequest::release_stepcontrol() {
  clear_has_stepcontrol();
  ::naothmessages::StepControlRequest* temp = stepcontrol_;
  stepcontrol_ = NULL;
  return temp;
}

// required .naothmessages.Pose2D offset = 5;
inline bool WalkRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WalkRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WalkRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WalkRequest::clear_offset() {
  if (offset_ != NULL) offset_->::naothmessages::Pose2D::Clear();
  clear_has_offset();
}
inline const ::naothmessages::Pose2D& WalkRequest::offset() const {
  return offset_ != NULL ? *offset_ : *default_instance_->offset_;
}
inline ::naothmessages::Pose2D* WalkRequest::mutable_offset() {
  set_has_offset();
  if (offset_ == NULL) offset_ = new ::naothmessages::Pose2D;
  return offset_;
}
inline ::naothmessages::Pose2D* WalkRequest::release_offset() {
  clear_has_offset();
  ::naothmessages::Pose2D* temp = offset_;
  offset_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// KickRequest

// required .naothmessages.DoubleVector3 kickPoint = 1;
inline bool KickRequest::has_kickpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickRequest::set_has_kickpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickRequest::clear_has_kickpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickRequest::clear_kickpoint() {
  if (kickpoint_ != NULL) kickpoint_->::naothmessages::DoubleVector3::Clear();
  clear_has_kickpoint();
}
inline const ::naothmessages::DoubleVector3& KickRequest::kickpoint() const {
  return kickpoint_ != NULL ? *kickpoint_ : *default_instance_->kickpoint_;
}
inline ::naothmessages::DoubleVector3* KickRequest::mutable_kickpoint() {
  set_has_kickpoint();
  if (kickpoint_ == NULL) kickpoint_ = new ::naothmessages::DoubleVector3;
  return kickpoint_;
}
inline ::naothmessages::DoubleVector3* KickRequest::release_kickpoint() {
  clear_has_kickpoint();
  ::naothmessages::DoubleVector3* temp = kickpoint_;
  kickpoint_ = NULL;
  return temp;
}

// required double kickDirection = 2;
inline bool KickRequest::has_kickdirection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickRequest::set_has_kickdirection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickRequest::clear_has_kickdirection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickRequest::clear_kickdirection() {
  kickdirection_ = 0;
  clear_has_kickdirection();
}
inline double KickRequest::kickdirection() const {
  return kickdirection_;
}
inline void KickRequest::set_kickdirection(double value) {
  set_has_kickdirection();
  kickdirection_ = value;
}

// required int32 kickFoot = 3;
inline bool KickRequest::has_kickfoot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KickRequest::set_has_kickfoot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KickRequest::clear_has_kickfoot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KickRequest::clear_kickfoot() {
  kickfoot_ = 0;
  clear_has_kickfoot();
}
inline ::google::protobuf::int32 KickRequest::kickfoot() const {
  return kickfoot_;
}
inline void KickRequest::set_kickfoot(::google::protobuf::int32 value) {
  set_has_kickfoot();
  kickfoot_ = value;
}

// required bool finishKick = 4;
inline bool KickRequest::has_finishkick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KickRequest::set_has_finishkick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KickRequest::clear_has_finishkick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KickRequest::clear_finishkick() {
  finishkick_ = false;
  clear_has_finishkick();
}
inline bool KickRequest::finishkick() const {
  return finishkick_;
}
inline void KickRequest::set_finishkick(bool value) {
  set_has_finishkick();
  finishkick_ = value;
}

// -------------------------------------------------------------------

// GraspRequest

// required .naothmessages.DoubleVector3 graspingPoint = 1;
inline bool GraspRequest::has_graspingpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GraspRequest::set_has_graspingpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GraspRequest::clear_has_graspingpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GraspRequest::clear_graspingpoint() {
  if (graspingpoint_ != NULL) graspingpoint_->::naothmessages::DoubleVector3::Clear();
  clear_has_graspingpoint();
}
inline const ::naothmessages::DoubleVector3& GraspRequest::graspingpoint() const {
  return graspingpoint_ != NULL ? *graspingpoint_ : *default_instance_->graspingpoint_;
}
inline ::naothmessages::DoubleVector3* GraspRequest::mutable_graspingpoint() {
  set_has_graspingpoint();
  if (graspingpoint_ == NULL) graspingpoint_ = new ::naothmessages::DoubleVector3;
  return graspingpoint_;
}
inline ::naothmessages::DoubleVector3* GraspRequest::release_graspingpoint() {
  clear_has_graspingpoint();
  ::naothmessages::DoubleVector3* temp = graspingpoint_;
  graspingpoint_ = NULL;
  return temp;
}

// required uint32 graspingState = 2;
inline bool GraspRequest::has_graspingstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GraspRequest::set_has_graspingstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GraspRequest::clear_has_graspingstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GraspRequest::clear_graspingstate() {
  graspingstate_ = 0u;
  clear_has_graspingstate();
}
inline ::google::protobuf::uint32 GraspRequest::graspingstate() const {
  return graspingstate_;
}
inline void GraspRequest::set_graspingstate(::google::protobuf::uint32 value) {
  set_has_graspingstate();
  graspingstate_ = value;
}

// required uint32 graspDistState = 3;
inline bool GraspRequest::has_graspdiststate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GraspRequest::set_has_graspdiststate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GraspRequest::clear_has_graspdiststate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GraspRequest::clear_graspdiststate() {
  graspdiststate_ = 0u;
  clear_has_graspdiststate();
}
inline ::google::protobuf::uint32 GraspRequest::graspdiststate() const {
  return graspdiststate_;
}
inline void GraspRequest::set_graspdiststate(::google::protobuf::uint32 value) {
  set_has_graspdiststate();
  graspdiststate_ = value;
}

// required uint32 graspStiffState = 4;
inline bool GraspRequest::has_graspstiffstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GraspRequest::set_has_graspstiffstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GraspRequest::clear_has_graspstiffstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GraspRequest::clear_graspstiffstate() {
  graspstiffstate_ = 0u;
  clear_has_graspstiffstate();
}
inline ::google::protobuf::uint32 GraspRequest::graspstiffstate() const {
  return graspstiffstate_;
}
inline void GraspRequest::set_graspstiffstate(::google::protobuf::uint32 value) {
  set_has_graspstiffstate();
  graspstiffstate_ = value;
}

// -------------------------------------------------------------------

// ArmMotionRequest

// required uint32 id = 1;
inline bool ArmMotionRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArmMotionRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArmMotionRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArmMotionRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ArmMotionRequest::id() const {
  return id_;
}
inline void ArmMotionRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .naothmessages.DoubleVector2 lShoulderPosition = 2;
inline bool ArmMotionRequest::has_lshoulderposition() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArmMotionRequest::set_has_lshoulderposition() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArmMotionRequest::clear_has_lshoulderposition() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArmMotionRequest::clear_lshoulderposition() {
  if (lshoulderposition_ != NULL) lshoulderposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_lshoulderposition();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::lshoulderposition() const {
  return lshoulderposition_ != NULL ? *lshoulderposition_ : *default_instance_->lshoulderposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_lshoulderposition() {
  set_has_lshoulderposition();
  if (lshoulderposition_ == NULL) lshoulderposition_ = new ::naothmessages::DoubleVector2;
  return lshoulderposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_lshoulderposition() {
  clear_has_lshoulderposition();
  ::naothmessages::DoubleVector2* temp = lshoulderposition_;
  lshoulderposition_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector2 lShoulderStiffness = 3;
inline bool ArmMotionRequest::has_lshoulderstiffness() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArmMotionRequest::set_has_lshoulderstiffness() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArmMotionRequest::clear_has_lshoulderstiffness() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArmMotionRequest::clear_lshoulderstiffness() {
  if (lshoulderstiffness_ != NULL) lshoulderstiffness_->::naothmessages::DoubleVector2::Clear();
  clear_has_lshoulderstiffness();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::lshoulderstiffness() const {
  return lshoulderstiffness_ != NULL ? *lshoulderstiffness_ : *default_instance_->lshoulderstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_lshoulderstiffness() {
  set_has_lshoulderstiffness();
  if (lshoulderstiffness_ == NULL) lshoulderstiffness_ = new ::naothmessages::DoubleVector2;
  return lshoulderstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_lshoulderstiffness() {
  clear_has_lshoulderstiffness();
  ::naothmessages::DoubleVector2* temp = lshoulderstiffness_;
  lshoulderstiffness_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector2 lElbowPosition = 4;
inline bool ArmMotionRequest::has_lelbowposition() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArmMotionRequest::set_has_lelbowposition() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArmMotionRequest::clear_has_lelbowposition() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArmMotionRequest::clear_lelbowposition() {
  if (lelbowposition_ != NULL) lelbowposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_lelbowposition();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::lelbowposition() const {
  return lelbowposition_ != NULL ? *lelbowposition_ : *default_instance_->lelbowposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_lelbowposition() {
  set_has_lelbowposition();
  if (lelbowposition_ == NULL) lelbowposition_ = new ::naothmessages::DoubleVector2;
  return lelbowposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_lelbowposition() {
  clear_has_lelbowposition();
  ::naothmessages::DoubleVector2* temp = lelbowposition_;
  lelbowposition_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector2 lElbowStiffness = 5;
inline bool ArmMotionRequest::has_lelbowstiffness() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArmMotionRequest::set_has_lelbowstiffness() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArmMotionRequest::clear_has_lelbowstiffness() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArmMotionRequest::clear_lelbowstiffness() {
  if (lelbowstiffness_ != NULL) lelbowstiffness_->::naothmessages::DoubleVector2::Clear();
  clear_has_lelbowstiffness();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::lelbowstiffness() const {
  return lelbowstiffness_ != NULL ? *lelbowstiffness_ : *default_instance_->lelbowstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_lelbowstiffness() {
  set_has_lelbowstiffness();
  if (lelbowstiffness_ == NULL) lelbowstiffness_ = new ::naothmessages::DoubleVector2;
  return lelbowstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_lelbowstiffness() {
  clear_has_lelbowstiffness();
  ::naothmessages::DoubleVector2* temp = lelbowstiffness_;
  lelbowstiffness_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector2 rShoulderPosition = 6;
inline bool ArmMotionRequest::has_rshoulderposition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArmMotionRequest::set_has_rshoulderposition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArmMotionRequest::clear_has_rshoulderposition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArmMotionRequest::clear_rshoulderposition() {
  if (rshoulderposition_ != NULL) rshoulderposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_rshoulderposition();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::rshoulderposition() const {
  return rshoulderposition_ != NULL ? *rshoulderposition_ : *default_instance_->rshoulderposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_rshoulderposition() {
  set_has_rshoulderposition();
  if (rshoulderposition_ == NULL) rshoulderposition_ = new ::naothmessages::DoubleVector2;
  return rshoulderposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_rshoulderposition() {
  clear_has_rshoulderposition();
  ::naothmessages::DoubleVector2* temp = rshoulderposition_;
  rshoulderposition_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector2 rShoulderStiffness = 7;
inline bool ArmMotionRequest::has_rshoulderstiffness() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArmMotionRequest::set_has_rshoulderstiffness() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArmMotionRequest::clear_has_rshoulderstiffness() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArmMotionRequest::clear_rshoulderstiffness() {
  if (rshoulderstiffness_ != NULL) rshoulderstiffness_->::naothmessages::DoubleVector2::Clear();
  clear_has_rshoulderstiffness();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::rshoulderstiffness() const {
  return rshoulderstiffness_ != NULL ? *rshoulderstiffness_ : *default_instance_->rshoulderstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_rshoulderstiffness() {
  set_has_rshoulderstiffness();
  if (rshoulderstiffness_ == NULL) rshoulderstiffness_ = new ::naothmessages::DoubleVector2;
  return rshoulderstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_rshoulderstiffness() {
  clear_has_rshoulderstiffness();
  ::naothmessages::DoubleVector2* temp = rshoulderstiffness_;
  rshoulderstiffness_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector2 rElbowPosition = 8;
inline bool ArmMotionRequest::has_relbowposition() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ArmMotionRequest::set_has_relbowposition() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ArmMotionRequest::clear_has_relbowposition() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ArmMotionRequest::clear_relbowposition() {
  if (relbowposition_ != NULL) relbowposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_relbowposition();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::relbowposition() const {
  return relbowposition_ != NULL ? *relbowposition_ : *default_instance_->relbowposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_relbowposition() {
  set_has_relbowposition();
  if (relbowposition_ == NULL) relbowposition_ = new ::naothmessages::DoubleVector2;
  return relbowposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_relbowposition() {
  clear_has_relbowposition();
  ::naothmessages::DoubleVector2* temp = relbowposition_;
  relbowposition_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector2 rElbowStiffness = 9;
inline bool ArmMotionRequest::has_relbowstiffness() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ArmMotionRequest::set_has_relbowstiffness() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ArmMotionRequest::clear_has_relbowstiffness() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ArmMotionRequest::clear_relbowstiffness() {
  if (relbowstiffness_ != NULL) relbowstiffness_->::naothmessages::DoubleVector2::Clear();
  clear_has_relbowstiffness();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::relbowstiffness() const {
  return relbowstiffness_ != NULL ? *relbowstiffness_ : *default_instance_->relbowstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_relbowstiffness() {
  set_has_relbowstiffness();
  if (relbowstiffness_ == NULL) relbowstiffness_ = new ::naothmessages::DoubleVector2;
  return relbowstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_relbowstiffness() {
  clear_has_relbowstiffness();
  ::naothmessages::DoubleVector2* temp = relbowstiffness_;
  relbowstiffness_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// MotionRequest

// required uint32 id = 1;
inline bool MotionRequest::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotionRequest::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotionRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MotionRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MotionRequest::id() const {
  return id_;
}
inline void MotionRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 time = 2;
inline bool MotionRequest::has_time() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MotionRequest::set_has_time() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MotionRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MotionRequest::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 MotionRequest::time() const {
  return time_;
}
inline void MotionRequest::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required bool forced = 3;
inline bool MotionRequest::has_forced() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotionRequest::set_has_forced() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotionRequest::clear_has_forced() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MotionRequest::clear_forced() {
  forced_ = false;
  clear_has_forced();
}
inline bool MotionRequest::forced() const {
  return forced_;
}
inline void MotionRequest::set_forced(bool value) {
  set_has_forced();
  forced_ = value;
}

// optional .naothmessages.WalkRequest walkRequest = 4;
inline bool MotionRequest::has_walkrequest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotionRequest::set_has_walkrequest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotionRequest::clear_has_walkrequest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MotionRequest::clear_walkrequest() {
  if (walkrequest_ != NULL) walkrequest_->::naothmessages::WalkRequest::Clear();
  clear_has_walkrequest();
}
inline const ::naothmessages::WalkRequest& MotionRequest::walkrequest() const {
  return walkrequest_ != NULL ? *walkrequest_ : *default_instance_->walkrequest_;
}
inline ::naothmessages::WalkRequest* MotionRequest::mutable_walkrequest() {
  set_has_walkrequest();
  if (walkrequest_ == NULL) walkrequest_ = new ::naothmessages::WalkRequest;
  return walkrequest_;
}
inline ::naothmessages::WalkRequest* MotionRequest::release_walkrequest() {
  clear_has_walkrequest();
  ::naothmessages::WalkRequest* temp = walkrequest_;
  walkrequest_ = NULL;
  return temp;
}

// optional bool starndardStand = 5;
inline bool MotionRequest::has_starndardstand() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MotionRequest::set_has_starndardstand() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MotionRequest::clear_has_starndardstand() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MotionRequest::clear_starndardstand() {
  starndardstand_ = false;
  clear_has_starndardstand();
}
inline bool MotionRequest::starndardstand() const {
  return starndardstand_;
}
inline void MotionRequest::set_starndardstand(bool value) {
  set_has_starndardstand();
  starndardstand_ = value;
}

// optional .naothmessages.KickRequest kickRequest = 6;
inline bool MotionRequest::has_kickrequest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MotionRequest::set_has_kickrequest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MotionRequest::clear_has_kickrequest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MotionRequest::clear_kickrequest() {
  if (kickrequest_ != NULL) kickrequest_->::naothmessages::KickRequest::Clear();
  clear_has_kickrequest();
}
inline const ::naothmessages::KickRequest& MotionRequest::kickrequest() const {
  return kickrequest_ != NULL ? *kickrequest_ : *default_instance_->kickrequest_;
}
inline ::naothmessages::KickRequest* MotionRequest::mutable_kickrequest() {
  set_has_kickrequest();
  if (kickrequest_ == NULL) kickrequest_ = new ::naothmessages::KickRequest;
  return kickrequest_;
}
inline ::naothmessages::KickRequest* MotionRequest::release_kickrequest() {
  clear_has_kickrequest();
  ::naothmessages::KickRequest* temp = kickrequest_;
  kickrequest_ = NULL;
  return temp;
}

// optional double standHeight = 7;
inline bool MotionRequest::has_standheight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MotionRequest::set_has_standheight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MotionRequest::clear_has_standheight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MotionRequest::clear_standheight() {
  standheight_ = 0;
  clear_has_standheight();
}
inline double MotionRequest::standheight() const {
  return standheight_;
}
inline void MotionRequest::set_standheight(double value) {
  set_has_standheight();
  standheight_ = value;
}

// optional bool calibrateFootTouchDetector = 8;
inline bool MotionRequest::has_calibratefoottouchdetector() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MotionRequest::set_has_calibratefoottouchdetector() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MotionRequest::clear_has_calibratefoottouchdetector() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MotionRequest::clear_calibratefoottouchdetector() {
  calibratefoottouchdetector_ = false;
  clear_has_calibratefoottouchdetector();
}
inline bool MotionRequest::calibratefoottouchdetector() const {
  return calibratefoottouchdetector_;
}
inline void MotionRequest::set_calibratefoottouchdetector(bool value) {
  set_has_calibratefoottouchdetector();
  calibratefoottouchdetector_ = value;
}

// optional uint32 cognitionFrameNumber = 9;
inline bool MotionRequest::has_cognitionframenumber() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MotionRequest::set_has_cognitionframenumber() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MotionRequest::clear_has_cognitionframenumber() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MotionRequest::clear_cognitionframenumber() {
  cognitionframenumber_ = 0u;
  clear_has_cognitionframenumber();
}
inline ::google::protobuf::uint32 MotionRequest::cognitionframenumber() const {
  return cognitionframenumber_;
}
inline void MotionRequest::set_cognitionframenumber(::google::protobuf::uint32 value) {
  set_has_cognitionframenumber();
  cognitionframenumber_ = value;
}

// optional .naothmessages.GraspRequest graspRequest = 10;
inline bool MotionRequest::has_grasprequest() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MotionRequest::set_has_grasprequest() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MotionRequest::clear_has_grasprequest() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MotionRequest::clear_grasprequest() {
  if (grasprequest_ != NULL) grasprequest_->::naothmessages::GraspRequest::Clear();
  clear_has_grasprequest();
}
inline const ::naothmessages::GraspRequest& MotionRequest::grasprequest() const {
  return grasprequest_ != NULL ? *grasprequest_ : *default_instance_->grasprequest_;
}
inline ::naothmessages::GraspRequest* MotionRequest::mutable_grasprequest() {
  set_has_grasprequest();
  if (grasprequest_ == NULL) grasprequest_ = new ::naothmessages::GraspRequest;
  return grasprequest_;
}
inline ::naothmessages::GraspRequest* MotionRequest::release_grasprequest() {
  clear_has_grasprequest();
  ::naothmessages::GraspRequest* temp = grasprequest_;
  grasprequest_ = NULL;
  return temp;
}

// optional .naothmessages.ArmMotionRequest armMotionRequest = 11;
inline bool MotionRequest::has_armmotionrequest() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MotionRequest::set_has_armmotionrequest() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MotionRequest::clear_has_armmotionrequest() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MotionRequest::clear_armmotionrequest() {
  if (armmotionrequest_ != NULL) armmotionrequest_->::naothmessages::ArmMotionRequest::Clear();
  clear_has_armmotionrequest();
}
inline const ::naothmessages::ArmMotionRequest& MotionRequest::armmotionrequest() const {
  return armmotionrequest_ != NULL ? *armmotionrequest_ : *default_instance_->armmotionrequest_;
}
inline ::naothmessages::ArmMotionRequest* MotionRequest::mutable_armmotionrequest() {
  set_has_armmotionrequest();
  if (armmotionrequest_ == NULL) armmotionrequest_ = new ::naothmessages::ArmMotionRequest;
  return armmotionrequest_;
}
inline ::naothmessages::ArmMotionRequest* MotionRequest::release_armmotionrequest() {
  clear_has_armmotionrequest();
  ::naothmessages::ArmMotionRequest* temp = armmotionrequest_;
  armmotionrequest_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LinePercept

// repeated .naothmessages.FieldLineSegment lines = 1;
inline int LinePercept::lines_size() const {
  return lines_.size();
}
inline void LinePercept::clear_lines() {
  lines_.Clear();
}
inline const ::naothmessages::FieldLineSegment& LinePercept::lines(int index) const {
  return lines_.Get(index);
}
inline ::naothmessages::FieldLineSegment* LinePercept::mutable_lines(int index) {
  return lines_.Mutable(index);
}
inline ::naothmessages::FieldLineSegment* LinePercept::add_lines() {
  return lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::FieldLineSegment >&
LinePercept::lines() const {
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::FieldLineSegment >*
LinePercept::mutable_lines() {
  return &lines_;
}

// repeated .naothmessages.Intersection intersections = 2;
inline int LinePercept::intersections_size() const {
  return intersections_.size();
}
inline void LinePercept::clear_intersections() {
  intersections_.Clear();
}
inline const ::naothmessages::Intersection& LinePercept::intersections(int index) const {
  return intersections_.Get(index);
}
inline ::naothmessages::Intersection* LinePercept::mutable_intersections(int index) {
  return intersections_.Mutable(index);
}
inline ::naothmessages::Intersection* LinePercept::add_intersections() {
  return intersections_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Intersection >&
LinePercept::intersections() const {
  return intersections_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Intersection >*
LinePercept::mutable_intersections() {
  return &intersections_;
}

// optional .naothmessages.DoubleVector2 middleCircleCenter = 3;
inline bool LinePercept::has_middlecirclecenter() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinePercept::set_has_middlecirclecenter() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinePercept::clear_has_middlecirclecenter() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinePercept::clear_middlecirclecenter() {
  if (middlecirclecenter_ != NULL) middlecirclecenter_->::naothmessages::DoubleVector2::Clear();
  clear_has_middlecirclecenter();
}
inline const ::naothmessages::DoubleVector2& LinePercept::middlecirclecenter() const {
  return middlecirclecenter_ != NULL ? *middlecirclecenter_ : *default_instance_->middlecirclecenter_;
}
inline ::naothmessages::DoubleVector2* LinePercept::mutable_middlecirclecenter() {
  set_has_middlecirclecenter();
  if (middlecirclecenter_ == NULL) middlecirclecenter_ = new ::naothmessages::DoubleVector2;
  return middlecirclecenter_;
}
inline ::naothmessages::DoubleVector2* LinePercept::release_middlecirclecenter() {
  clear_has_middlecirclecenter();
  ::naothmessages::DoubleVector2* temp = middlecirclecenter_;
  middlecirclecenter_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ScanLineEndPoint

// required .naothmessages.IntVector2 posInImage = 1;
inline bool ScanLineEndPoint::has_posinimage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScanLineEndPoint::set_has_posinimage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScanLineEndPoint::clear_has_posinimage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScanLineEndPoint::clear_posinimage() {
  if (posinimage_ != NULL) posinimage_->::naothmessages::IntVector2::Clear();
  clear_has_posinimage();
}
inline const ::naothmessages::IntVector2& ScanLineEndPoint::posinimage() const {
  return posinimage_ != NULL ? *posinimage_ : *default_instance_->posinimage_;
}
inline ::naothmessages::IntVector2* ScanLineEndPoint::mutable_posinimage() {
  set_has_posinimage();
  if (posinimage_ == NULL) posinimage_ = new ::naothmessages::IntVector2;
  return posinimage_;
}
inline ::naothmessages::IntVector2* ScanLineEndPoint::release_posinimage() {
  clear_has_posinimage();
  ::naothmessages::IntVector2* temp = posinimage_;
  posinimage_ = NULL;
  return temp;
}

// required .naothmessages.DoubleVector2 posOnField = 2;
inline bool ScanLineEndPoint::has_posonfield() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanLineEndPoint::set_has_posonfield() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScanLineEndPoint::clear_has_posonfield() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScanLineEndPoint::clear_posonfield() {
  if (posonfield_ != NULL) posonfield_->::naothmessages::DoubleVector2::Clear();
  clear_has_posonfield();
}
inline const ::naothmessages::DoubleVector2& ScanLineEndPoint::posonfield() const {
  return posonfield_ != NULL ? *posonfield_ : *default_instance_->posonfield_;
}
inline ::naothmessages::DoubleVector2* ScanLineEndPoint::mutable_posonfield() {
  set_has_posonfield();
  if (posonfield_ == NULL) posonfield_ = new ::naothmessages::DoubleVector2;
  return posonfield_;
}
inline ::naothmessages::DoubleVector2* ScanLineEndPoint::release_posonfield() {
  clear_has_posonfield();
  ::naothmessages::DoubleVector2* temp = posonfield_;
  posonfield_ = NULL;
  return temp;
}

// required .naothmessages.Color color = 3;
inline bool ScanLineEndPoint::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScanLineEndPoint::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScanLineEndPoint::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScanLineEndPoint::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline naothmessages::Color ScanLineEndPoint::color() const {
  return static_cast< naothmessages::Color >(color_);
}
inline void ScanLineEndPoint::set_color(naothmessages::Color value) {
  GOOGLE_DCHECK(naothmessages::Color_IsValid(value));
  set_has_color();
  color_ = value;
}

// required uint32 ScanLineID = 4;
inline bool ScanLineEndPoint::has_scanlineid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScanLineEndPoint::set_has_scanlineid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScanLineEndPoint::clear_has_scanlineid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScanLineEndPoint::clear_scanlineid() {
  scanlineid_ = 0u;
  clear_has_scanlineid();
}
inline ::google::protobuf::uint32 ScanLineEndPoint::scanlineid() const {
  return scanlineid_;
}
inline void ScanLineEndPoint::set_scanlineid(::google::protobuf::uint32 value) {
  set_has_scanlineid();
  scanlineid_ = value;
}

// -------------------------------------------------------------------

// Edgel

// required .naothmessages.IntVector2 point = 1;
inline bool Edgel::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edgel::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edgel::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edgel::clear_point() {
  if (point_ != NULL) point_->::naothmessages::IntVector2::Clear();
  clear_has_point();
}
inline const ::naothmessages::IntVector2& Edgel::point() const {
  return point_ != NULL ? *point_ : *default_instance_->point_;
}
inline ::naothmessages::IntVector2* Edgel::mutable_point() {
  set_has_point();
  if (point_ == NULL) point_ = new ::naothmessages::IntVector2;
  return point_;
}
inline ::naothmessages::IntVector2* Edgel::release_point() {
  clear_has_point();
  ::naothmessages::IntVector2* temp = point_;
  point_ = NULL;
  return temp;
}

// required .naothmessages.DoubleVector2 direction = 2;
inline bool Edgel::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edgel::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edgel::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edgel::clear_direction() {
  if (direction_ != NULL) direction_->::naothmessages::DoubleVector2::Clear();
  clear_has_direction();
}
inline const ::naothmessages::DoubleVector2& Edgel::direction() const {
  return direction_ != NULL ? *direction_ : *default_instance_->direction_;
}
inline ::naothmessages::DoubleVector2* Edgel::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) direction_ = new ::naothmessages::DoubleVector2;
  return direction_;
}
inline ::naothmessages::DoubleVector2* Edgel::release_direction() {
  clear_has_direction();
  ::naothmessages::DoubleVector2* temp = direction_;
  direction_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// EdgelPair

// required int32 begin = 1;
inline bool EdgelPair::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EdgelPair::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EdgelPair::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EdgelPair::clear_begin() {
  begin_ = 0;
  clear_has_begin();
}
inline ::google::protobuf::int32 EdgelPair::begin() const {
  return begin_;
}
inline void EdgelPair::set_begin(::google::protobuf::int32 value) {
  set_has_begin();
  begin_ = value;
}

// required int32 end = 2;
inline bool EdgelPair::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EdgelPair::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EdgelPair::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EdgelPair::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 EdgelPair::end() const {
  return end_;
}
inline void EdgelPair::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
}

// required int32 id = 3;
inline bool EdgelPair::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EdgelPair::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EdgelPair::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EdgelPair::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 EdgelPair::id() const {
  return id_;
}
inline void EdgelPair::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ScanLineEdgelPercept

// repeated .naothmessages.Edgel edgels = 1;
inline int ScanLineEdgelPercept::edgels_size() const {
  return edgels_.size();
}
inline void ScanLineEdgelPercept::clear_edgels() {
  edgels_.Clear();
}
inline const ::naothmessages::Edgel& ScanLineEdgelPercept::edgels(int index) const {
  return edgels_.Get(index);
}
inline ::naothmessages::Edgel* ScanLineEdgelPercept::mutable_edgels(int index) {
  return edgels_.Mutable(index);
}
inline ::naothmessages::Edgel* ScanLineEdgelPercept::add_edgels() {
  return edgels_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >&
ScanLineEdgelPercept::edgels() const {
  return edgels_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >*
ScanLineEdgelPercept::mutable_edgels() {
  return &edgels_;
}

// repeated .naothmessages.EdgelPair pairs = 3;
inline int ScanLineEdgelPercept::pairs_size() const {
  return pairs_.size();
}
inline void ScanLineEdgelPercept::clear_pairs() {
  pairs_.Clear();
}
inline const ::naothmessages::EdgelPair& ScanLineEdgelPercept::pairs(int index) const {
  return pairs_.Get(index);
}
inline ::naothmessages::EdgelPair* ScanLineEdgelPercept::mutable_pairs(int index) {
  return pairs_.Mutable(index);
}
inline ::naothmessages::EdgelPair* ScanLineEdgelPercept::add_pairs() {
  return pairs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::EdgelPair >&
ScanLineEdgelPercept::pairs() const {
  return pairs_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::EdgelPair >*
ScanLineEdgelPercept::mutable_pairs() {
  return &pairs_;
}

// repeated .naothmessages.ScanLineEndPoint endPoints = 2;
inline int ScanLineEdgelPercept::endpoints_size() const {
  return endpoints_.size();
}
inline void ScanLineEdgelPercept::clear_endpoints() {
  endpoints_.Clear();
}
inline const ::naothmessages::ScanLineEndPoint& ScanLineEdgelPercept::endpoints(int index) const {
  return endpoints_.Get(index);
}
inline ::naothmessages::ScanLineEndPoint* ScanLineEdgelPercept::mutable_endpoints(int index) {
  return endpoints_.Mutable(index);
}
inline ::naothmessages::ScanLineEndPoint* ScanLineEdgelPercept::add_endpoints() {
  return endpoints_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::ScanLineEndPoint >&
ScanLineEdgelPercept::endpoints() const {
  return endpoints_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::ScanLineEndPoint >*
ScanLineEdgelPercept::mutable_endpoints() {
  return &endpoints_;
}

// -------------------------------------------------------------------

// StepControlStatus

// required uint32 stepID = 1;
inline bool StepControlStatus::has_stepid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StepControlStatus::set_has_stepid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StepControlStatus::clear_has_stepid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StepControlStatus::clear_stepid() {
  stepid_ = 0u;
  clear_has_stepid();
}
inline ::google::protobuf::uint32 StepControlStatus::stepid() const {
  return stepid_;
}
inline void StepControlStatus::set_stepid(::google::protobuf::uint32 value) {
  set_has_stepid();
  stepid_ = value;
}

// required uint32 moveableFoot = 2;
inline bool StepControlStatus::has_moveablefoot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StepControlStatus::set_has_moveablefoot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StepControlStatus::clear_has_moveablefoot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StepControlStatus::clear_moveablefoot() {
  moveablefoot_ = 0u;
  clear_has_moveablefoot();
}
inline ::google::protobuf::uint32 StepControlStatus::moveablefoot() const {
  return moveablefoot_;
}
inline void StepControlStatus::set_moveablefoot(::google::protobuf::uint32 value) {
  set_has_moveablefoot();
  moveablefoot_ = value;
}

// -------------------------------------------------------------------

// MotionStatus

// required uint32 time = 1;
inline bool MotionStatus::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotionStatus::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotionStatus::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MotionStatus::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 MotionStatus::time() const {
  return time_;
}
inline void MotionStatus::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required uint32 lastMotion = 2;
inline bool MotionStatus::has_lastmotion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MotionStatus::set_has_lastmotion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MotionStatus::clear_has_lastmotion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MotionStatus::clear_lastmotion() {
  lastmotion_ = 0u;
  clear_has_lastmotion();
}
inline ::google::protobuf::uint32 MotionStatus::lastmotion() const {
  return lastmotion_;
}
inline void MotionStatus::set_lastmotion(::google::protobuf::uint32 value) {
  set_has_lastmotion();
  lastmotion_ = value;
}

// required uint32 currentMotion = 3;
inline bool MotionStatus::has_currentmotion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotionStatus::set_has_currentmotion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotionStatus::clear_has_currentmotion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MotionStatus::clear_currentmotion() {
  currentmotion_ = 0u;
  clear_has_currentmotion();
}
inline ::google::protobuf::uint32 MotionStatus::currentmotion() const {
  return currentmotion_;
}
inline void MotionStatus::set_currentmotion(::google::protobuf::uint32 value) {
  set_has_currentmotion();
  currentmotion_ = value;
}

// required uint32 headMotion = 4;
inline bool MotionStatus::has_headmotion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotionStatus::set_has_headmotion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotionStatus::clear_has_headmotion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MotionStatus::clear_headmotion() {
  headmotion_ = 0u;
  clear_has_headmotion();
}
inline ::google::protobuf::uint32 MotionStatus::headmotion() const {
  return headmotion_;
}
inline void MotionStatus::set_headmotion(::google::protobuf::uint32 value) {
  set_has_headmotion();
  headmotion_ = value;
}

// required uint32 currentMotionState = 5;
inline bool MotionStatus::has_currentmotionstate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MotionStatus::set_has_currentmotionstate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MotionStatus::clear_has_currentmotionstate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MotionStatus::clear_currentmotionstate() {
  currentmotionstate_ = 0u;
  clear_has_currentmotionstate();
}
inline ::google::protobuf::uint32 MotionStatus::currentmotionstate() const {
  return currentmotionstate_;
}
inline void MotionStatus::set_currentmotionstate(::google::protobuf::uint32 value) {
  set_has_currentmotionstate();
  currentmotionstate_ = value;
}

// required .naothmessages.Pose2D plannedMotionLeftFoot = 6;
inline bool MotionStatus::has_plannedmotionleftfoot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MotionStatus::set_has_plannedmotionleftfoot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MotionStatus::clear_has_plannedmotionleftfoot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MotionStatus::clear_plannedmotionleftfoot() {
  if (plannedmotionleftfoot_ != NULL) plannedmotionleftfoot_->::naothmessages::Pose2D::Clear();
  clear_has_plannedmotionleftfoot();
}
inline const ::naothmessages::Pose2D& MotionStatus::plannedmotionleftfoot() const {
  return plannedmotionleftfoot_ != NULL ? *plannedmotionleftfoot_ : *default_instance_->plannedmotionleftfoot_;
}
inline ::naothmessages::Pose2D* MotionStatus::mutable_plannedmotionleftfoot() {
  set_has_plannedmotionleftfoot();
  if (plannedmotionleftfoot_ == NULL) plannedmotionleftfoot_ = new ::naothmessages::Pose2D;
  return plannedmotionleftfoot_;
}
inline ::naothmessages::Pose2D* MotionStatus::release_plannedmotionleftfoot() {
  clear_has_plannedmotionleftfoot();
  ::naothmessages::Pose2D* temp = plannedmotionleftfoot_;
  plannedmotionleftfoot_ = NULL;
  return temp;
}

// required .naothmessages.Pose2D plannedMotionRightFoot = 7;
inline bool MotionStatus::has_plannedmotionrightfoot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MotionStatus::set_has_plannedmotionrightfoot() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MotionStatus::clear_has_plannedmotionrightfoot() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MotionStatus::clear_plannedmotionrightfoot() {
  if (plannedmotionrightfoot_ != NULL) plannedmotionrightfoot_->::naothmessages::Pose2D::Clear();
  clear_has_plannedmotionrightfoot();
}
inline const ::naothmessages::Pose2D& MotionStatus::plannedmotionrightfoot() const {
  return plannedmotionrightfoot_ != NULL ? *plannedmotionrightfoot_ : *default_instance_->plannedmotionrightfoot_;
}
inline ::naothmessages::Pose2D* MotionStatus::mutable_plannedmotionrightfoot() {
  set_has_plannedmotionrightfoot();
  if (plannedmotionrightfoot_ == NULL) plannedmotionrightfoot_ = new ::naothmessages::Pose2D;
  return plannedmotionrightfoot_;
}
inline ::naothmessages::Pose2D* MotionStatus::release_plannedmotionrightfoot() {
  clear_has_plannedmotionrightfoot();
  ::naothmessages::Pose2D* temp = plannedmotionrightfoot_;
  plannedmotionrightfoot_ = NULL;
  return temp;
}

// required .naothmessages.Pose2D plannedMotionHip = 8;
inline bool MotionStatus::has_plannedmotionhip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MotionStatus::set_has_plannedmotionhip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MotionStatus::clear_has_plannedmotionhip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MotionStatus::clear_plannedmotionhip() {
  if (plannedmotionhip_ != NULL) plannedmotionhip_->::naothmessages::Pose2D::Clear();
  clear_has_plannedmotionhip();
}
inline const ::naothmessages::Pose2D& MotionStatus::plannedmotionhip() const {
  return plannedmotionhip_ != NULL ? *plannedmotionhip_ : *default_instance_->plannedmotionhip_;
}
inline ::naothmessages::Pose2D* MotionStatus::mutable_plannedmotionhip() {
  set_has_plannedmotionhip();
  if (plannedmotionhip_ == NULL) plannedmotionhip_ = new ::naothmessages::Pose2D;
  return plannedmotionhip_;
}
inline ::naothmessages::Pose2D* MotionStatus::release_plannedmotionhip() {
  clear_has_plannedmotionhip();
  ::naothmessages::Pose2D* temp = plannedmotionhip_;
  plannedmotionhip_ = NULL;
  return temp;
}

// optional .naothmessages.StepControlStatus stepControlStatus = 9;
inline bool MotionStatus::has_stepcontrolstatus() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MotionStatus::set_has_stepcontrolstatus() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MotionStatus::clear_has_stepcontrolstatus() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MotionStatus::clear_stepcontrolstatus() {
  if (stepcontrolstatus_ != NULL) stepcontrolstatus_->::naothmessages::StepControlStatus::Clear();
  clear_has_stepcontrolstatus();
}
inline const ::naothmessages::StepControlStatus& MotionStatus::stepcontrolstatus() const {
  return stepcontrolstatus_ != NULL ? *stepcontrolstatus_ : *default_instance_->stepcontrolstatus_;
}
inline ::naothmessages::StepControlStatus* MotionStatus::mutable_stepcontrolstatus() {
  set_has_stepcontrolstatus();
  if (stepcontrolstatus_ == NULL) stepcontrolstatus_ = new ::naothmessages::StepControlStatus;
  return stepcontrolstatus_;
}
inline ::naothmessages::StepControlStatus* MotionStatus::release_stepcontrolstatus() {
  clear_has_stepcontrolstatus();
  ::naothmessages::StepControlStatus* temp = stepcontrolstatus_;
  stepcontrolstatus_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// OdometryData

// required .naothmessages.Pose2D pose = 1;
inline bool OdometryData::has_pose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OdometryData::set_has_pose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OdometryData::clear_has_pose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OdometryData::clear_pose() {
  if (pose_ != NULL) pose_->::naothmessages::Pose2D::Clear();
  clear_has_pose();
}
inline const ::naothmessages::Pose2D& OdometryData::pose() const {
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::naothmessages::Pose2D* OdometryData::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::naothmessages::Pose2D;
  return pose_;
}
inline ::naothmessages::Pose2D* OdometryData::release_pose() {
  clear_has_pose();
  ::naothmessages::Pose2D* temp = pose_;
  pose_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CalibrationData

// optional .naothmessages.DoubleVector2 inertialSensorOffset = 1;
inline bool CalibrationData::has_inertialsensoroffset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalibrationData::set_has_inertialsensoroffset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalibrationData::clear_has_inertialsensoroffset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalibrationData::clear_inertialsensoroffset() {
  if (inertialsensoroffset_ != NULL) inertialsensoroffset_->::naothmessages::DoubleVector2::Clear();
  clear_has_inertialsensoroffset();
}
inline const ::naothmessages::DoubleVector2& CalibrationData::inertialsensoroffset() const {
  return inertialsensoroffset_ != NULL ? *inertialsensoroffset_ : *default_instance_->inertialsensoroffset_;
}
inline ::naothmessages::DoubleVector2* CalibrationData::mutable_inertialsensoroffset() {
  set_has_inertialsensoroffset();
  if (inertialsensoroffset_ == NULL) inertialsensoroffset_ = new ::naothmessages::DoubleVector2;
  return inertialsensoroffset_;
}
inline ::naothmessages::DoubleVector2* CalibrationData::release_inertialsensoroffset() {
  clear_has_inertialsensoroffset();
  ::naothmessages::DoubleVector2* temp = inertialsensoroffset_;
  inertialsensoroffset_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector2 gyroSensorOffset = 2;
inline bool CalibrationData::has_gyrosensoroffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CalibrationData::set_has_gyrosensoroffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CalibrationData::clear_has_gyrosensoroffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CalibrationData::clear_gyrosensoroffset() {
  if (gyrosensoroffset_ != NULL) gyrosensoroffset_->::naothmessages::DoubleVector2::Clear();
  clear_has_gyrosensoroffset();
}
inline const ::naothmessages::DoubleVector2& CalibrationData::gyrosensoroffset() const {
  return gyrosensoroffset_ != NULL ? *gyrosensoroffset_ : *default_instance_->gyrosensoroffset_;
}
inline ::naothmessages::DoubleVector2* CalibrationData::mutable_gyrosensoroffset() {
  set_has_gyrosensoroffset();
  if (gyrosensoroffset_ == NULL) gyrosensoroffset_ = new ::naothmessages::DoubleVector2;
  return gyrosensoroffset_;
}
inline ::naothmessages::DoubleVector2* CalibrationData::release_gyrosensoroffset() {
  clear_has_gyrosensoroffset();
  ::naothmessages::DoubleVector2* temp = gyrosensoroffset_;
  gyrosensoroffset_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector3 accSensorOffset = 3;
inline bool CalibrationData::has_accsensoroffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CalibrationData::set_has_accsensoroffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CalibrationData::clear_has_accsensoroffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CalibrationData::clear_accsensoroffset() {
  if (accsensoroffset_ != NULL) accsensoroffset_->::naothmessages::DoubleVector3::Clear();
  clear_has_accsensoroffset();
}
inline const ::naothmessages::DoubleVector3& CalibrationData::accsensoroffset() const {
  return accsensoroffset_ != NULL ? *accsensoroffset_ : *default_instance_->accsensoroffset_;
}
inline ::naothmessages::DoubleVector3* CalibrationData::mutable_accsensoroffset() {
  set_has_accsensoroffset();
  if (accsensoroffset_ == NULL) accsensoroffset_ = new ::naothmessages::DoubleVector3;
  return accsensoroffset_;
}
inline ::naothmessages::DoubleVector3* CalibrationData::release_accsensoroffset() {
  clear_has_accsensoroffset();
  ::naothmessages::DoubleVector3* temp = accsensoroffset_;
  accsensoroffset_ = NULL;
  return temp;
}

// required bool calibrated = 4;
inline bool CalibrationData::has_calibrated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CalibrationData::set_has_calibrated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CalibrationData::clear_has_calibrated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CalibrationData::clear_calibrated() {
  calibrated_ = false;
  clear_has_calibrated();
}
inline bool CalibrationData::calibrated() const {
  return calibrated_;
}
inline void CalibrationData::set_calibrated(bool value) {
  set_has_calibrated();
  calibrated_ = value;
}

// -------------------------------------------------------------------

// InertialModel

// optional .naothmessages.DoubleVector2 orientation = 1;
inline bool InertialModel::has_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InertialModel::set_has_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InertialModel::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InertialModel::clear_orientation() {
  if (orientation_ != NULL) orientation_->::naothmessages::DoubleVector2::Clear();
  clear_has_orientation();
}
inline const ::naothmessages::DoubleVector2& InertialModel::orientation() const {
  return orientation_ != NULL ? *orientation_ : *default_instance_->orientation_;
}
inline ::naothmessages::DoubleVector2* InertialModel::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) orientation_ = new ::naothmessages::DoubleVector2;
  return orientation_;
}
inline ::naothmessages::DoubleVector2* InertialModel::release_orientation() {
  clear_has_orientation();
  ::naothmessages::DoubleVector2* temp = orientation_;
  orientation_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// TeamMessageCollection

// repeated .naothmessages.TeamMessage data = 1;
inline int TeamMessageCollection::data_size() const {
  return data_.size();
}
inline void TeamMessageCollection::clear_data() {
  data_.Clear();
}
inline const ::naothmessages::TeamMessage& TeamMessageCollection::data(int index) const {
  return data_.Get(index);
}
inline ::naothmessages::TeamMessage* TeamMessageCollection::mutable_data(int index) {
  return data_.Mutable(index);
}
inline ::naothmessages::TeamMessage* TeamMessageCollection::add_data() {
  return data_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::TeamMessage >&
TeamMessageCollection::data() const {
  return data_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::TeamMessage >*
TeamMessageCollection::mutable_data() {
  return &data_;
}

// -------------------------------------------------------------------

// TeamMessage

// optional uint32 playerNum = 1 [default = 0];
inline bool TeamMessage::has_playernum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TeamMessage::set_has_playernum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TeamMessage::clear_has_playernum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TeamMessage::clear_playernum() {
  playernum_ = 0u;
  clear_has_playernum();
}
inline ::google::protobuf::uint32 TeamMessage::playernum() const {
  return playernum_;
}
inline void TeamMessage::set_playernum(::google::protobuf::uint32 value) {
  set_has_playernum();
  playernum_ = value;
}

// optional .naothmessages.TeamColor teamColor = 11 [default = blueTeam];
inline bool TeamMessage::has_teamcolor() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TeamMessage::set_has_teamcolor() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TeamMessage::clear_has_teamcolor() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TeamMessage::clear_teamcolor() {
  teamcolor_ = 0;
  clear_has_teamcolor();
}
inline naothmessages::TeamColor TeamMessage::teamcolor() const {
  return static_cast< naothmessages::TeamColor >(teamcolor_);
}
inline void TeamMessage::set_teamcolor(naothmessages::TeamColor value) {
  GOOGLE_DCHECK(naothmessages::TeamColor_IsValid(value));
  set_has_teamcolor();
  teamcolor_ = value;
}

// optional .naothmessages.Pose2D pose = 3;
inline bool TeamMessage::has_pose() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TeamMessage::set_has_pose() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TeamMessage::clear_has_pose() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TeamMessage::clear_pose() {
  if (pose_ != NULL) pose_->::naothmessages::Pose2D::Clear();
  clear_has_pose();
}
inline const ::naothmessages::Pose2D& TeamMessage::pose() const {
  return pose_ != NULL ? *pose_ : *default_instance_->pose_;
}
inline ::naothmessages::Pose2D* TeamMessage::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) pose_ = new ::naothmessages::Pose2D;
  return pose_;
}
inline ::naothmessages::Pose2D* TeamMessage::release_pose() {
  clear_has_pose();
  ::naothmessages::Pose2D* temp = pose_;
  pose_ = NULL;
  return temp;
}

// optional int32 ballAge = 4 [default = -1];
inline bool TeamMessage::has_ballage() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TeamMessage::set_has_ballage() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TeamMessage::clear_has_ballage() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TeamMessage::clear_ballage() {
  ballage_ = -1;
  clear_has_ballage();
}
inline ::google::protobuf::int32 TeamMessage::ballage() const {
  return ballage_;
}
inline void TeamMessage::set_ballage(::google::protobuf::int32 value) {
  set_has_ballage();
  ballage_ = value;
}

// optional .naothmessages.DoubleVector2 ballPosition = 5;
inline bool TeamMessage::has_ballposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TeamMessage::set_has_ballposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TeamMessage::clear_has_ballposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TeamMessage::clear_ballposition() {
  if (ballposition_ != NULL) ballposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_ballposition();
}
inline const ::naothmessages::DoubleVector2& TeamMessage::ballposition() const {
  return ballposition_ != NULL ? *ballposition_ : *default_instance_->ballposition_;
}
inline ::naothmessages::DoubleVector2* TeamMessage::mutable_ballposition() {
  set_has_ballposition();
  if (ballposition_ == NULL) ballposition_ = new ::naothmessages::DoubleVector2;
  return ballposition_;
}
inline ::naothmessages::DoubleVector2* TeamMessage::release_ballposition() {
  clear_has_ballposition();
  ::naothmessages::DoubleVector2* temp = ballposition_;
  ballposition_ = NULL;
  return temp;
}

// optional .naothmessages.DoubleVector2 ballVelocity = 6;
inline bool TeamMessage::has_ballvelocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TeamMessage::set_has_ballvelocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TeamMessage::clear_has_ballvelocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TeamMessage::clear_ballvelocity() {
  if (ballvelocity_ != NULL) ballvelocity_->::naothmessages::DoubleVector2::Clear();
  clear_has_ballvelocity();
}
inline const ::naothmessages::DoubleVector2& TeamMessage::ballvelocity() const {
  return ballvelocity_ != NULL ? *ballvelocity_ : *default_instance_->ballvelocity_;
}
inline ::naothmessages::DoubleVector2* TeamMessage::mutable_ballvelocity() {
  set_has_ballvelocity();
  if (ballvelocity_ == NULL) ballvelocity_ = new ::naothmessages::DoubleVector2;
  return ballvelocity_;
}
inline ::naothmessages::DoubleVector2* TeamMessage::release_ballvelocity() {
  clear_has_ballvelocity();
  ::naothmessages::DoubleVector2* temp = ballvelocity_;
  ballvelocity_ = NULL;
  return temp;
}

// optional bool fallen = 10 [default = false];
inline bool TeamMessage::has_fallen() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TeamMessage::set_has_fallen() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TeamMessage::clear_has_fallen() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TeamMessage::clear_fallen() {
  fallen_ = false;
  clear_has_fallen();
}
inline bool TeamMessage::fallen() const {
  return fallen_;
}
inline void TeamMessage::set_fallen(bool value) {
  set_has_fallen();
  fallen_ = value;
}

// optional .naothmessages.BUUserTeamMessage user = 8;
inline bool TeamMessage::has_user() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TeamMessage::set_has_user() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TeamMessage::clear_has_user() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TeamMessage::clear_user() {
  if (user_ != NULL) user_->::naothmessages::BUUserTeamMessage::Clear();
  clear_has_user();
}
inline const ::naothmessages::BUUserTeamMessage& TeamMessage::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::naothmessages::BUUserTeamMessage* TeamMessage::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::naothmessages::BUUserTeamMessage;
  return user_;
}
inline ::naothmessages::BUUserTeamMessage* TeamMessage::release_user() {
  clear_has_user();
  ::naothmessages::BUUserTeamMessage* temp = user_;
  user_ = NULL;
  return temp;
}

// optional .naothmessages.FrameInfo frameInfo = 9;
inline bool TeamMessage::has_frameinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TeamMessage::set_has_frameinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TeamMessage::clear_has_frameinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TeamMessage::clear_frameinfo() {
  if (frameinfo_ != NULL) frameinfo_->::naothmessages::FrameInfo::Clear();
  clear_has_frameinfo();
}
inline const ::naothmessages::FrameInfo& TeamMessage::frameinfo() const {
  return frameinfo_ != NULL ? *frameinfo_ : *default_instance_->frameinfo_;
}
inline ::naothmessages::FrameInfo* TeamMessage::mutable_frameinfo() {
  set_has_frameinfo();
  if (frameinfo_ == NULL) frameinfo_ = new ::naothmessages::FrameInfo;
  return frameinfo_;
}
inline ::naothmessages::FrameInfo* TeamMessage::release_frameinfo() {
  clear_has_frameinfo();
  ::naothmessages::FrameInfo* temp = frameinfo_;
  frameinfo_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// BUUserTeamMessage

// optional string bodyID = 1 [default = "unknown"];
inline bool BUUserTeamMessage::has_bodyid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BUUserTeamMessage::set_has_bodyid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BUUserTeamMessage::clear_has_bodyid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BUUserTeamMessage::clear_bodyid() {
  if (bodyid_ != &_default_bodyid_) {
    bodyid_->assign(_default_bodyid_);
  }
  clear_has_bodyid();
}
inline const ::std::string& BUUserTeamMessage::bodyid() const {
  return *bodyid_;
}
inline void BUUserTeamMessage::set_bodyid(const ::std::string& value) {
  set_has_bodyid();
  if (bodyid_ == &_default_bodyid_) {
    bodyid_ = new ::std::string;
  }
  bodyid_->assign(value);
}
inline void BUUserTeamMessage::set_bodyid(const char* value) {
  set_has_bodyid();
  if (bodyid_ == &_default_bodyid_) {
    bodyid_ = new ::std::string;
  }
  bodyid_->assign(value);
}
inline void BUUserTeamMessage::set_bodyid(const char* value, size_t size) {
  set_has_bodyid();
  if (bodyid_ == &_default_bodyid_) {
    bodyid_ = new ::std::string;
  }
  bodyid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BUUserTeamMessage::mutable_bodyid() {
  set_has_bodyid();
  if (bodyid_ == &_default_bodyid_) {
    bodyid_ = new ::std::string(_default_bodyid_);
  }
  return bodyid_;
}
inline ::std::string* BUUserTeamMessage::release_bodyid() {
  clear_has_bodyid();
  if (bodyid_ == &_default_bodyid_) {
    return NULL;
  } else {
    ::std::string* temp = bodyid_;
    bodyid_ = const_cast< ::std::string*>(&_default_bodyid_);
    return temp;
  }
}

// optional uint32 timeToBall = 2;
inline bool BUUserTeamMessage::has_timetoball() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BUUserTeamMessage::set_has_timetoball() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BUUserTeamMessage::clear_has_timetoball() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BUUserTeamMessage::clear_timetoball() {
  timetoball_ = 0u;
  clear_has_timetoball();
}
inline ::google::protobuf::uint32 BUUserTeamMessage::timetoball() const {
  return timetoball_;
}
inline void BUUserTeamMessage::set_timetoball(::google::protobuf::uint32 value) {
  set_has_timetoball();
  timetoball_ = value;
}

// optional bool wasStriker = 3 [default = false];
inline bool BUUserTeamMessage::has_wasstriker() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BUUserTeamMessage::set_has_wasstriker() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BUUserTeamMessage::clear_has_wasstriker() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BUUserTeamMessage::clear_wasstriker() {
  wasstriker_ = false;
  clear_has_wasstriker();
}
inline bool BUUserTeamMessage::wasstriker() const {
  return wasstriker_;
}
inline void BUUserTeamMessage::set_wasstriker(bool value) {
  set_has_wasstriker();
  wasstriker_ = value;
}

// optional bool isPenalized = 4 [default = false];
inline bool BUUserTeamMessage::has_ispenalized() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BUUserTeamMessage::set_has_ispenalized() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BUUserTeamMessage::clear_has_ispenalized() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BUUserTeamMessage::clear_ispenalized() {
  ispenalized_ = false;
  clear_has_ispenalized();
}
inline bool BUUserTeamMessage::ispenalized() const {
  return ispenalized_;
}
inline void BUUserTeamMessage::set_ispenalized(bool value) {
  set_has_ispenalized();
  ispenalized_ = value;
}

// repeated .naothmessages.Opponent opponents = 5;
inline int BUUserTeamMessage::opponents_size() const {
  return opponents_.size();
}
inline void BUUserTeamMessage::clear_opponents() {
  opponents_.Clear();
}
inline const ::naothmessages::Opponent& BUUserTeamMessage::opponents(int index) const {
  return opponents_.Get(index);
}
inline ::naothmessages::Opponent* BUUserTeamMessage::mutable_opponents(int index) {
  return opponents_.Mutable(index);
}
inline ::naothmessages::Opponent* BUUserTeamMessage::add_opponents() {
  return opponents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Opponent >&
BUUserTeamMessage::opponents() const {
  return opponents_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Opponent >*
BUUserTeamMessage::mutable_opponents() {
  return &opponents_;
}

// optional uint32 teamNumber = 6 [default = 0];
inline bool BUUserTeamMessage::has_teamnumber() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BUUserTeamMessage::set_has_teamnumber() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BUUserTeamMessage::clear_has_teamnumber() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BUUserTeamMessage::clear_teamnumber() {
  teamnumber_ = 0u;
  clear_has_teamnumber();
}
inline ::google::protobuf::uint32 BUUserTeamMessage::teamnumber() const {
  return teamnumber_;
}
inline void BUUserTeamMessage::set_teamnumber(::google::protobuf::uint32 value) {
  set_has_teamnumber();
  teamnumber_ = value;
}

// optional float batteryCharge = 7 [default = 1];
inline bool BUUserTeamMessage::has_batterycharge() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BUUserTeamMessage::set_has_batterycharge() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BUUserTeamMessage::clear_has_batterycharge() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BUUserTeamMessage::clear_batterycharge() {
  batterycharge_ = 1;
  clear_has_batterycharge();
}
inline float BUUserTeamMessage::batterycharge() const {
  return batterycharge_;
}
inline void BUUserTeamMessage::set_batterycharge(float value) {
  set_has_batterycharge();
  batterycharge_ = value;
}

// optional float temperature = 8 [default = 0];
inline bool BUUserTeamMessage::has_temperature() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void BUUserTeamMessage::set_has_temperature() {
  _has_bits_[0] |= 0x00000080u;
}
inline void BUUserTeamMessage::clear_has_temperature() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void BUUserTeamMessage::clear_temperature() {
  temperature_ = 0;
  clear_has_temperature();
}
inline float BUUserTeamMessage::temperature() const {
  return temperature_;
}
inline void BUUserTeamMessage::set_temperature(float value) {
  set_has_temperature();
  temperature_ = value;
}

// optional uint64 timestamp = 9 [default = 0];
inline bool BUUserTeamMessage::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void BUUserTeamMessage::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
inline void BUUserTeamMessage::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void BUUserTeamMessage::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 BUUserTeamMessage::timestamp() const {
  return timestamp_;
}
inline void BUUserTeamMessage::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// Opponent

// required int32 playerNum = 1 [default = 0];
inline bool Opponent::has_playernum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Opponent::set_has_playernum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Opponent::clear_has_playernum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Opponent::clear_playernum() {
  playernum_ = 0;
  clear_has_playernum();
}
inline ::google::protobuf::int32 Opponent::playernum() const {
  return playernum_;
}
inline void Opponent::set_playernum(::google::protobuf::int32 value) {
  set_has_playernum();
  playernum_ = value;
}

// optional .naothmessages.Pose2D poseOnField = 2;
inline bool Opponent::has_poseonfield() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Opponent::set_has_poseonfield() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Opponent::clear_has_poseonfield() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Opponent::clear_poseonfield() {
  if (poseonfield_ != NULL) poseonfield_->::naothmessages::Pose2D::Clear();
  clear_has_poseonfield();
}
inline const ::naothmessages::Pose2D& Opponent::poseonfield() const {
  return poseonfield_ != NULL ? *poseonfield_ : *default_instance_->poseonfield_;
}
inline ::naothmessages::Pose2D* Opponent::mutable_poseonfield() {
  set_has_poseonfield();
  if (poseonfield_ == NULL) poseonfield_ = new ::naothmessages::Pose2D;
  return poseonfield_;
}
inline ::naothmessages::Pose2D* Opponent::release_poseonfield() {
  clear_has_poseonfield();
  ::naothmessages::Pose2D* temp = poseonfield_;
  poseonfield_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// CameraMatrixCalibration

// repeated .naothmessages.DoubleVector2 correctionOffset = 1;
inline int CameraMatrixCalibration::correctionoffset_size() const {
  return correctionoffset_.size();
}
inline void CameraMatrixCalibration::clear_correctionoffset() {
  correctionoffset_.Clear();
}
inline const ::naothmessages::DoubleVector2& CameraMatrixCalibration::correctionoffset(int index) const {
  return correctionoffset_.Get(index);
}
inline ::naothmessages::DoubleVector2* CameraMatrixCalibration::mutable_correctionoffset(int index) {
  return correctionoffset_.Mutable(index);
}
inline ::naothmessages::DoubleVector2* CameraMatrixCalibration::add_correctionoffset() {
  return correctionoffset_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
CameraMatrixCalibration::correctionoffset() const {
  return correctionoffset_;
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
CameraMatrixCalibration::mutable_correctionoffset() {
  return &correctionoffset_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace naothmessages

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< naothmessages::TeamColor>() {
  return naothmessages::TeamColor_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Representations_2eproto__INCLUDED


// added by NaoTH 
#if defined(__GNUC__) && defined(_NAOTH_CHECK_CONVERSION_)
#if __GNUC__ > 3 && __GNUC_MINOR__ > 5
#pragma GCC diagnostic pop
#else
#pragma GCC diagnostic error "-Wconversion"
#endif
#endif

