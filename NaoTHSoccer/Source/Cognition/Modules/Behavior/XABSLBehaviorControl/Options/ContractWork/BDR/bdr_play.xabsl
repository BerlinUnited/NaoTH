option bdr_play
{
  /** temperature which shouldn't be exceeded */
  float @min_temperature;
  float @max_temperature; //[70..90] "°";

  /** temperature increase until wartung */
  float @inc_temperature; //[2 - 10] "°"
  float @offset_max_temp_reached;

  /** battery percentage which shouldn't be fallen below */
  float @min_battery; // [0.3-0.5] "%";
  float @max_battery;

  /** battery percentage decrease until wartung */
  float @dec_battery; //[0.02 - 0.05] "°"
  float @offset_min_battery_reached;

  common decision
  {
    if(body.falling)
        goto fallen;
    else if(!body.ready_to_walk || game.current_mode != playing)
        goto idle;
  }
  
  initial state idle{
    decision{
      else
        goto localize;
    } 
    action{
        bdr.message = ready;
        bdr.reason = none; // init reason
        bdr.activity = initializing;
        bdr.localized_on_field = false;
    }
  }

  state fallen{
      decision{
          else
              stay;
      }

      action{
          bdr.message = fallen;
          bdr.reason = none; // init reason
          bdr.activity = initializing;
          bdr.localized_on_field = false;
      }
              
  }
  
  state localize
  {
    decision
    {
      else if(robot_pose.is_valid && executed_motion.time > 5000)
        goto transition;
      else
        stay;
    }
    action
    {
        motion.type = stand;
        head.control_mode = look_around;
        situationStatusOwnHalf = last_state_was_penalized;
        bdr.activity = initializing;   

        bdr.charge_beginning = platform.battery;
        bdr.temperature_beginning = max(value0 = body.temperature.leg.left, value1 = body.temperature.leg.right);
    }
  }

  state do_nothing
  {
    decision
    {
      else if(remote_control.bdr_control != DO_NOTHING)
        goto transition;
      else
        stay;
    }
    action
    {
      motion.type = stand;    
      motion.walk.stop_with_stand=true;        
      head.control_mode = search_for_ball_and_look_around;
      bdr.activity = doing_nothing;
    }
  }

  state pre_autonomous_entertaining {
      decision {
          else if (action_done)
              goto autonomous_entertaining;
          else
              stay;
      }

      action {
          situation_abortable = true;
          bdr_goto_point(x = -600, y = 0, rot = 0);
          head.control_mode = search_for_ball_and_look_around;

          bdr.activity = pre_entertaining;
      }
  }

  state autonomous_entertaining {
      decision {
          else if(remote_control.bdr_control != AUTONOMOUS_PLAY)
              goto transition;
          else if (body.temperature.leg.left > bdr.temperature_beginning + @inc_temperature
                   || body.temperature.leg.right > bdr.temperature_beginning + @inc_temperature)
              goto pre_wartung_reason_temperature;
          else if (platform.battery < bdr.charge_beginning - @dec_battery)
              goto pre_wartung_reason_battery;
          else if (bdr.number_of_players_in_play == 1) // other player is waiting for me
              goto transition;
          else
              stay;
      }

      action {
          bdr.activity = entertaining;
          motion.type = bdr_entertainment;
      }
  }

  state pre_autonomous_play {
      decision {
          else if (action_done)
              goto autonomous_play;
          else
              stay;
      }

      action {
          situation_abortable = true;
          bdr_goto_point(x = -600, y = 0, rot = 0);
          head.control_mode = search_for_ball_and_look_around;

          bdr.activity = pre_playing;
      }
  }

  state autonomous_play
  {
    decision
    {
      else if(action_done)
          goto post_autonomous_play;
      else if(bdr.number_of_players_in_play == 1
              && state_time > 10000)
          goto pre_autonomous_entertaining; 
      else
          stay;
    }
    action
    {
        bdr_play_soccer_synchronized();
        bdr.activity = playing;
        bdr.reason = none;
    }
  }

  state post_autonomous_play
  {
    decision
    {
      else if(remote_control.bdr_control != AUTONOMOUS_PLAY)
          goto transition;
      else if (body.temperature.leg.left >  bdr.temperature_beginning + @inc_temperature
               || body.temperature.leg.right >  bdr.temperature_beginning + @inc_temperature)
          goto pre_wartung_reason_temperature;
      else if (platform.battery < bdr.charge_beginning - @dec_battery)
          goto pre_wartung_reason_battery;
      else
          goto pre_autonomous_play;
    }

    action
    {
      motion.type = stand;
      head.control_mode = search_for_ball_and_look_around;
    }
  }

  state wartung_by_operator {
      decision {
          else if (remote_control.bdr_control != WARTUNG)
              goto localize_after_wartung;
          else
              stay;
      }

      action {
          bdr.reason = none;
          // bdr.activity = pre_servicing // is set by suboption
          bdr_goto_charging_station();
      }
  }

  state pre_wartung_reason_temperature{
      decision {
          else
              goto wartung_reason_temperature;
      }
      action {
          bdr.reason = temperature;
          bdr.message = cooling_down_needed;
          bdr.charge_beginning = platform.battery;
          bdr.temperature_beginning = max(value0 = body.temperature.leg.left, value1 = body.temperature.leg.right);
          bdr.activity = pre_servicing;
      }
  }
  
  state wartung_reason_temperature{
      decision {
          else if(body.temperature.leg.left < @min_temperature
                  && body.temperature.leg.right < @min_temperature){
              goto localize_after_wartung;
          } else if(bdr.temperature_beginning > @max_temperature){
              if(body.temperature.leg.left < bdr.temperature_beginning - @inc_temperature - @offset_max_temp_reached
                 && body.temperature.leg.right < bdr.temperature_beginning - @inc_temperature - @offset_max_temp_reached)
                  goto localize_after_wartung;
              else
                  stay;
          } else {
              if(body.temperature.leg.left < bdr.temperature_beginning - @inc_temperature
                  && body.temperature.leg.right < bdr.temperature_beginning - @inc_temperature)
                  goto localize_after_wartung;
              else
                  stay;
          }
      }

      action{
        // bdr.activity = pre_servicing // is set by suboption
        bdr_goto_charging_station();
        bdr.wartung_max_target = min(value0 = bdr.temperature_beginning - @inc_temperature - @offset_max_temp_reached,
                                     value1 = bdr.temperature_beginning - @inc_temperature - @offset_max_temp_reached);
      }
  }

  state pre_wartung_reason_battery{
      decision {
          else
              goto wartung_reason_battery;
      }
      action {
          bdr.reason  = battery_charge;
          bdr.message = charging_needed;
          bdr.charge_beginning = platform.battery;
          bdr.temperature_beginning = max(value0 = body.temperature.leg.left, value1 = body.temperature.leg.right);
          bdr.activity = pre_servicing;
      }
  }

  state wartung_reason_battery{
    decision
    {
          else if(platform.battery > @max_battery)
              goto localize_after_wartung;
          else if(bdr.charge_beginning < @min_battery){
              if(platform.battery > bdr.charge_beginning + @dec_battery + @offset_min_battery_reached)
                  goto localize_after_wartung;
              else
                  stay;
          } else {
              if(platform.battery > (bdr.charge_beginning + @dec_battery))
                  goto localize_after_wartung;
              else
                  stay;
          }
    }
    action
    {
        // bdr.activity = pre_servicing // is set by suboption
        bdr_goto_charging_station();
        bdr.wartung_max_target = bdr.charge_beginning + @dec_battery + @offset_min_battery_reached;
    }
  }

  state localize_after_wartung
  {
    decision
    {
      else if(executed_motion.type == stand && executed_motion.time > 5000)
        goto transition;
      else
        stay;
    }
    action
    {
        motion.type = stand;
        head.control_mode = search_for_ball_and_look_around;
        bdr.reason = none; // reset wartungs reason
        bdr.activity = initializing;
        bdr.sitting = false;
        bdr.message = ready;

        bdr.charge_beginning = platform.battery;
        bdr.temperature_beginning = max(value0 = body.temperature.leg.left, value1 = body.temperature.leg.right);
    }
  }

  state transition
  {
      decision
      {
          else if(executed_motion.type == stand
                  || state_time > 1000)
          {
            if(bdr.reason == battery_charge)
                goto pre_wartung_reason_battery;
            else if(bdr.reason == temperature)
                goto pre_wartung_reason_temperature;
            else if(remote_control.bdr_control == DO_NOTHING)
                goto do_nothing;
            else if(remote_control.bdr_control == AUTONOMOUS_PLAY) {
                if(bdr.number_of_players_in_play == 1
                   && bdr.activity != playing)
                    goto pre_autonomous_play;
                else if (bdr.number_of_players_in_play == 1
                         && bdr.activity == playing)
                    goto pre_autonomous_entertaining;
                else
                    goto pre_autonomous_play;
            }
            else if(remote_control.bdr_control == WARTUNG)
                goto wartung_by_operator;
            else
                stay;
          }
          else 
              stay;
      }

      action
      {
        motion.type = stand;
    
        motion.walk.stop_with_stand=false;
        
        head.control_mode = none;
        head.point_in_world.x = 200;
        head.point_in_world.y = 0;
        head.point_in_world.z = 0;
        head.motion_type = look_at_world_point;

        bdr.localized_on_field = true; // TODO: need some criteria like #Lines, error of matching after localization etc.
      }
  }
}