option bdr_goto_charging_station
{

  initial state wait {
      decision {
          if(state_time < 2000)
            stay;
          else
            goto approach;
      }

      action {
          head.control_mode = look_around;
          motion.type = stand;
          bdr.activity = pre_servicing;
          bdr.sit_down_counter = 0;
      }
  }

  state approach {
      decision {
        if(action_done)
          goto wait_and_localize;
        else
          stay;
      }

      action {
          head.control_mode = look_around;
          bdr_goto_point(
            x = -265, 
            y = (robot_pose.is_mirrored?-450:450), 
            rot = (robot_pose.is_mirrored?90:-90)
            );
          motion.walk.style = stable;
      }
  }

  state wait_and_localize{
      decision {
          if(state_time > 10000) {
              goto approach_very_slowly;
          }
          else
              stay;
      }
      
      action{
          motion.type = stand;
          head.control_mode = look_around;
      }
  }

  state approach_very_slowly{
      decision{
          if (action_done)
              goto sit;
          else
              stay;
      }

      action {
            head.control_mode = look_around;
            bdr_align_carefully(
              x = -265, 
              y = (robot_pose.is_mirrored?-620:620), 
              rot = (robot_pose.is_mirrored?90:-90));
      }
  }

  state sit {
      decision {
        if(executed_motion.type == bdr_sit)
          goto wait_and_check_for_connection;
        else
          stay;
      }

      action {
          motion.type = bdr_sit;
      }
  }

  state wait_and_check_for_connection {
      decision {
        //TODO: use some kind of symbol indicating that the sit motion was reached?
        if(state_time > 10000){ 
          if(battery.isDischarging)
              goto increase_counter;
          else 
              goto done;
        }
        else
            stay;
      }

      action {
          motion.type = bdr_sit;
      }
  }

  state increase_counter{
      decision {
          if(bdr.sit_down_counter > 3)
              goto failed;
          else
              goto stand_up_again;
      }

      action {
          motion.type = bdr_sit;
          bdr.sit_down_counter = bdr.sit_down_counter + 1;
      }
  }

  state stand_up_again {
      decision
      {
        if(executed_motion.type == stand && executed_motion.time > 5000)
          //goto approach_very_slowly; // Wunsch von Olaf... die Beobachtung war, dass sie gut ausgerichtet sind nach dem ersten Setzen
          goto sit;
        else
          stay;
      }
        
	  action
	  {
	      motion.type = stand;
	      head.control_mode = look_around;
	  }
  }

  state failed {
      decision {
          if(!battery.isDischarging)
              goto done;
          else if (state_time > 7000)
              goto stand_up_before_reapproach;
          else 
              stay;
      }

      action{
          motion.type  = bdr_sit;
          bdr.message = failed_charging;
          bdr.sit_down_counter = 0;
      }
  }

  state stand_up_before_reapproach {
    decision
    {
      if(executed_motion.type == stand && executed_motion.time > 5000)
        //goto approach_very_slowly; // Wunsch von Olaf... die Beobachtung war, dass sie gut ausgerichtet sind nach dem ersten Setzen
        goto approach;
      else
        stay;
    }
        
    action
    {
        motion.type = stand;
        head.control_mode = look_around;
    }
  }

  target state done {
      decision {
        stay;
      }

      action {
          motion.type  = bdr_sit;
          bdr.activity = servicing;
          bdr.sitting  = true;
          bdr.message  = charging;
      }
  }

}