/** Go to a specific position on the field */
option bdr_align_carefully
{
  /** x position of the point to walk to on the field */
  float @x; //[-4500..4500] "mm";

  /** y position of the point to walk to on the field */
  float @y; // [-3000..3000] "mm";

  /** absolute rotation on field */
  float @rot; // -180...180 "deg";

  state move
  {
    decision
    {
      if (   vector.abs(x=robot_pose.planned.x - @x, y=robot_pose.planned.y - @y) < 10
          && abs(value=robot_pose.planned.rotation - @rot) < 5
          && vector.abs(x=executed_motion.planed.target.x, y=executed_motion.planed.target.y) < 5
          && abs(value=executed_motion.planed.target.rotation) < 5 )
        goto stop;
      else
        stay;
    }
    action
    {
      motion.type = walk;
      motion.walk.style = stable;
      motion.walk_speed.rot = normalize(angle=atan2(y = @y - robot_pose.planned.y, x = @x - robot_pose.planned.x) - robot_pose.planned.rotation);
      motion.walk_speed.x = 0.5 * vector.abs(x = @x - robot_pose.planned.x, y = @y - robot_pose.planned.y) * cos(angle=motion.walk_speed.rot);
      motion.walk_speed.y = vector.abs(x = @x - robot_pose.planned.x, y = @y - robot_pose.planned.y) * sin(angle=motion.walk_speed.rot);
      motion.walk_speed.rot = normalize(angle=(@rot - robot_pose.planned.rotation));
      motion.walk.coordinate = hip;
      motion.walk.stop_with_stand = true;
    }

  }

  initial target state stop
  {
    decision
    {
      if ( vector.abs(x=robot_pose.planned.x - @x, y=robot_pose.planned.y - @y) > 20 )
        goto move;
      else
        stay;
    }
    action
    {
      motion.type = stand;
    }
  }   
}
