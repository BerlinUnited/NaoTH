option path_turn_to_attack_direction
{
  initial state decide {
    decision{
    // This is potentially bad since now a path routine can be intererupted 
      if(attack.direction.preview > 0 && obstacle.ultrasound.distance > 400)
        goto turn_right_around;
      else if (attack.direction.preview > 0 && obstacle.ultrasound.distance <= 400)
        goto turn_right_around_stable;
      else if (attack.direction.preview <= 0 && obstacle.ultrasound.distance <= 400)
        goto turn_left_around_stable;
      else
        goto turn_left_around;
    }
    action{
    }
  }

  state turn_right_around {
    decision {
      stay;
    }
    action {
      path_move_around_ball(direction=attack.direction.preview, radius=210, stable=false);
      //motion.walk.style = fast;
    }
  }

  state turn_right_around_stable {
    decision {
      stay;
    }
    action {
      path_move_around_ball(direction=attack.direction.preview, radius=210, stable=true);
      //motion.walk.style = fast;
    }
  }


  state turn_left_around {
    decision {
      stay;
    }
    action {
      path_move_around_ball(direction=attack.direction.preview, radius=210, stable=false);
      //motion.walk.style = fast;
    }
  }

  state turn_left_around_stable {
    decision {
      stay;
    }
    action {
      path_move_around_ball(direction=attack.direction.preview, radius=210, stable=true);
      //motion.walk.style = fast;
    }
  }

}