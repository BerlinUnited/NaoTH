// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Representations.proto

#ifndef PROTOBUF_Representations_2eproto__INCLUDED
#define PROTOBUF_Representations_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3004000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "CommonTypes.pb.h"
#include "Framework-Representations.pb.h"
// @@protoc_insertion_point(includes)
namespace naothmessages {
class ArmMotionRequest;
class ArmMotionRequestDefaultTypeInternal;
extern ArmMotionRequestDefaultTypeInternal _ArmMotionRequest_default_instance_;
class BallCandidates;
class BallCandidatesDefaultTypeInternal;
extern BallCandidatesDefaultTypeInternal _BallCandidates_default_instance_;
class BallCandidates_Patch;
class BallCandidates_PatchDefaultTypeInternal;
extern BallCandidates_PatchDefaultTypeInternal _BallCandidates_Patch_default_instance_;
class BallModel;
class BallModelDefaultTypeInternal;
extern BallModelDefaultTypeInternal _BallModel_default_instance_;
class BallPercept;
class BallPerceptDefaultTypeInternal;
extern BallPerceptDefaultTypeInternal _BallPercept_default_instance_;
class BodyState;
class BodyStateDefaultTypeInternal;
extern BodyStateDefaultTypeInternal _BodyState_default_instance_;
class BodyStatus;
class BodyStatusDefaultTypeInternal;
extern BodyStatusDefaultTypeInternal _BodyStatus_default_instance_;
class CalibrationData;
class CalibrationDataDefaultTypeInternal;
extern CalibrationDataDefaultTypeInternal _CalibrationData_default_instance_;
class CalibrationDataCMC;
class CalibrationDataCMCDefaultTypeInternal;
extern CalibrationDataCMCDefaultTypeInternal _CalibrationDataCMC_default_instance_;
class CalibrationDataCMC_CalibrationDataSampleV3;
class CalibrationDataCMC_CalibrationDataSampleV3DefaultTypeInternal;
extern CalibrationDataCMC_CalibrationDataSampleV3DefaultTypeInternal _CalibrationDataCMC_CalibrationDataSampleV3_default_instance_;
class CameraMatrix;
class CameraMatrixDefaultTypeInternal;
extern CameraMatrixDefaultTypeInternal _CameraMatrix_default_instance_;
class CameraMatrixCalibration;
class CameraMatrixCalibrationDefaultTypeInternal;
extern CameraMatrixCalibrationDefaultTypeInternal _CameraMatrixCalibration_default_instance_;
class CentreOfPressure;
class CentreOfPressureDefaultTypeInternal;
extern CentreOfPressureDefaultTypeInternal _CentreOfPressure_default_instance_;
class CollisionPercept;
class CollisionPerceptDefaultTypeInternal;
extern CollisionPerceptDefaultTypeInternal _CollisionPercept_default_instance_;
class DebugModify;
class DebugModifyDefaultTypeInternal;
extern DebugModifyDefaultTypeInternal _DebugModify_default_instance_;
class DebugModify_ModifyValue;
class DebugModify_ModifyValueDefaultTypeInternal;
extern DebugModify_ModifyValueDefaultTypeInternal _DebugModify_ModifyValue_default_instance_;
class DoubleEdgel;
class DoubleEdgelDefaultTypeInternal;
extern DoubleEdgelDefaultTypeInternal _DoubleEdgel_default_instance_;
class Edgel;
class EdgelDefaultTypeInternal;
extern EdgelDefaultTypeInternal _Edgel_default_instance_;
class EdgelPair;
class EdgelPairDefaultTypeInternal;
extern EdgelPairDefaultTypeInternal _EdgelPair_default_instance_;
class FieldPercept;
class FieldPerceptDefaultTypeInternal;
extern FieldPerceptDefaultTypeInternal _FieldPercept_default_instance_;
class GoalPercept;
class GoalPerceptDefaultTypeInternal;
extern GoalPerceptDefaultTypeInternal _GoalPercept_default_instance_;
class GoalPercept_GoalPost;
class GoalPercept_GoalPostDefaultTypeInternal;
extern GoalPercept_GoalPostDefaultTypeInternal _GoalPercept_GoalPost_default_instance_;
class GraspRequest;
class GraspRequestDefaultTypeInternal;
extern GraspRequestDefaultTypeInternal _GraspRequest_default_instance_;
class GroundContactModel;
class GroundContactModelDefaultTypeInternal;
extern GroundContactModelDefaultTypeInternal _GroundContactModel_default_instance_;
class HeadMotionRequest;
class HeadMotionRequestDefaultTypeInternal;
extern HeadMotionRequestDefaultTypeInternal _HeadMotionRequest_default_instance_;
class IMUData;
class IMUDataDefaultTypeInternal;
extern IMUDataDefaultTypeInternal _IMUData_default_instance_;
class InertialModel;
class InertialModelDefaultTypeInternal;
extern InertialModelDefaultTypeInternal _InertialModel_default_instance_;
class KickRequest;
class KickRequestDefaultTypeInternal;
extern KickRequestDefaultTypeInternal _KickRequest_default_instance_;
class LineGraphPercept;
class LineGraphPerceptDefaultTypeInternal;
extern LineGraphPerceptDefaultTypeInternal _LineGraphPercept_default_instance_;
class LinePercept;
class LinePerceptDefaultTypeInternal;
extern LinePerceptDefaultTypeInternal _LinePercept_default_instance_;
class LinePercept_FieldLineSegment;
class LinePercept_FieldLineSegmentDefaultTypeInternal;
extern LinePercept_FieldLineSegmentDefaultTypeInternal _LinePercept_FieldLineSegment_default_instance_;
class LinePercept_Intersection;
class LinePercept_IntersectionDefaultTypeInternal;
extern LinePercept_IntersectionDefaultTypeInternal _LinePercept_Intersection_default_instance_;
class MotionRequest;
class MotionRequestDefaultTypeInternal;
extern MotionRequestDefaultTypeInternal _MotionRequest_default_instance_;
class MotionStatus;
class MotionStatusDefaultTypeInternal;
extern MotionStatusDefaultTypeInternal _MotionStatus_default_instance_;
class MultiBallPercept;
class MultiBallPerceptDefaultTypeInternal;
extern MultiBallPerceptDefaultTypeInternal _MultiBallPercept_default_instance_;
class MultiBallPercept_BallPercept;
class MultiBallPercept_BallPerceptDefaultTypeInternal;
extern MultiBallPercept_BallPerceptDefaultTypeInternal _MultiBallPercept_BallPercept_default_instance_;
class OdometryData;
class OdometryDataDefaultTypeInternal;
extern OdometryDataDefaultTypeInternal _OdometryData_default_instance_;
class Polygon;
class PolygonDefaultTypeInternal;
extern PolygonDefaultTypeInternal _Polygon_default_instance_;
class RansacCirclePercept2018;
class RansacCirclePercept2018DefaultTypeInternal;
extern RansacCirclePercept2018DefaultTypeInternal _RansacCirclePercept2018_default_instance_;
class RansacLinePercept;
class RansacLinePerceptDefaultTypeInternal;
extern RansacLinePerceptDefaultTypeInternal _RansacLinePercept_default_instance_;
class RemoteControlCommand;
class RemoteControlCommandDefaultTypeInternal;
extern RemoteControlCommandDefaultTypeInternal _RemoteControlCommand_default_instance_;
class ScanLineEdgelPercept;
class ScanLineEdgelPerceptDefaultTypeInternal;
extern ScanLineEdgelPerceptDefaultTypeInternal _ScanLineEdgelPercept_default_instance_;
class ScanLineEndPoint;
class ScanLineEndPointDefaultTypeInternal;
extern ScanLineEndPointDefaultTypeInternal _ScanLineEndPoint_default_instance_;
class ShortLinePercept;
class ShortLinePerceptDefaultTypeInternal;
extern ShortLinePerceptDefaultTypeInternal _ShortLinePercept_default_instance_;
class StepBuffer;
class StepBufferDefaultTypeInternal;
extern StepBufferDefaultTypeInternal _StepBuffer_default_instance_;
class StepControlRequest;
class StepControlRequestDefaultTypeInternal;
extern StepControlRequestDefaultTypeInternal _StepControlRequest_default_instance_;
class StepControlStatus;
class StepControlStatusDefaultTypeInternal;
extern StepControlStatusDefaultTypeInternal _StepControlStatus_default_instance_;
class WalkRequest;
class WalkRequestDefaultTypeInternal;
extern WalkRequestDefaultTypeInternal _WalkRequest_default_instance_;
class WhistlePercept;
class WhistlePerceptDefaultTypeInternal;
extern WhistlePerceptDefaultTypeInternal _WhistlePercept_default_instance_;
class WhistlePercept_Whistle;
class WhistlePercept_WhistleDefaultTypeInternal;
extern WhistlePercept_WhistleDefaultTypeInternal _WhistlePercept_Whistle_default_instance_;
class bodyAwareness;
class bodyAwarenessDefaultTypeInternal;
extern bodyAwarenessDefaultTypeInternal _bodyAwareness_default_instance_;
}  // namespace naothmessages

namespace naothmessages {

namespace protobuf_Representations_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static void InitDefaultsImpl();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_Representations_2eproto

enum GoalPercept_GoalPost_PostType {
  GoalPercept_GoalPost_PostType_rightPost = 0,
  GoalPercept_GoalPost_PostType_leftPost = 1,
  GoalPercept_GoalPost_PostType_unknownPost = 2
};
bool GoalPercept_GoalPost_PostType_IsValid(int value);
const GoalPercept_GoalPost_PostType GoalPercept_GoalPost_PostType_PostType_MIN = GoalPercept_GoalPost_PostType_rightPost;
const GoalPercept_GoalPost_PostType GoalPercept_GoalPost_PostType_PostType_MAX = GoalPercept_GoalPost_PostType_unknownPost;
const int GoalPercept_GoalPost_PostType_PostType_ARRAYSIZE = GoalPercept_GoalPost_PostType_PostType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GoalPercept_GoalPost_PostType_descriptor();
inline const ::std::string& GoalPercept_GoalPost_PostType_Name(GoalPercept_GoalPost_PostType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GoalPercept_GoalPost_PostType_descriptor(), value);
}
inline bool GoalPercept_GoalPost_PostType_Parse(
    const ::std::string& name, GoalPercept_GoalPost_PostType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GoalPercept_GoalPost_PostType>(
    GoalPercept_GoalPost_PostType_descriptor(), name, value);
}
enum StepControlRequest_StepType {
  StepControlRequest_StepType_WALKSTEP = 0,
  StepControlRequest_StepType_KICKSTEP = 1,
  StepControlRequest_StepType_ZEROSTEP = 2
};
bool StepControlRequest_StepType_IsValid(int value);
const StepControlRequest_StepType StepControlRequest_StepType_StepType_MIN = StepControlRequest_StepType_WALKSTEP;
const StepControlRequest_StepType StepControlRequest_StepType_StepType_MAX = StepControlRequest_StepType_ZEROSTEP;
const int StepControlRequest_StepType_StepType_ARRAYSIZE = StepControlRequest_StepType_StepType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StepControlRequest_StepType_descriptor();
inline const ::std::string& StepControlRequest_StepType_Name(StepControlRequest_StepType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StepControlRequest_StepType_descriptor(), value);
}
inline bool StepControlRequest_StepType_Parse(
    const ::std::string& name, StepControlRequest_StepType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StepControlRequest_StepType>(
    StepControlRequest_StepType_descriptor(), name, value);
}
enum StepControlRequest_RestrictionMode {
  StepControlRequest_RestrictionMode_HARD = 0,
  StepControlRequest_RestrictionMode_SOFT = 1
};
bool StepControlRequest_RestrictionMode_IsValid(int value);
const StepControlRequest_RestrictionMode StepControlRequest_RestrictionMode_RestrictionMode_MIN = StepControlRequest_RestrictionMode_HARD;
const StepControlRequest_RestrictionMode StepControlRequest_RestrictionMode_RestrictionMode_MAX = StepControlRequest_RestrictionMode_SOFT;
const int StepControlRequest_RestrictionMode_RestrictionMode_ARRAYSIZE = StepControlRequest_RestrictionMode_RestrictionMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* StepControlRequest_RestrictionMode_descriptor();
inline const ::std::string& StepControlRequest_RestrictionMode_Name(StepControlRequest_RestrictionMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    StepControlRequest_RestrictionMode_descriptor(), value);
}
inline bool StepControlRequest_RestrictionMode_Parse(
    const ::std::string& name, StepControlRequest_RestrictionMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StepControlRequest_RestrictionMode>(
    StepControlRequest_RestrictionMode_descriptor(), name, value);
}
enum LinePercept_Intersection_IntersectionType {
  LinePercept_Intersection_IntersectionType_unknown = 0,
  LinePercept_Intersection_IntersectionType_T = 1,
  LinePercept_Intersection_IntersectionType_L = 2,
  LinePercept_Intersection_IntersectionType_C = 3,
  LinePercept_Intersection_IntersectionType_none = 4,
  LinePercept_Intersection_IntersectionType_X = 5
};
bool LinePercept_Intersection_IntersectionType_IsValid(int value);
const LinePercept_Intersection_IntersectionType LinePercept_Intersection_IntersectionType_IntersectionType_MIN = LinePercept_Intersection_IntersectionType_unknown;
const LinePercept_Intersection_IntersectionType LinePercept_Intersection_IntersectionType_IntersectionType_MAX = LinePercept_Intersection_IntersectionType_X;
const int LinePercept_Intersection_IntersectionType_IntersectionType_ARRAYSIZE = LinePercept_Intersection_IntersectionType_IntersectionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LinePercept_Intersection_IntersectionType_descriptor();
inline const ::std::string& LinePercept_Intersection_IntersectionType_Name(LinePercept_Intersection_IntersectionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LinePercept_Intersection_IntersectionType_descriptor(), value);
}
inline bool LinePercept_Intersection_IntersectionType_Parse(
    const ::std::string& name, LinePercept_Intersection_IntersectionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LinePercept_Intersection_IntersectionType>(
    LinePercept_Intersection_IntersectionType_descriptor(), name, value);
}
enum BallCandidates_Patch_Type {
  BallCandidates_Patch_Type_Y = 0,
  BallCandidates_Patch_Type_YUV = 1,
  BallCandidates_Patch_Type_YUVC = 2
};
bool BallCandidates_Patch_Type_IsValid(int value);
const BallCandidates_Patch_Type BallCandidates_Patch_Type_Type_MIN = BallCandidates_Patch_Type_Y;
const BallCandidates_Patch_Type BallCandidates_Patch_Type_Type_MAX = BallCandidates_Patch_Type_YUVC;
const int BallCandidates_Patch_Type_Type_ARRAYSIZE = BallCandidates_Patch_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* BallCandidates_Patch_Type_descriptor();
inline const ::std::string& BallCandidates_Patch_Type_Name(BallCandidates_Patch_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    BallCandidates_Patch_Type_descriptor(), value);
}
inline bool BallCandidates_Patch_Type_Parse(
    const ::std::string& name, BallCandidates_Patch_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BallCandidates_Patch_Type>(
    BallCandidates_Patch_Type_descriptor(), name, value);
}
enum RemoteControlCommand_ControlMode {
  RemoteControlCommand_ControlMode_DIRECT_CONTROL = 0,
  RemoteControlCommand_ControlMode_LOCK_CONTROL = 1
};
bool RemoteControlCommand_ControlMode_IsValid(int value);
const RemoteControlCommand_ControlMode RemoteControlCommand_ControlMode_ControlMode_MIN = RemoteControlCommand_ControlMode_DIRECT_CONTROL;
const RemoteControlCommand_ControlMode RemoteControlCommand_ControlMode_ControlMode_MAX = RemoteControlCommand_ControlMode_LOCK_CONTROL;
const int RemoteControlCommand_ControlMode_ControlMode_ARRAYSIZE = RemoteControlCommand_ControlMode_ControlMode_MAX + 1;

const ::google::protobuf::EnumDescriptor* RemoteControlCommand_ControlMode_descriptor();
inline const ::std::string& RemoteControlCommand_ControlMode_Name(RemoteControlCommand_ControlMode value) {
  return ::google::protobuf::internal::NameOfEnum(
    RemoteControlCommand_ControlMode_descriptor(), value);
}
inline bool RemoteControlCommand_ControlMode_Parse(
    const ::std::string& name, RemoteControlCommand_ControlMode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RemoteControlCommand_ControlMode>(
    RemoteControlCommand_ControlMode_descriptor(), name, value);
}
enum RemoteControlCommand_ActionType {
  RemoteControlCommand_ActionType_NONE = 0,
  RemoteControlCommand_ActionType_STAND = 1,
  RemoteControlCommand_ActionType_WALK = 2,
  RemoteControlCommand_ActionType_KICK_RIGHT = 3,
  RemoteControlCommand_ActionType_KICK_LEFT = 4,
  RemoteControlCommand_ActionType_KICK_FORWARD_LEFT = 5,
  RemoteControlCommand_ActionType_KICK_FORWARD_RIGHT = 6
};
bool RemoteControlCommand_ActionType_IsValid(int value);
const RemoteControlCommand_ActionType RemoteControlCommand_ActionType_ActionType_MIN = RemoteControlCommand_ActionType_NONE;
const RemoteControlCommand_ActionType RemoteControlCommand_ActionType_ActionType_MAX = RemoteControlCommand_ActionType_KICK_FORWARD_RIGHT;
const int RemoteControlCommand_ActionType_ActionType_ARRAYSIZE = RemoteControlCommand_ActionType_ActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RemoteControlCommand_ActionType_descriptor();
inline const ::std::string& RemoteControlCommand_ActionType_Name(RemoteControlCommand_ActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RemoteControlCommand_ActionType_descriptor(), value);
}
inline bool RemoteControlCommand_ActionType_Parse(
    const ::std::string& name, RemoteControlCommand_ActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RemoteControlCommand_ActionType>(
    RemoteControlCommand_ActionType_descriptor(), name, value);
}
enum RemoteControlCommand_SecondActionType {
  RemoteControlCommand_SecondActionType_SECOND_NONE = 0,
  RemoteControlCommand_SecondActionType_BLINK = 1,
  RemoteControlCommand_SecondActionType_SAY = 2
};
bool RemoteControlCommand_SecondActionType_IsValid(int value);
const RemoteControlCommand_SecondActionType RemoteControlCommand_SecondActionType_SecondActionType_MIN = RemoteControlCommand_SecondActionType_SECOND_NONE;
const RemoteControlCommand_SecondActionType RemoteControlCommand_SecondActionType_SecondActionType_MAX = RemoteControlCommand_SecondActionType_SAY;
const int RemoteControlCommand_SecondActionType_SecondActionType_ARRAYSIZE = RemoteControlCommand_SecondActionType_SecondActionType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RemoteControlCommand_SecondActionType_descriptor();
inline const ::std::string& RemoteControlCommand_SecondActionType_Name(RemoteControlCommand_SecondActionType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RemoteControlCommand_SecondActionType_descriptor(), value);
}
inline bool RemoteControlCommand_SecondActionType_Parse(
    const ::std::string& name, RemoteControlCommand_SecondActionType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RemoteControlCommand_SecondActionType>(
    RemoteControlCommand_SecondActionType_descriptor(), name, value);
}
enum GroundContactModel_Foot {
  GroundContactModel_Foot_LEFT = 0,
  GroundContactModel_Foot_RIGHT = 1,
  GroundContactModel_Foot_NONE = 2
};
bool GroundContactModel_Foot_IsValid(int value);
const GroundContactModel_Foot GroundContactModel_Foot_Foot_MIN = GroundContactModel_Foot_LEFT;
const GroundContactModel_Foot GroundContactModel_Foot_Foot_MAX = GroundContactModel_Foot_NONE;
const int GroundContactModel_Foot_Foot_ARRAYSIZE = GroundContactModel_Foot_Foot_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroundContactModel_Foot_descriptor();
inline const ::std::string& GroundContactModel_Foot_Name(GroundContactModel_Foot value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroundContactModel_Foot_descriptor(), value);
}
inline bool GroundContactModel_Foot_Parse(
    const ::std::string& name, GroundContactModel_Foot* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroundContactModel_Foot>(
    GroundContactModel_Foot_descriptor(), name, value);
}
// ===================================================================

class CameraMatrix : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.CameraMatrix) */ {
 public:
  CameraMatrix();
  virtual ~CameraMatrix();

  CameraMatrix(const CameraMatrix& from);

  inline CameraMatrix& operator=(const CameraMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraMatrix(CameraMatrix&& from) noexcept
    : CameraMatrix() {
    *this = ::std::move(from);
  }

  inline CameraMatrix& operator=(CameraMatrix&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraMatrix& default_instance();

  static inline const CameraMatrix* internal_default_instance() {
    return reinterpret_cast<const CameraMatrix*>(
               &_CameraMatrix_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(CameraMatrix* other);
  friend void swap(CameraMatrix& a, CameraMatrix& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraMatrix* New() const PROTOBUF_FINAL { return New(NULL); }

  CameraMatrix* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CameraMatrix& from);
  void MergeFrom(const CameraMatrix& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CameraMatrix* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.Pose3D pose = 1;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 1;
  const ::naothmessages::Pose3D& pose() const;
  ::naothmessages::Pose3D* mutable_pose();
  ::naothmessages::Pose3D* release_pose();
  void set_allocated_pose(::naothmessages::Pose3D* pose);

  // optional bool valid = 3;
  bool has_valid() const;
  void clear_valid();
  static const int kValidFieldNumber = 3;
  bool valid() const;
  void set_valid(bool value);

  // optional uint32 timestamp = 4;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // optional .naothmessages.CameraID cameraID = 2 [default = bottom];
  bool has_cameraid() const;
  void clear_cameraid();
  static const int kCameraIDFieldNumber = 2;
  ::naothmessages::CameraID cameraid() const;
  void set_cameraid(::naothmessages::CameraID value);

  // @@protoc_insertion_point(class_scope:naothmessages.CameraMatrix)
 private:
  void set_has_pose();
  void clear_has_pose();
  void set_has_cameraid();
  void clear_has_cameraid();
  void set_has_valid();
  void clear_has_valid();
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::Pose3D* pose_;
  bool valid_;
  ::google::protobuf::uint32 timestamp_;
  int cameraid_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BallPercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.BallPercept) */ {
 public:
  BallPercept();
  virtual ~BallPercept();

  BallPercept(const BallPercept& from);

  inline BallPercept& operator=(const BallPercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BallPercept(BallPercept&& from) noexcept
    : BallPercept() {
    *this = ::std::move(from);
  }

  inline BallPercept& operator=(BallPercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallPercept& default_instance();

  static inline const BallPercept* internal_default_instance() {
    return reinterpret_cast<const BallPercept*>(
               &_BallPercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(BallPercept* other);
  friend void swap(BallPercept& a, BallPercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BallPercept* New() const PROTOBUF_FINAL { return New(NULL); }

  BallPercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BallPercept& from);
  void MergeFrom(const BallPercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BallPercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.DoubleVector2 centerInImage = 2;
  bool has_centerinimage() const;
  void clear_centerinimage();
  static const int kCenterInImageFieldNumber = 2;
  const ::naothmessages::DoubleVector2& centerinimage() const;
  ::naothmessages::DoubleVector2* mutable_centerinimage();
  ::naothmessages::DoubleVector2* release_centerinimage();
  void set_allocated_centerinimage(::naothmessages::DoubleVector2* centerinimage);

  // optional .naothmessages.DoubleVector2 bearingBasedOffsetOnField = 5;
  bool has_bearingbasedoffsetonfield() const;
  void clear_bearingbasedoffsetonfield();
  static const int kBearingBasedOffsetOnFieldFieldNumber = 5;
  const ::naothmessages::DoubleVector2& bearingbasedoffsetonfield() const;
  ::naothmessages::DoubleVector2* mutable_bearingbasedoffsetonfield();
  ::naothmessages::DoubleVector2* release_bearingbasedoffsetonfield();
  void set_allocated_bearingbasedoffsetonfield(::naothmessages::DoubleVector2* bearingbasedoffsetonfield);

  // optional .naothmessages.FrameInfo frameInfoWhenBallWasSeen = 6;
  bool has_frameinfowhenballwasseen() const;
  void clear_frameinfowhenballwasseen();
  static const int kFrameInfoWhenBallWasSeenFieldNumber = 6;
  const ::naothmessages::FrameInfo& frameinfowhenballwasseen() const;
  ::naothmessages::FrameInfo* mutable_frameinfowhenballwasseen();
  ::naothmessages::FrameInfo* release_frameinfowhenballwasseen();
  void set_allocated_frameinfowhenballwasseen(::naothmessages::FrameInfo* frameinfowhenballwasseen);

  // optional bool ballWasSeen = 1;
  bool has_ballwasseen() const;
  void clear_ballwasseen();
  static const int kBallWasSeenFieldNumber = 1;
  bool ballwasseen() const;
  void set_ballwasseen(bool value);

  // optional .naothmessages.Color ballColor = 4;
  bool has_ballcolor() const;
  void clear_ballcolor();
  static const int kBallColorFieldNumber = 4;
  ::naothmessages::Color ballcolor() const;
  void set_ballcolor(::naothmessages::Color value);

  // optional double radiusInImage = 3;
  bool has_radiusinimage() const;
  void clear_radiusinimage();
  static const int kRadiusInImageFieldNumber = 3;
  double radiusinimage() const;
  void set_radiusinimage(double value);

  // @@protoc_insertion_point(class_scope:naothmessages.BallPercept)
 private:
  void set_has_ballwasseen();
  void clear_has_ballwasseen();
  void set_has_centerinimage();
  void clear_has_centerinimage();
  void set_has_radiusinimage();
  void clear_has_radiusinimage();
  void set_has_ballcolor();
  void clear_has_ballcolor();
  void set_has_bearingbasedoffsetonfield();
  void clear_has_bearingbasedoffsetonfield();
  void set_has_frameinfowhenballwasseen();
  void clear_has_frameinfowhenballwasseen();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector2* centerinimage_;
  ::naothmessages::DoubleVector2* bearingbasedoffsetonfield_;
  ::naothmessages::FrameInfo* frameinfowhenballwasseen_;
  bool ballwasseen_;
  int ballcolor_;
  double radiusinimage_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiBallPercept_BallPercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.MultiBallPercept.BallPercept) */ {
 public:
  MultiBallPercept_BallPercept();
  virtual ~MultiBallPercept_BallPercept();

  MultiBallPercept_BallPercept(const MultiBallPercept_BallPercept& from);

  inline MultiBallPercept_BallPercept& operator=(const MultiBallPercept_BallPercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiBallPercept_BallPercept(MultiBallPercept_BallPercept&& from) noexcept
    : MultiBallPercept_BallPercept() {
    *this = ::std::move(from);
  }

  inline MultiBallPercept_BallPercept& operator=(MultiBallPercept_BallPercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiBallPercept_BallPercept& default_instance();

  static inline const MultiBallPercept_BallPercept* internal_default_instance() {
    return reinterpret_cast<const MultiBallPercept_BallPercept*>(
               &_MultiBallPercept_BallPercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(MultiBallPercept_BallPercept* other);
  friend void swap(MultiBallPercept_BallPercept& a, MultiBallPercept_BallPercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiBallPercept_BallPercept* New() const PROTOBUF_FINAL { return New(NULL); }

  MultiBallPercept_BallPercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MultiBallPercept_BallPercept& from);
  void MergeFrom(const MultiBallPercept_BallPercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MultiBallPercept_BallPercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.DoubleVector2 centerInImage = 1;
  bool has_centerinimage() const;
  void clear_centerinimage();
  static const int kCenterInImageFieldNumber = 1;
  const ::naothmessages::DoubleVector2& centerinimage() const;
  ::naothmessages::DoubleVector2* mutable_centerinimage();
  ::naothmessages::DoubleVector2* release_centerinimage();
  void set_allocated_centerinimage(::naothmessages::DoubleVector2* centerinimage);

  // optional .naothmessages.DoubleVector2 positionOnField = 3;
  bool has_positiononfield() const;
  void clear_positiononfield();
  static const int kPositionOnFieldFieldNumber = 3;
  const ::naothmessages::DoubleVector2& positiononfield() const;
  ::naothmessages::DoubleVector2* mutable_positiononfield();
  ::naothmessages::DoubleVector2* release_positiononfield();
  void set_allocated_positiononfield(::naothmessages::DoubleVector2* positiononfield);

  // optional double radiusInImage = 2;
  bool has_radiusinimage() const;
  void clear_radiusinimage();
  static const int kRadiusInImageFieldNumber = 2;
  double radiusinimage() const;
  void set_radiusinimage(double value);

  // optional .naothmessages.CameraID cameraId = 4;
  bool has_cameraid() const;
  void clear_cameraid();
  static const int kCameraIdFieldNumber = 4;
  ::naothmessages::CameraID cameraid() const;
  void set_cameraid(::naothmessages::CameraID value);

  // @@protoc_insertion_point(class_scope:naothmessages.MultiBallPercept.BallPercept)
 private:
  void set_has_centerinimage();
  void clear_has_centerinimage();
  void set_has_radiusinimage();
  void clear_has_radiusinimage();
  void set_has_positiononfield();
  void clear_has_positiononfield();
  void set_has_cameraid();
  void clear_has_cameraid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector2* centerinimage_;
  ::naothmessages::DoubleVector2* positiononfield_;
  double radiusinimage_;
  int cameraid_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiBallPercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.MultiBallPercept) */ {
 public:
  MultiBallPercept();
  virtual ~MultiBallPercept();

  MultiBallPercept(const MultiBallPercept& from);

  inline MultiBallPercept& operator=(const MultiBallPercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiBallPercept(MultiBallPercept&& from) noexcept
    : MultiBallPercept() {
    *this = ::std::move(from);
  }

  inline MultiBallPercept& operator=(MultiBallPercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiBallPercept& default_instance();

  static inline const MultiBallPercept* internal_default_instance() {
    return reinterpret_cast<const MultiBallPercept*>(
               &_MultiBallPercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(MultiBallPercept* other);
  friend void swap(MultiBallPercept& a, MultiBallPercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiBallPercept* New() const PROTOBUF_FINAL { return New(NULL); }

  MultiBallPercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MultiBallPercept& from);
  void MergeFrom(const MultiBallPercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MultiBallPercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MultiBallPercept_BallPercept BallPercept;

  // accessors -------------------------------------------------------

  // repeated .naothmessages.MultiBallPercept.BallPercept percepts = 2;
  int percepts_size() const;
  void clear_percepts();
  static const int kPerceptsFieldNumber = 2;
  const ::naothmessages::MultiBallPercept_BallPercept& percepts(int index) const;
  ::naothmessages::MultiBallPercept_BallPercept* mutable_percepts(int index);
  ::naothmessages::MultiBallPercept_BallPercept* add_percepts();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::MultiBallPercept_BallPercept >*
      mutable_percepts();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::MultiBallPercept_BallPercept >&
      percepts() const;

  // optional .naothmessages.FrameInfo frameInfoWhenBallWasSeen = 1;
  bool has_frameinfowhenballwasseen() const;
  void clear_frameinfowhenballwasseen();
  static const int kFrameInfoWhenBallWasSeenFieldNumber = 1;
  const ::naothmessages::FrameInfo& frameinfowhenballwasseen() const;
  ::naothmessages::FrameInfo* mutable_frameinfowhenballwasseen();
  ::naothmessages::FrameInfo* release_frameinfowhenballwasseen();
  void set_allocated_frameinfowhenballwasseen(::naothmessages::FrameInfo* frameinfowhenballwasseen);

  // @@protoc_insertion_point(class_scope:naothmessages.MultiBallPercept)
 private:
  void set_has_frameinfowhenballwasseen();
  void clear_has_frameinfowhenballwasseen();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::MultiBallPercept_BallPercept > percepts_;
  ::naothmessages::FrameInfo* frameinfowhenballwasseen_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BallModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.BallModel) */ {
 public:
  BallModel();
  virtual ~BallModel();

  BallModel(const BallModel& from);

  inline BallModel& operator=(const BallModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BallModel(BallModel&& from) noexcept
    : BallModel() {
    *this = ::std::move(from);
  }

  inline BallModel& operator=(BallModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallModel& default_instance();

  static inline const BallModel* internal_default_instance() {
    return reinterpret_cast<const BallModel*>(
               &_BallModel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(BallModel* other);
  friend void swap(BallModel& a, BallModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BallModel* New() const PROTOBUF_FINAL { return New(NULL); }

  BallModel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BallModel& from);
  void MergeFrom(const BallModel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BallModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .naothmessages.DoubleVector2 futurePosition = 8 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR int futureposition_size() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_futureposition();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kFuturePositionFieldNumber = 8;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::naothmessages::DoubleVector2& futureposition(int index) const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::naothmessages::DoubleVector2* mutable_futureposition(int index);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::naothmessages::DoubleVector2* add_futureposition();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
      mutable_futureposition();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
      futureposition() const;

  // optional .naothmessages.DoubleVector2 position = 3;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 3;
  const ::naothmessages::DoubleVector2& position() const;
  ::naothmessages::DoubleVector2* mutable_position();
  ::naothmessages::DoubleVector2* release_position();
  void set_allocated_position(::naothmessages::DoubleVector2* position);

  // optional .naothmessages.DoubleVector2 speed = 4;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 4;
  const ::naothmessages::DoubleVector2& speed() const;
  ::naothmessages::DoubleVector2* mutable_speed();
  ::naothmessages::DoubleVector2* release_speed();
  void set_allocated_speed(::naothmessages::DoubleVector2* speed);

  // optional .naothmessages.DoubleVector2 positionPreview = 5;
  bool has_positionpreview() const;
  void clear_positionpreview();
  static const int kPositionPreviewFieldNumber = 5;
  const ::naothmessages::DoubleVector2& positionpreview() const;
  ::naothmessages::DoubleVector2* mutable_positionpreview();
  ::naothmessages::DoubleVector2* release_positionpreview();
  void set_allocated_positionpreview(::naothmessages::DoubleVector2* positionpreview);

  // optional .naothmessages.DoubleVector2 positionPreviewInLFoot = 6;
  bool has_positionpreviewinlfoot() const;
  void clear_positionpreviewinlfoot();
  static const int kPositionPreviewInLFootFieldNumber = 6;
  const ::naothmessages::DoubleVector2& positionpreviewinlfoot() const;
  ::naothmessages::DoubleVector2* mutable_positionpreviewinlfoot();
  ::naothmessages::DoubleVector2* release_positionpreviewinlfoot();
  void set_allocated_positionpreviewinlfoot(::naothmessages::DoubleVector2* positionpreviewinlfoot);

  // optional .naothmessages.DoubleVector2 positionPreviewInRFoot = 7;
  bool has_positionpreviewinrfoot() const;
  void clear_positionpreviewinrfoot();
  static const int kPositionPreviewInRFootFieldNumber = 7;
  const ::naothmessages::DoubleVector2& positionpreviewinrfoot() const;
  ::naothmessages::DoubleVector2* mutable_positionpreviewinrfoot();
  ::naothmessages::DoubleVector2* release_positionpreviewinrfoot();
  void set_allocated_positionpreviewinrfoot(::naothmessages::DoubleVector2* positionpreviewinrfoot);

  // optional bool valid = 1;
  bool has_valid() const;
  void clear_valid();
  static const int kValidFieldNumber = 1;
  bool valid() const;
  void set_valid(bool value);

  // optional bool knows = 2;
  bool has_knows() const;
  void clear_knows();
  static const int kKnowsFieldNumber = 2;
  bool knows() const;
  void set_knows(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.BallModel)
 private:
  void set_has_valid();
  void clear_has_valid();
  void set_has_knows();
  void clear_has_knows();
  void set_has_position();
  void clear_has_position();
  void set_has_speed();
  void clear_has_speed();
  void set_has_positionpreview();
  void clear_has_positionpreview();
  void set_has_positionpreviewinlfoot();
  void clear_has_positionpreviewinlfoot();
  void set_has_positionpreviewinrfoot();
  void clear_has_positionpreviewinrfoot();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 > futureposition_;
  ::naothmessages::DoubleVector2* position_;
  ::naothmessages::DoubleVector2* speed_;
  ::naothmessages::DoubleVector2* positionpreview_;
  ::naothmessages::DoubleVector2* positionpreviewinlfoot_;
  ::naothmessages::DoubleVector2* positionpreviewinrfoot_;
  bool valid_;
  bool knows_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GoalPercept_GoalPost : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.GoalPercept.GoalPost) */ {
 public:
  GoalPercept_GoalPost();
  virtual ~GoalPercept_GoalPost();

  GoalPercept_GoalPost(const GoalPercept_GoalPost& from);

  inline GoalPercept_GoalPost& operator=(const GoalPercept_GoalPost& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GoalPercept_GoalPost(GoalPercept_GoalPost&& from) noexcept
    : GoalPercept_GoalPost() {
    *this = ::std::move(from);
  }

  inline GoalPercept_GoalPost& operator=(GoalPercept_GoalPost&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoalPercept_GoalPost& default_instance();

  static inline const GoalPercept_GoalPost* internal_default_instance() {
    return reinterpret_cast<const GoalPercept_GoalPost*>(
               &_GoalPercept_GoalPost_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(GoalPercept_GoalPost* other);
  friend void swap(GoalPercept_GoalPost& a, GoalPercept_GoalPost& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GoalPercept_GoalPost* New() const PROTOBUF_FINAL { return New(NULL); }

  GoalPercept_GoalPost* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GoalPercept_GoalPost& from);
  void MergeFrom(const GoalPercept_GoalPost& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GoalPercept_GoalPost* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef GoalPercept_GoalPost_PostType PostType;
  static const PostType rightPost =
    GoalPercept_GoalPost_PostType_rightPost;
  static const PostType leftPost =
    GoalPercept_GoalPost_PostType_leftPost;
  static const PostType unknownPost =
    GoalPercept_GoalPost_PostType_unknownPost;
  static inline bool PostType_IsValid(int value) {
    return GoalPercept_GoalPost_PostType_IsValid(value);
  }
  static const PostType PostType_MIN =
    GoalPercept_GoalPost_PostType_PostType_MIN;
  static const PostType PostType_MAX =
    GoalPercept_GoalPost_PostType_PostType_MAX;
  static const int PostType_ARRAYSIZE =
    GoalPercept_GoalPost_PostType_PostType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PostType_descriptor() {
    return GoalPercept_GoalPost_PostType_descriptor();
  }
  static inline const ::std::string& PostType_Name(PostType value) {
    return GoalPercept_GoalPost_PostType_Name(value);
  }
  static inline bool PostType_Parse(const ::std::string& name,
      PostType* value) {
    return GoalPercept_GoalPost_PostType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .naothmessages.IntVector2 basePoint = 1;
  bool has_basepoint() const;
  void clear_basepoint();
  static const int kBasePointFieldNumber = 1;
  const ::naothmessages::IntVector2& basepoint() const;
  ::naothmessages::IntVector2* mutable_basepoint();
  ::naothmessages::IntVector2* release_basepoint();
  void set_allocated_basepoint(::naothmessages::IntVector2* basepoint);

  // optional .naothmessages.DoubleVector2 position = 2;
  bool has_position() const;
  void clear_position();
  static const int kPositionFieldNumber = 2;
  const ::naothmessages::DoubleVector2& position() const;
  ::naothmessages::DoubleVector2* mutable_position();
  ::naothmessages::DoubleVector2* release_position();
  void set_allocated_position(::naothmessages::DoubleVector2* position);

  // optional .naothmessages.Color color = 3;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 3;
  ::naothmessages::Color color() const;
  void set_color(::naothmessages::Color value);

  // optional .naothmessages.GoalPercept.GoalPost.PostType type = 4;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 4;
  ::naothmessages::GoalPercept_GoalPost_PostType type() const;
  void set_type(::naothmessages::GoalPercept_GoalPost_PostType value);

  // optional double seenHeight = 6;
  bool has_seenheight() const;
  void clear_seenheight();
  static const int kSeenHeightFieldNumber = 6;
  double seenheight() const;
  void set_seenheight(double value);

  // optional bool positionReliable = 5;
  bool has_positionreliable() const;
  void clear_positionreliable();
  static const int kPositionReliableFieldNumber = 5;
  bool positionreliable() const;
  void set_positionreliable(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.GoalPercept.GoalPost)
 private:
  void set_has_basepoint();
  void clear_has_basepoint();
  void set_has_position();
  void clear_has_position();
  void set_has_color();
  void clear_has_color();
  void set_has_type();
  void clear_has_type();
  void set_has_positionreliable();
  void clear_has_positionreliable();
  void set_has_seenheight();
  void clear_has_seenheight();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::IntVector2* basepoint_;
  ::naothmessages::DoubleVector2* position_;
  int color_;
  int type_;
  double seenheight_;
  bool positionreliable_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GoalPercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.GoalPercept) */ {
 public:
  GoalPercept();
  virtual ~GoalPercept();

  GoalPercept(const GoalPercept& from);

  inline GoalPercept& operator=(const GoalPercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GoalPercept(GoalPercept&& from) noexcept
    : GoalPercept() {
    *this = ::std::move(from);
  }

  inline GoalPercept& operator=(GoalPercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GoalPercept& default_instance();

  static inline const GoalPercept* internal_default_instance() {
    return reinterpret_cast<const GoalPercept*>(
               &_GoalPercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(GoalPercept* other);
  friend void swap(GoalPercept& a, GoalPercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GoalPercept* New() const PROTOBUF_FINAL { return New(NULL); }

  GoalPercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GoalPercept& from);
  void MergeFrom(const GoalPercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GoalPercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef GoalPercept_GoalPost GoalPost;

  // accessors -------------------------------------------------------

  // repeated .naothmessages.GoalPercept.GoalPost post = 4;
  int post_size() const;
  void clear_post();
  static const int kPostFieldNumber = 4;
  const ::naothmessages::GoalPercept_GoalPost& post(int index) const;
  ::naothmessages::GoalPercept_GoalPost* mutable_post(int index);
  ::naothmessages::GoalPercept_GoalPost* add_post();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::GoalPercept_GoalPost >*
      mutable_post();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::GoalPercept_GoalPost >&
      post() const;

  // optional .naothmessages.DoubleVector3 goalCentroid = 2;
  bool has_goalcentroid() const;
  void clear_goalcentroid();
  static const int kGoalCentroidFieldNumber = 2;
  const ::naothmessages::DoubleVector3& goalcentroid() const;
  ::naothmessages::DoubleVector3* mutable_goalcentroid();
  ::naothmessages::DoubleVector3* release_goalcentroid();
  void set_allocated_goalcentroid(::naothmessages::DoubleVector3* goalcentroid);

  // optional double angleToSeenGoal = 1;
  bool has_angletoseengoal() const;
  void clear_angletoseengoal();
  static const int kAngleToSeenGoalFieldNumber = 1;
  double angletoseengoal() const;
  void set_angletoseengoal(double value);

  // optional int32 numberOfSeenPosts = 3;
  bool has_numberofseenposts() const;
  void clear_numberofseenposts();
  static const int kNumberOfSeenPostsFieldNumber = 3;
  ::google::protobuf::int32 numberofseenposts() const;
  void set_numberofseenposts(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:naothmessages.GoalPercept)
 private:
  void set_has_angletoseengoal();
  void clear_has_angletoseengoal();
  void set_has_goalcentroid();
  void clear_has_goalcentroid();
  void set_has_numberofseenposts();
  void clear_has_numberofseenposts();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::GoalPercept_GoalPost > post_;
  ::naothmessages::DoubleVector3* goalcentroid_;
  double angletoseengoal_;
  ::google::protobuf::int32 numberofseenposts_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeadMotionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.HeadMotionRequest) */ {
 public:
  HeadMotionRequest();
  virtual ~HeadMotionRequest();

  HeadMotionRequest(const HeadMotionRequest& from);

  inline HeadMotionRequest& operator=(const HeadMotionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeadMotionRequest(HeadMotionRequest&& from) noexcept
    : HeadMotionRequest() {
    *this = ::std::move(from);
  }

  inline HeadMotionRequest& operator=(HeadMotionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeadMotionRequest& default_instance();

  static inline const HeadMotionRequest* internal_default_instance() {
    return reinterpret_cast<const HeadMotionRequest*>(
               &_HeadMotionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(HeadMotionRequest* other);
  friend void swap(HeadMotionRequest& a, HeadMotionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeadMotionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  HeadMotionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const HeadMotionRequest& from);
  void MergeFrom(const HeadMotionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(HeadMotionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.DoubleVector2 targetJointPosition = 3;
  bool has_targetjointposition() const;
  void clear_targetjointposition();
  static const int kTargetJointPositionFieldNumber = 3;
  const ::naothmessages::DoubleVector2& targetjointposition() const;
  ::naothmessages::DoubleVector2* mutable_targetjointposition();
  ::naothmessages::DoubleVector2* release_targetjointposition();
  void set_allocated_targetjointposition(::naothmessages::DoubleVector2* targetjointposition);

  // optional .naothmessages.DoubleVector2 targetPointInImage = 4;
  bool has_targetpointinimage() const;
  void clear_targetpointinimage();
  static const int kTargetPointInImageFieldNumber = 4;
  const ::naothmessages::DoubleVector2& targetpointinimage() const;
  ::naothmessages::DoubleVector2* mutable_targetpointinimage();
  ::naothmessages::DoubleVector2* release_targetpointinimage();
  void set_allocated_targetpointinimage(::naothmessages::DoubleVector2* targetpointinimage);

  // optional .naothmessages.DoubleVector3 targetPointInTheWorld = 5;
  bool has_targetpointintheworld() const;
  void clear_targetpointintheworld();
  static const int kTargetPointInTheWorldFieldNumber = 5;
  const ::naothmessages::DoubleVector3& targetpointintheworld() const;
  ::naothmessages::DoubleVector3* mutable_targetpointintheworld();
  ::naothmessages::DoubleVector3* release_targetpointintheworld();
  void set_allocated_targetpointintheworld(::naothmessages::DoubleVector3* targetpointintheworld);

  // optional .naothmessages.DoubleVector3 searchCenter = 6;
  bool has_searchcenter() const;
  void clear_searchcenter();
  static const int kSearchCenterFieldNumber = 6;
  const ::naothmessages::DoubleVector3& searchcenter() const;
  ::naothmessages::DoubleVector3* mutable_searchcenter();
  ::naothmessages::DoubleVector3* release_searchcenter();
  void set_allocated_searchcenter(::naothmessages::DoubleVector3* searchcenter);

  // optional .naothmessages.DoubleVector3 searchSize = 7;
  bool has_searchsize() const;
  void clear_searchsize();
  static const int kSearchSizeFieldNumber = 7;
  const ::naothmessages::DoubleVector3& searchsize() const;
  ::naothmessages::DoubleVector3* mutable_searchsize();
  ::naothmessages::DoubleVector3* release_searchsize();
  void set_allocated_searchsize(::naothmessages::DoubleVector3* searchsize);

  // optional .naothmessages.DoubleVector2 targetPointOnTheGround = 9;
  bool has_targetpointontheground() const;
  void clear_targetpointontheground();
  static const int kTargetPointOnTheGroundFieldNumber = 9;
  const ::naothmessages::DoubleVector2& targetpointontheground() const;
  ::naothmessages::DoubleVector2* mutable_targetpointontheground();
  ::naothmessages::DoubleVector2* release_targetpointontheground();
  void set_allocated_targetpointontheground(::naothmessages::DoubleVector2* targetpointontheground);

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required uint32 cameraID = 2;
  bool has_cameraid() const;
  void clear_cameraid();
  static const int kCameraIDFieldNumber = 2;
  ::google::protobuf::uint32 cameraid() const;
  void set_cameraid(::google::protobuf::uint32 value);

  // optional bool searchDirection = 8;
  bool has_searchdirection() const;
  void clear_searchdirection();
  static const int kSearchDirectionFieldNumber = 8;
  bool searchdirection() const;
  void set_searchdirection(bool value);

  // optional uint32 coordinate = 10;
  bool has_coordinate() const;
  void clear_coordinate();
  static const int kCoordinateFieldNumber = 10;
  ::google::protobuf::uint32 coordinate() const;
  void set_coordinate(::google::protobuf::uint32 value);

  // optional double velocity = 11;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 11;
  double velocity() const;
  void set_velocity(double value);

  // @@protoc_insertion_point(class_scope:naothmessages.HeadMotionRequest)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_cameraid();
  void clear_has_cameraid();
  void set_has_targetjointposition();
  void clear_has_targetjointposition();
  void set_has_targetpointinimage();
  void clear_has_targetpointinimage();
  void set_has_targetpointintheworld();
  void clear_has_targetpointintheworld();
  void set_has_searchcenter();
  void clear_has_searchcenter();
  void set_has_searchsize();
  void clear_has_searchsize();
  void set_has_searchdirection();
  void clear_has_searchdirection();
  void set_has_targetpointontheground();
  void clear_has_targetpointontheground();
  void set_has_coordinate();
  void clear_has_coordinate();
  void set_has_velocity();
  void clear_has_velocity();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector2* targetjointposition_;
  ::naothmessages::DoubleVector2* targetpointinimage_;
  ::naothmessages::DoubleVector3* targetpointintheworld_;
  ::naothmessages::DoubleVector3* searchcenter_;
  ::naothmessages::DoubleVector3* searchsize_;
  ::naothmessages::DoubleVector2* targetpointontheground_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 cameraid_;
  bool searchdirection_;
  ::google::protobuf::uint32 coordinate_;
  double velocity_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StepControlRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.StepControlRequest) */ {
 public:
  StepControlRequest();
  virtual ~StepControlRequest();

  StepControlRequest(const StepControlRequest& from);

  inline StepControlRequest& operator=(const StepControlRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StepControlRequest(StepControlRequest&& from) noexcept
    : StepControlRequest() {
    *this = ::std::move(from);
  }

  inline StepControlRequest& operator=(StepControlRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StepControlRequest& default_instance();

  static inline const StepControlRequest* internal_default_instance() {
    return reinterpret_cast<const StepControlRequest*>(
               &_StepControlRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(StepControlRequest* other);
  friend void swap(StepControlRequest& a, StepControlRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StepControlRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  StepControlRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StepControlRequest& from);
  void MergeFrom(const StepControlRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StepControlRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef StepControlRequest_StepType StepType;
  static const StepType WALKSTEP =
    StepControlRequest_StepType_WALKSTEP;
  static const StepType KICKSTEP =
    StepControlRequest_StepType_KICKSTEP;
  static const StepType ZEROSTEP =
    StepControlRequest_StepType_ZEROSTEP;
  static inline bool StepType_IsValid(int value) {
    return StepControlRequest_StepType_IsValid(value);
  }
  static const StepType StepType_MIN =
    StepControlRequest_StepType_StepType_MIN;
  static const StepType StepType_MAX =
    StepControlRequest_StepType_StepType_MAX;
  static const int StepType_ARRAYSIZE =
    StepControlRequest_StepType_StepType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  StepType_descriptor() {
    return StepControlRequest_StepType_descriptor();
  }
  static inline const ::std::string& StepType_Name(StepType value) {
    return StepControlRequest_StepType_Name(value);
  }
  static inline bool StepType_Parse(const ::std::string& name,
      StepType* value) {
    return StepControlRequest_StepType_Parse(name, value);
  }

  typedef StepControlRequest_RestrictionMode RestrictionMode;
  static const RestrictionMode HARD =
    StepControlRequest_RestrictionMode_HARD;
  static const RestrictionMode SOFT =
    StepControlRequest_RestrictionMode_SOFT;
  static inline bool RestrictionMode_IsValid(int value) {
    return StepControlRequest_RestrictionMode_IsValid(value);
  }
  static const RestrictionMode RestrictionMode_MIN =
    StepControlRequest_RestrictionMode_RestrictionMode_MIN;
  static const RestrictionMode RestrictionMode_MAX =
    StepControlRequest_RestrictionMode_RestrictionMode_MAX;
  static const int RestrictionMode_ARRAYSIZE =
    StepControlRequest_RestrictionMode_RestrictionMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  RestrictionMode_descriptor() {
    return StepControlRequest_RestrictionMode_descriptor();
  }
  static inline const ::std::string& RestrictionMode_Name(RestrictionMode value) {
    return StepControlRequest_RestrictionMode_Name(value);
  }
  static inline bool RestrictionMode_Parse(const ::std::string& name,
      RestrictionMode* value) {
    return StepControlRequest_RestrictionMode_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .naothmessages.Pose2D target = 3;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 3;
  const ::naothmessages::Pose2D& target() const;
  ::naothmessages::Pose2D* mutable_target();
  ::naothmessages::Pose2D* release_target();
  void set_allocated_target(::naothmessages::Pose2D* target);

  // required uint32 stepID = 1;
  bool has_stepid() const;
  void clear_stepid();
  static const int kStepIDFieldNumber = 1;
  ::google::protobuf::uint32 stepid() const;
  void set_stepid(::google::protobuf::uint32 value);

  // required uint32 time = 4;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 4;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // required double speedDirection = 5;
  bool has_speeddirection() const;
  void clear_speeddirection();
  static const int kSpeedDirectionFieldNumber = 5;
  double speeddirection() const;
  void set_speeddirection(double value);

  // required double scale = 6;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 6;
  double scale() const;
  void set_scale(double value);

  // required bool moveLeftFoot = 2;
  bool has_moveleftfoot() const;
  void clear_moveleftfoot();
  static const int kMoveLeftFootFieldNumber = 2;
  bool moveleftfoot() const;
  void set_moveleftfoot(bool value);

  // required bool isProtected = 9;
  bool has_isprotected() const;
  void clear_isprotected();
  static const int kIsProtectedFieldNumber = 9;
  bool isprotected() const;
  void set_isprotected(bool value);

  // required .naothmessages.StepControlRequest.StepType steptype = 7;
  bool has_steptype() const;
  void clear_steptype();
  static const int kSteptypeFieldNumber = 7;
  ::naothmessages::StepControlRequest_StepType steptype() const;
  void set_steptype(::naothmessages::StepControlRequest_StepType value);

  // required .naothmessages.StepControlRequest.RestrictionMode restriction = 8;
  bool has_restriction() const;
  void clear_restriction();
  static const int kRestrictionFieldNumber = 8;
  ::naothmessages::StepControlRequest_RestrictionMode restriction() const;
  void set_restriction(::naothmessages::StepControlRequest_RestrictionMode value);

  // required uint32 stepRequestID = 10;
  bool has_steprequestid() const;
  void clear_steprequestid();
  static const int kStepRequestIDFieldNumber = 10;
  ::google::protobuf::uint32 steprequestid() const;
  void set_steprequestid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:naothmessages.StepControlRequest)
 private:
  void set_has_stepid();
  void clear_has_stepid();
  void set_has_moveleftfoot();
  void clear_has_moveleftfoot();
  void set_has_target();
  void clear_has_target();
  void set_has_time();
  void clear_has_time();
  void set_has_speeddirection();
  void clear_has_speeddirection();
  void set_has_scale();
  void clear_has_scale();
  void set_has_steptype();
  void clear_has_steptype();
  void set_has_restriction();
  void clear_has_restriction();
  void set_has_isprotected();
  void clear_has_isprotected();
  void set_has_steprequestid();
  void clear_has_steprequestid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::Pose2D* target_;
  ::google::protobuf::uint32 stepid_;
  ::google::protobuf::uint32 time_;
  double speeddirection_;
  double scale_;
  bool moveleftfoot_;
  bool isprotected_;
  int steptype_;
  int restriction_;
  ::google::protobuf::uint32 steprequestid_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WalkRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.WalkRequest) */ {
 public:
  WalkRequest();
  virtual ~WalkRequest();

  WalkRequest(const WalkRequest& from);

  inline WalkRequest& operator=(const WalkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WalkRequest(WalkRequest&& from) noexcept
    : WalkRequest() {
    *this = ::std::move(from);
  }

  inline WalkRequest& operator=(WalkRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WalkRequest& default_instance();

  static inline const WalkRequest* internal_default_instance() {
    return reinterpret_cast<const WalkRequest*>(
               &_WalkRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(WalkRequest* other);
  friend void swap(WalkRequest& a, WalkRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WalkRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  WalkRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WalkRequest& from);
  void MergeFrom(const WalkRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WalkRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.Pose2D target = 3;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 3;
  const ::naothmessages::Pose2D& target() const;
  ::naothmessages::Pose2D* mutable_target();
  ::naothmessages::Pose2D* release_target();
  void set_allocated_target(::naothmessages::Pose2D* target);

  // optional .naothmessages.StepControlRequest stepControl = 4;
  bool has_stepcontrol() const;
  void clear_stepcontrol();
  static const int kStepControlFieldNumber = 4;
  const ::naothmessages::StepControlRequest& stepcontrol() const;
  ::naothmessages::StepControlRequest* mutable_stepcontrol();
  ::naothmessages::StepControlRequest* release_stepcontrol();
  void set_allocated_stepcontrol(::naothmessages::StepControlRequest* stepcontrol);

  // required .naothmessages.Pose2D offset = 5;
  bool has_offset() const;
  void clear_offset();
  static const int kOffsetFieldNumber = 5;
  const ::naothmessages::Pose2D& offset() const;
  ::naothmessages::Pose2D* mutable_offset();
  ::naothmessages::Pose2D* release_offset();
  void set_allocated_offset(::naothmessages::Pose2D* offset);

  // required double character = 2;
  bool has_character() const;
  void clear_character();
  static const int kCharacterFieldNumber = 2;
  double character() const;
  void set_character(double value);

  // required uint32 coordinate = 1;
  bool has_coordinate() const;
  void clear_coordinate();
  static const int kCoordinateFieldNumber = 1;
  ::google::protobuf::uint32 coordinate() const;
  void set_coordinate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:naothmessages.WalkRequest)
 private:
  void set_has_coordinate();
  void clear_has_coordinate();
  void set_has_character();
  void clear_has_character();
  void set_has_target();
  void clear_has_target();
  void set_has_stepcontrol();
  void clear_has_stepcontrol();
  void set_has_offset();
  void clear_has_offset();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::Pose2D* target_;
  ::naothmessages::StepControlRequest* stepcontrol_;
  ::naothmessages::Pose2D* offset_;
  double character_;
  ::google::protobuf::uint32 coordinate_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KickRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.KickRequest) */ {
 public:
  KickRequest();
  virtual ~KickRequest();

  KickRequest(const KickRequest& from);

  inline KickRequest& operator=(const KickRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KickRequest(KickRequest&& from) noexcept
    : KickRequest() {
    *this = ::std::move(from);
  }

  inline KickRequest& operator=(KickRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KickRequest& default_instance();

  static inline const KickRequest* internal_default_instance() {
    return reinterpret_cast<const KickRequest*>(
               &_KickRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(KickRequest* other);
  friend void swap(KickRequest& a, KickRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KickRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  KickRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const KickRequest& from);
  void MergeFrom(const KickRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(KickRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.DoubleVector3 kickPoint = 1;
  bool has_kickpoint() const;
  void clear_kickpoint();
  static const int kKickPointFieldNumber = 1;
  const ::naothmessages::DoubleVector3& kickpoint() const;
  ::naothmessages::DoubleVector3* mutable_kickpoint();
  ::naothmessages::DoubleVector3* release_kickpoint();
  void set_allocated_kickpoint(::naothmessages::DoubleVector3* kickpoint);

  // required double kickDirection = 2;
  bool has_kickdirection() const;
  void clear_kickdirection();
  static const int kKickDirectionFieldNumber = 2;
  double kickdirection() const;
  void set_kickdirection(double value);

  // required int32 kickFoot = 3;
  bool has_kickfoot() const;
  void clear_kickfoot();
  static const int kKickFootFieldNumber = 3;
  ::google::protobuf::int32 kickfoot() const;
  void set_kickfoot(::google::protobuf::int32 value);

  // required bool finishKick = 4;
  bool has_finishkick() const;
  void clear_finishkick();
  static const int kFinishKickFieldNumber = 4;
  bool finishkick() const;
  void set_finishkick(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.KickRequest)
 private:
  void set_has_kickpoint();
  void clear_has_kickpoint();
  void set_has_kickdirection();
  void clear_has_kickdirection();
  void set_has_kickfoot();
  void clear_has_kickfoot();
  void set_has_finishkick();
  void clear_has_finishkick();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector3* kickpoint_;
  double kickdirection_;
  ::google::protobuf::int32 kickfoot_;
  bool finishkick_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GraspRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.GraspRequest) */ {
 public:
  GraspRequest();
  virtual ~GraspRequest();

  GraspRequest(const GraspRequest& from);

  inline GraspRequest& operator=(const GraspRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GraspRequest(GraspRequest&& from) noexcept
    : GraspRequest() {
    *this = ::std::move(from);
  }

  inline GraspRequest& operator=(GraspRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GraspRequest& default_instance();

  static inline const GraspRequest* internal_default_instance() {
    return reinterpret_cast<const GraspRequest*>(
               &_GraspRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(GraspRequest* other);
  friend void swap(GraspRequest& a, GraspRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GraspRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  GraspRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GraspRequest& from);
  void MergeFrom(const GraspRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GraspRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.DoubleVector3 graspingPoint = 1;
  bool has_graspingpoint() const;
  void clear_graspingpoint();
  static const int kGraspingPointFieldNumber = 1;
  const ::naothmessages::DoubleVector3& graspingpoint() const;
  ::naothmessages::DoubleVector3* mutable_graspingpoint();
  ::naothmessages::DoubleVector3* release_graspingpoint();
  void set_allocated_graspingpoint(::naothmessages::DoubleVector3* graspingpoint);

  // required uint32 graspingState = 2;
  bool has_graspingstate() const;
  void clear_graspingstate();
  static const int kGraspingStateFieldNumber = 2;
  ::google::protobuf::uint32 graspingstate() const;
  void set_graspingstate(::google::protobuf::uint32 value);

  // required uint32 graspDistState = 3;
  bool has_graspdiststate() const;
  void clear_graspdiststate();
  static const int kGraspDistStateFieldNumber = 3;
  ::google::protobuf::uint32 graspdiststate() const;
  void set_graspdiststate(::google::protobuf::uint32 value);

  // required uint32 graspStiffState = 4;
  bool has_graspstiffstate() const;
  void clear_graspstiffstate();
  static const int kGraspStiffStateFieldNumber = 4;
  ::google::protobuf::uint32 graspstiffstate() const;
  void set_graspstiffstate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:naothmessages.GraspRequest)
 private:
  void set_has_graspingpoint();
  void clear_has_graspingpoint();
  void set_has_graspingstate();
  void clear_has_graspingstate();
  void set_has_graspdiststate();
  void clear_has_graspdiststate();
  void set_has_graspstiffstate();
  void clear_has_graspstiffstate();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector3* graspingpoint_;
  ::google::protobuf::uint32 graspingstate_;
  ::google::protobuf::uint32 graspdiststate_;
  ::google::protobuf::uint32 graspstiffstate_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ArmMotionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.ArmMotionRequest) */ {
 public:
  ArmMotionRequest();
  virtual ~ArmMotionRequest();

  ArmMotionRequest(const ArmMotionRequest& from);

  inline ArmMotionRequest& operator=(const ArmMotionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ArmMotionRequest(ArmMotionRequest&& from) noexcept
    : ArmMotionRequest() {
    *this = ::std::move(from);
  }

  inline ArmMotionRequest& operator=(ArmMotionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ArmMotionRequest& default_instance();

  static inline const ArmMotionRequest* internal_default_instance() {
    return reinterpret_cast<const ArmMotionRequest*>(
               &_ArmMotionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(ArmMotionRequest* other);
  friend void swap(ArmMotionRequest& a, ArmMotionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ArmMotionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  ArmMotionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ArmMotionRequest& from);
  void MergeFrom(const ArmMotionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ArmMotionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.DoubleVector2 lShoulderPosition = 2;
  bool has_lshoulderposition() const;
  void clear_lshoulderposition();
  static const int kLShoulderPositionFieldNumber = 2;
  const ::naothmessages::DoubleVector2& lshoulderposition() const;
  ::naothmessages::DoubleVector2* mutable_lshoulderposition();
  ::naothmessages::DoubleVector2* release_lshoulderposition();
  void set_allocated_lshoulderposition(::naothmessages::DoubleVector2* lshoulderposition);

  // optional .naothmessages.DoubleVector2 lShoulderStiffness = 3;
  bool has_lshoulderstiffness() const;
  void clear_lshoulderstiffness();
  static const int kLShoulderStiffnessFieldNumber = 3;
  const ::naothmessages::DoubleVector2& lshoulderstiffness() const;
  ::naothmessages::DoubleVector2* mutable_lshoulderstiffness();
  ::naothmessages::DoubleVector2* release_lshoulderstiffness();
  void set_allocated_lshoulderstiffness(::naothmessages::DoubleVector2* lshoulderstiffness);

  // optional .naothmessages.DoubleVector2 lElbowPosition = 4;
  bool has_lelbowposition() const;
  void clear_lelbowposition();
  static const int kLElbowPositionFieldNumber = 4;
  const ::naothmessages::DoubleVector2& lelbowposition() const;
  ::naothmessages::DoubleVector2* mutable_lelbowposition();
  ::naothmessages::DoubleVector2* release_lelbowposition();
  void set_allocated_lelbowposition(::naothmessages::DoubleVector2* lelbowposition);

  // optional .naothmessages.DoubleVector2 lElbowStiffness = 5;
  bool has_lelbowstiffness() const;
  void clear_lelbowstiffness();
  static const int kLElbowStiffnessFieldNumber = 5;
  const ::naothmessages::DoubleVector2& lelbowstiffness() const;
  ::naothmessages::DoubleVector2* mutable_lelbowstiffness();
  ::naothmessages::DoubleVector2* release_lelbowstiffness();
  void set_allocated_lelbowstiffness(::naothmessages::DoubleVector2* lelbowstiffness);

  // optional .naothmessages.DoubleVector2 rShoulderPosition = 6;
  bool has_rshoulderposition() const;
  void clear_rshoulderposition();
  static const int kRShoulderPositionFieldNumber = 6;
  const ::naothmessages::DoubleVector2& rshoulderposition() const;
  ::naothmessages::DoubleVector2* mutable_rshoulderposition();
  ::naothmessages::DoubleVector2* release_rshoulderposition();
  void set_allocated_rshoulderposition(::naothmessages::DoubleVector2* rshoulderposition);

  // optional .naothmessages.DoubleVector2 rShoulderStiffness = 7;
  bool has_rshoulderstiffness() const;
  void clear_rshoulderstiffness();
  static const int kRShoulderStiffnessFieldNumber = 7;
  const ::naothmessages::DoubleVector2& rshoulderstiffness() const;
  ::naothmessages::DoubleVector2* mutable_rshoulderstiffness();
  ::naothmessages::DoubleVector2* release_rshoulderstiffness();
  void set_allocated_rshoulderstiffness(::naothmessages::DoubleVector2* rshoulderstiffness);

  // optional .naothmessages.DoubleVector2 rElbowPosition = 8;
  bool has_relbowposition() const;
  void clear_relbowposition();
  static const int kRElbowPositionFieldNumber = 8;
  const ::naothmessages::DoubleVector2& relbowposition() const;
  ::naothmessages::DoubleVector2* mutable_relbowposition();
  ::naothmessages::DoubleVector2* release_relbowposition();
  void set_allocated_relbowposition(::naothmessages::DoubleVector2* relbowposition);

  // optional .naothmessages.DoubleVector2 rElbowStiffness = 9;
  bool has_relbowstiffness() const;
  void clear_relbowstiffness();
  static const int kRElbowStiffnessFieldNumber = 9;
  const ::naothmessages::DoubleVector2& relbowstiffness() const;
  ::naothmessages::DoubleVector2* mutable_relbowstiffness();
  ::naothmessages::DoubleVector2* release_relbowstiffness();
  void set_allocated_relbowstiffness(::naothmessages::DoubleVector2* relbowstiffness);

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:naothmessages.ArmMotionRequest)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_lshoulderposition();
  void clear_has_lshoulderposition();
  void set_has_lshoulderstiffness();
  void clear_has_lshoulderstiffness();
  void set_has_lelbowposition();
  void clear_has_lelbowposition();
  void set_has_lelbowstiffness();
  void clear_has_lelbowstiffness();
  void set_has_rshoulderposition();
  void clear_has_rshoulderposition();
  void set_has_rshoulderstiffness();
  void clear_has_rshoulderstiffness();
  void set_has_relbowposition();
  void clear_has_relbowposition();
  void set_has_relbowstiffness();
  void clear_has_relbowstiffness();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector2* lshoulderposition_;
  ::naothmessages::DoubleVector2* lshoulderstiffness_;
  ::naothmessages::DoubleVector2* lelbowposition_;
  ::naothmessages::DoubleVector2* lelbowstiffness_;
  ::naothmessages::DoubleVector2* rshoulderposition_;
  ::naothmessages::DoubleVector2* rshoulderstiffness_;
  ::naothmessages::DoubleVector2* relbowposition_;
  ::naothmessages::DoubleVector2* relbowstiffness_;
  ::google::protobuf::uint32 id_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MotionRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.MotionRequest) */ {
 public:
  MotionRequest();
  virtual ~MotionRequest();

  MotionRequest(const MotionRequest& from);

  inline MotionRequest& operator=(const MotionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotionRequest(MotionRequest&& from) noexcept
    : MotionRequest() {
    *this = ::std::move(from);
  }

  inline MotionRequest& operator=(MotionRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotionRequest& default_instance();

  static inline const MotionRequest* internal_default_instance() {
    return reinterpret_cast<const MotionRequest*>(
               &_MotionRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    13;

  void Swap(MotionRequest* other);
  friend void swap(MotionRequest& a, MotionRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotionRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  MotionRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MotionRequest& from);
  void MergeFrom(const MotionRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MotionRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.WalkRequest walkRequest = 4;
  bool has_walkrequest() const;
  void clear_walkrequest();
  static const int kWalkRequestFieldNumber = 4;
  const ::naothmessages::WalkRequest& walkrequest() const;
  ::naothmessages::WalkRequest* mutable_walkrequest();
  ::naothmessages::WalkRequest* release_walkrequest();
  void set_allocated_walkrequest(::naothmessages::WalkRequest* walkrequest);

  // optional .naothmessages.KickRequest kickRequest = 6;
  bool has_kickrequest() const;
  void clear_kickrequest();
  static const int kKickRequestFieldNumber = 6;
  const ::naothmessages::KickRequest& kickrequest() const;
  ::naothmessages::KickRequest* mutable_kickrequest();
  ::naothmessages::KickRequest* release_kickrequest();
  void set_allocated_kickrequest(::naothmessages::KickRequest* kickrequest);

  // optional .naothmessages.GraspRequest graspRequest = 10;
  bool has_grasprequest() const;
  void clear_grasprequest();
  static const int kGraspRequestFieldNumber = 10;
  const ::naothmessages::GraspRequest& grasprequest() const;
  ::naothmessages::GraspRequest* mutable_grasprequest();
  ::naothmessages::GraspRequest* release_grasprequest();
  void set_allocated_grasprequest(::naothmessages::GraspRequest* grasprequest);

  // optional .naothmessages.ArmMotionRequest armMotionRequest = 11;
  bool has_armmotionrequest() const;
  void clear_armmotionrequest();
  static const int kArmMotionRequestFieldNumber = 11;
  const ::naothmessages::ArmMotionRequest& armmotionrequest() const;
  ::naothmessages::ArmMotionRequest* mutable_armmotionrequest();
  ::naothmessages::ArmMotionRequest* release_armmotionrequest();
  void set_allocated_armmotionrequest(::naothmessages::ArmMotionRequest* armmotionrequest);

  // required uint32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // required uint32 time = 2;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 2;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // optional double standHeight = 7;
  bool has_standheight() const;
  void clear_standheight();
  static const int kStandHeightFieldNumber = 7;
  double standheight() const;
  void set_standheight(double value);

  // required bool forced = 3;
  bool has_forced() const;
  void clear_forced();
  static const int kForcedFieldNumber = 3;
  bool forced() const;
  void set_forced(bool value);

  // optional bool starndardStand = 5;
  bool has_starndardstand() const;
  void clear_starndardstand();
  static const int kStarndardStandFieldNumber = 5;
  bool starndardstand() const;
  void set_starndardstand(bool value);

  // optional bool calibrateFootTouchDetector = 8;
  bool has_calibratefoottouchdetector() const;
  void clear_calibratefoottouchdetector();
  static const int kCalibrateFootTouchDetectorFieldNumber = 8;
  bool calibratefoottouchdetector() const;
  void set_calibratefoottouchdetector(bool value);

  // optional bool disable_relaxed_stand = 12;
  bool has_disable_relaxed_stand() const;
  void clear_disable_relaxed_stand();
  static const int kDisableRelaxedStandFieldNumber = 12;
  bool disable_relaxed_stand() const;
  void set_disable_relaxed_stand(bool value);

  // optional uint32 cognitionFrameNumber = 9;
  bool has_cognitionframenumber() const;
  void clear_cognitionframenumber();
  static const int kCognitionFrameNumberFieldNumber = 9;
  ::google::protobuf::uint32 cognitionframenumber() const;
  void set_cognitionframenumber(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:naothmessages.MotionRequest)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_time();
  void clear_has_time();
  void set_has_forced();
  void clear_has_forced();
  void set_has_walkrequest();
  void clear_has_walkrequest();
  void set_has_starndardstand();
  void clear_has_starndardstand();
  void set_has_kickrequest();
  void clear_has_kickrequest();
  void set_has_standheight();
  void clear_has_standheight();
  void set_has_calibratefoottouchdetector();
  void clear_has_calibratefoottouchdetector();
  void set_has_cognitionframenumber();
  void clear_has_cognitionframenumber();
  void set_has_grasprequest();
  void clear_has_grasprequest();
  void set_has_armmotionrequest();
  void clear_has_armmotionrequest();
  void set_has_disable_relaxed_stand();
  void clear_has_disable_relaxed_stand();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::WalkRequest* walkrequest_;
  ::naothmessages::KickRequest* kickrequest_;
  ::naothmessages::GraspRequest* grasprequest_;
  ::naothmessages::ArmMotionRequest* armmotionrequest_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 time_;
  double standheight_;
  bool forced_;
  bool starndardstand_;
  bool calibratefoottouchdetector_;
  bool disable_relaxed_stand_;
  ::google::protobuf::uint32 cognitionframenumber_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinePercept_Intersection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.LinePercept.Intersection) */ {
 public:
  LinePercept_Intersection();
  virtual ~LinePercept_Intersection();

  LinePercept_Intersection(const LinePercept_Intersection& from);

  inline LinePercept_Intersection& operator=(const LinePercept_Intersection& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinePercept_Intersection(LinePercept_Intersection&& from) noexcept
    : LinePercept_Intersection() {
    *this = ::std::move(from);
  }

  inline LinePercept_Intersection& operator=(LinePercept_Intersection&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinePercept_Intersection& default_instance();

  static inline const LinePercept_Intersection* internal_default_instance() {
    return reinterpret_cast<const LinePercept_Intersection*>(
               &_LinePercept_Intersection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    14;

  void Swap(LinePercept_Intersection* other);
  friend void swap(LinePercept_Intersection& a, LinePercept_Intersection& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinePercept_Intersection* New() const PROTOBUF_FINAL { return New(NULL); }

  LinePercept_Intersection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinePercept_Intersection& from);
  void MergeFrom(const LinePercept_Intersection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinePercept_Intersection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LinePercept_Intersection_IntersectionType IntersectionType;
  static const IntersectionType unknown =
    LinePercept_Intersection_IntersectionType_unknown;
  static const IntersectionType T =
    LinePercept_Intersection_IntersectionType_T;
  static const IntersectionType L =
    LinePercept_Intersection_IntersectionType_L;
  static const IntersectionType C =
    LinePercept_Intersection_IntersectionType_C;
  static const IntersectionType none =
    LinePercept_Intersection_IntersectionType_none;
  static const IntersectionType X =
    LinePercept_Intersection_IntersectionType_X;
  static inline bool IntersectionType_IsValid(int value) {
    return LinePercept_Intersection_IntersectionType_IsValid(value);
  }
  static const IntersectionType IntersectionType_MIN =
    LinePercept_Intersection_IntersectionType_IntersectionType_MIN;
  static const IntersectionType IntersectionType_MAX =
    LinePercept_Intersection_IntersectionType_IntersectionType_MAX;
  static const int IntersectionType_ARRAYSIZE =
    LinePercept_Intersection_IntersectionType_IntersectionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  IntersectionType_descriptor() {
    return LinePercept_Intersection_IntersectionType_descriptor();
  }
  static inline const ::std::string& IntersectionType_Name(IntersectionType value) {
    return LinePercept_Intersection_IntersectionType_Name(value);
  }
  static inline bool IntersectionType_Parse(const ::std::string& name,
      IntersectionType* value) {
    return LinePercept_Intersection_IntersectionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .naothmessages.DoubleVector2 posInImage = 1;
  bool has_posinimage() const;
  void clear_posinimage();
  static const int kPosInImageFieldNumber = 1;
  const ::naothmessages::DoubleVector2& posinimage() const;
  ::naothmessages::DoubleVector2* mutable_posinimage();
  ::naothmessages::DoubleVector2* release_posinimage();
  void set_allocated_posinimage(::naothmessages::DoubleVector2* posinimage);

  // optional .naothmessages.DoubleVector2 posOnField = 2;
  bool has_posonfield() const;
  void clear_posonfield();
  static const int kPosOnFieldFieldNumber = 2;
  const ::naothmessages::DoubleVector2& posonfield() const;
  ::naothmessages::DoubleVector2* mutable_posonfield();
  ::naothmessages::DoubleVector2* release_posonfield();
  void set_allocated_posonfield(::naothmessages::DoubleVector2* posonfield);

  // optional .naothmessages.LinePercept.Intersection.IntersectionType type = 3;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::naothmessages::LinePercept_Intersection_IntersectionType type() const;
  void set_type(::naothmessages::LinePercept_Intersection_IntersectionType value);

  // optional uint32 segmentOneIndex = 6;
  bool has_segmentoneindex() const;
  void clear_segmentoneindex();
  static const int kSegmentOneIndexFieldNumber = 6;
  ::google::protobuf::uint32 segmentoneindex() const;
  void set_segmentoneindex(::google::protobuf::uint32 value);

  // optional double segmentOneDistance = 8;
  bool has_segmentonedistance() const;
  void clear_segmentonedistance();
  static const int kSegmentOneDistanceFieldNumber = 8;
  double segmentonedistance() const;
  void set_segmentonedistance(double value);

  // optional uint32 segmentTwoIndex = 7;
  bool has_segmenttwoindex() const;
  void clear_segmenttwoindex();
  static const int kSegmentTwoIndexFieldNumber = 7;
  ::google::protobuf::uint32 segmenttwoindex() const;
  void set_segmenttwoindex(::google::protobuf::uint32 value);

  // optional double segmentTwoDistance = 9;
  bool has_segmenttwodistance() const;
  void clear_segmenttwodistance();
  static const int kSegmentTwoDistanceFieldNumber = 9;
  double segmenttwodistance() const;
  void set_segmenttwodistance(double value);

  // @@protoc_insertion_point(class_scope:naothmessages.LinePercept.Intersection)
 private:
  void set_has_posinimage();
  void clear_has_posinimage();
  void set_has_posonfield();
  void clear_has_posonfield();
  void set_has_type();
  void clear_has_type();
  void set_has_segmentoneindex();
  void clear_has_segmentoneindex();
  void set_has_segmenttwoindex();
  void clear_has_segmenttwoindex();
  void set_has_segmentonedistance();
  void clear_has_segmentonedistance();
  void set_has_segmenttwodistance();
  void clear_has_segmenttwodistance();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector2* posinimage_;
  ::naothmessages::DoubleVector2* posonfield_;
  int type_;
  ::google::protobuf::uint32 segmentoneindex_;
  double segmentonedistance_;
  ::google::protobuf::uint32 segmenttwoindex_;
  double segmenttwodistance_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinePercept_FieldLineSegment : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.LinePercept.FieldLineSegment) */ {
 public:
  LinePercept_FieldLineSegment();
  virtual ~LinePercept_FieldLineSegment();

  LinePercept_FieldLineSegment(const LinePercept_FieldLineSegment& from);

  inline LinePercept_FieldLineSegment& operator=(const LinePercept_FieldLineSegment& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinePercept_FieldLineSegment(LinePercept_FieldLineSegment&& from) noexcept
    : LinePercept_FieldLineSegment() {
    *this = ::std::move(from);
  }

  inline LinePercept_FieldLineSegment& operator=(LinePercept_FieldLineSegment&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinePercept_FieldLineSegment& default_instance();

  static inline const LinePercept_FieldLineSegment* internal_default_instance() {
    return reinterpret_cast<const LinePercept_FieldLineSegment*>(
               &_LinePercept_FieldLineSegment_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    15;

  void Swap(LinePercept_FieldLineSegment* other);
  friend void swap(LinePercept_FieldLineSegment& a, LinePercept_FieldLineSegment& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinePercept_FieldLineSegment* New() const PROTOBUF_FINAL { return New(NULL); }

  LinePercept_FieldLineSegment* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinePercept_FieldLineSegment& from);
  void MergeFrom(const LinePercept_FieldLineSegment& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinePercept_FieldLineSegment* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.LineSegment lineInImage = 1;
  bool has_lineinimage() const;
  void clear_lineinimage();
  static const int kLineInImageFieldNumber = 1;
  const ::naothmessages::LineSegment& lineinimage() const;
  ::naothmessages::LineSegment* mutable_lineinimage();
  ::naothmessages::LineSegment* release_lineinimage();
  void set_allocated_lineinimage(::naothmessages::LineSegment* lineinimage);

  // optional .naothmessages.LineSegment lineOnField = 2;
  bool has_lineonfield() const;
  void clear_lineonfield();
  static const int kLineOnFieldFieldNumber = 2;
  const ::naothmessages::LineSegment& lineonfield() const;
  ::naothmessages::LineSegment* mutable_lineonfield();
  ::naothmessages::LineSegment* release_lineonfield();
  void set_allocated_lineonfield(::naothmessages::LineSegment* lineonfield);

  // optional int32 beginExtendCount = 3;
  bool has_beginextendcount() const;
  void clear_beginextendcount();
  static const int kBeginExtendCountFieldNumber = 3;
  ::google::protobuf::int32 beginextendcount() const;
  void set_beginextendcount(::google::protobuf::int32 value);

  // optional int32 endExtendCount = 4;
  bool has_endextendcount() const;
  void clear_endextendcount();
  static const int kEndExtendCountFieldNumber = 4;
  ::google::protobuf::int32 endextendcount() const;
  void set_endextendcount(::google::protobuf::int32 value);

  // optional double thickness = 5;
  bool has_thickness() const;
  void clear_thickness();
  static const int kThicknessFieldNumber = 5;
  double thickness() const;
  void set_thickness(double value);

  // optional double slope = 6;
  bool has_slope() const;
  void clear_slope();
  static const int kSlopeFieldNumber = 6;
  double slope() const;
  void set_slope(double value);

  // optional double angle = 7;
  bool has_angle() const;
  void clear_angle();
  static const int kAngleFieldNumber = 7;
  double angle() const;
  void set_angle(double value);

  // optional bool valid = 8;
  bool has_valid() const;
  void clear_valid();
  static const int kValidFieldNumber = 8;
  bool valid() const;
  void set_valid(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.LinePercept.FieldLineSegment)
 private:
  void set_has_lineinimage();
  void clear_has_lineinimage();
  void set_has_lineonfield();
  void clear_has_lineonfield();
  void set_has_beginextendcount();
  void clear_has_beginextendcount();
  void set_has_endextendcount();
  void clear_has_endextendcount();
  void set_has_thickness();
  void clear_has_thickness();
  void set_has_slope();
  void clear_has_slope();
  void set_has_angle();
  void clear_has_angle();
  void set_has_valid();
  void clear_has_valid();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::LineSegment* lineinimage_;
  ::naothmessages::LineSegment* lineonfield_;
  ::google::protobuf::int32 beginextendcount_;
  ::google::protobuf::int32 endextendcount_;
  double thickness_;
  double slope_;
  double angle_;
  bool valid_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LinePercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.LinePercept) */ {
 public:
  LinePercept();
  virtual ~LinePercept();

  LinePercept(const LinePercept& from);

  inline LinePercept& operator=(const LinePercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LinePercept(LinePercept&& from) noexcept
    : LinePercept() {
    *this = ::std::move(from);
  }

  inline LinePercept& operator=(LinePercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LinePercept& default_instance();

  static inline const LinePercept* internal_default_instance() {
    return reinterpret_cast<const LinePercept*>(
               &_LinePercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    16;

  void Swap(LinePercept* other);
  friend void swap(LinePercept& a, LinePercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LinePercept* New() const PROTOBUF_FINAL { return New(NULL); }

  LinePercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LinePercept& from);
  void MergeFrom(const LinePercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LinePercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef LinePercept_Intersection Intersection;
  typedef LinePercept_FieldLineSegment FieldLineSegment;

  // accessors -------------------------------------------------------

  // repeated .naothmessages.LinePercept.FieldLineSegment lines = 1;
  int lines_size() const;
  void clear_lines();
  static const int kLinesFieldNumber = 1;
  const ::naothmessages::LinePercept_FieldLineSegment& lines(int index) const;
  ::naothmessages::LinePercept_FieldLineSegment* mutable_lines(int index);
  ::naothmessages::LinePercept_FieldLineSegment* add_lines();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::LinePercept_FieldLineSegment >*
      mutable_lines();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::LinePercept_FieldLineSegment >&
      lines() const;

  // repeated .naothmessages.LinePercept.Intersection intersections = 2;
  int intersections_size() const;
  void clear_intersections();
  static const int kIntersectionsFieldNumber = 2;
  const ::naothmessages::LinePercept_Intersection& intersections(int index) const;
  ::naothmessages::LinePercept_Intersection* mutable_intersections(int index);
  ::naothmessages::LinePercept_Intersection* add_intersections();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::LinePercept_Intersection >*
      mutable_intersections();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::LinePercept_Intersection >&
      intersections() const;

  // optional .naothmessages.DoubleVector2 middleCircleCenter = 3;
  bool has_middlecirclecenter() const;
  void clear_middlecirclecenter();
  static const int kMiddleCircleCenterFieldNumber = 3;
  const ::naothmessages::DoubleVector2& middlecirclecenter() const;
  ::naothmessages::DoubleVector2* mutable_middlecirclecenter();
  ::naothmessages::DoubleVector2* release_middlecirclecenter();
  void set_allocated_middlecirclecenter(::naothmessages::DoubleVector2* middlecirclecenter);

  // @@protoc_insertion_point(class_scope:naothmessages.LinePercept)
 private:
  void set_has_middlecirclecenter();
  void clear_has_middlecirclecenter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::LinePercept_FieldLineSegment > lines_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::LinePercept_Intersection > intersections_;
  ::naothmessages::DoubleVector2* middlecirclecenter_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ShortLinePercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.ShortLinePercept) */ {
 public:
  ShortLinePercept();
  virtual ~ShortLinePercept();

  ShortLinePercept(const ShortLinePercept& from);

  inline ShortLinePercept& operator=(const ShortLinePercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ShortLinePercept(ShortLinePercept&& from) noexcept
    : ShortLinePercept() {
    *this = ::std::move(from);
  }

  inline ShortLinePercept& operator=(ShortLinePercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShortLinePercept& default_instance();

  static inline const ShortLinePercept* internal_default_instance() {
    return reinterpret_cast<const ShortLinePercept*>(
               &_ShortLinePercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    17;

  void Swap(ShortLinePercept* other);
  friend void swap(ShortLinePercept& a, ShortLinePercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ShortLinePercept* New() const PROTOBUF_FINAL { return New(NULL); }

  ShortLinePercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ShortLinePercept& from);
  void MergeFrom(const ShortLinePercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ShortLinePercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .naothmessages.LineSegment fieldLineSegments = 1;
  int fieldlinesegments_size() const;
  void clear_fieldlinesegments();
  static const int kFieldLineSegmentsFieldNumber = 1;
  const ::naothmessages::LineSegment& fieldlinesegments(int index) const;
  ::naothmessages::LineSegment* mutable_fieldlinesegments(int index);
  ::naothmessages::LineSegment* add_fieldlinesegments();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::LineSegment >*
      mutable_fieldlinesegments();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::LineSegment >&
      fieldlinesegments() const;

  // @@protoc_insertion_point(class_scope:naothmessages.ShortLinePercept)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::LineSegment > fieldlinesegments_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Polygon : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.Polygon) */ {
 public:
  Polygon();
  virtual ~Polygon();

  Polygon(const Polygon& from);

  inline Polygon& operator=(const Polygon& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Polygon(Polygon&& from) noexcept
    : Polygon() {
    *this = ::std::move(from);
  }

  inline Polygon& operator=(Polygon&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Polygon& default_instance();

  static inline const Polygon* internal_default_instance() {
    return reinterpret_cast<const Polygon*>(
               &_Polygon_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    18;

  void Swap(Polygon* other);
  friend void swap(Polygon& a, Polygon& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Polygon* New() const PROTOBUF_FINAL { return New(NULL); }

  Polygon* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Polygon& from);
  void MergeFrom(const Polygon& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Polygon* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .naothmessages.IntVector2 points = 1;
  int points_size() const;
  void clear_points();
  static const int kPointsFieldNumber = 1;
  const ::naothmessages::IntVector2& points(int index) const;
  ::naothmessages::IntVector2* mutable_points(int index);
  ::naothmessages::IntVector2* add_points();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::IntVector2 >*
      mutable_points();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::IntVector2 >&
      points() const;

  // @@protoc_insertion_point(class_scope:naothmessages.Polygon)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::IntVector2 > points_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FieldPercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.FieldPercept) */ {
 public:
  FieldPercept();
  virtual ~FieldPercept();

  FieldPercept(const FieldPercept& from);

  inline FieldPercept& operator=(const FieldPercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FieldPercept(FieldPercept&& from) noexcept
    : FieldPercept() {
    *this = ::std::move(from);
  }

  inline FieldPercept& operator=(FieldPercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FieldPercept& default_instance();

  static inline const FieldPercept* internal_default_instance() {
    return reinterpret_cast<const FieldPercept*>(
               &_FieldPercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    19;

  void Swap(FieldPercept* other);
  friend void swap(FieldPercept& a, FieldPercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FieldPercept* New() const PROTOBUF_FINAL { return New(NULL); }

  FieldPercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const FieldPercept& from);
  void MergeFrom(const FieldPercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(FieldPercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.Polygon fieldPoly = 1;
  bool has_fieldpoly() const;
  void clear_fieldpoly();
  static const int kFieldPolyFieldNumber = 1;
  const ::naothmessages::Polygon& fieldpoly() const;
  ::naothmessages::Polygon* mutable_fieldpoly();
  ::naothmessages::Polygon* release_fieldpoly();
  void set_allocated_fieldpoly(::naothmessages::Polygon* fieldpoly);

  // @@protoc_insertion_point(class_scope:naothmessages.FieldPercept)
 private:
  void set_has_fieldpoly();
  void clear_has_fieldpoly();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::Polygon* fieldpoly_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RansacLinePercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.RansacLinePercept) */ {
 public:
  RansacLinePercept();
  virtual ~RansacLinePercept();

  RansacLinePercept(const RansacLinePercept& from);

  inline RansacLinePercept& operator=(const RansacLinePercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RansacLinePercept(RansacLinePercept&& from) noexcept
    : RansacLinePercept() {
    *this = ::std::move(from);
  }

  inline RansacLinePercept& operator=(RansacLinePercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RansacLinePercept& default_instance();

  static inline const RansacLinePercept* internal_default_instance() {
    return reinterpret_cast<const RansacLinePercept*>(
               &_RansacLinePercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    20;

  void Swap(RansacLinePercept* other);
  friend void swap(RansacLinePercept& a, RansacLinePercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RansacLinePercept* New() const PROTOBUF_FINAL { return New(NULL); }

  RansacLinePercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RansacLinePercept& from);
  void MergeFrom(const RansacLinePercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RansacLinePercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .naothmessages.LineSegment fieldLineSegments = 1;
  int fieldlinesegments_size() const;
  void clear_fieldlinesegments();
  static const int kFieldLineSegmentsFieldNumber = 1;
  const ::naothmessages::LineSegment& fieldlinesegments(int index) const;
  ::naothmessages::LineSegment* mutable_fieldlinesegments(int index);
  ::naothmessages::LineSegment* add_fieldlinesegments();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::LineSegment >*
      mutable_fieldlinesegments();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::LineSegment >&
      fieldlinesegments() const;

  // @@protoc_insertion_point(class_scope:naothmessages.RansacLinePercept)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::LineSegment > fieldlinesegments_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RansacCirclePercept2018 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.RansacCirclePercept2018) */ {
 public:
  RansacCirclePercept2018();
  virtual ~RansacCirclePercept2018();

  RansacCirclePercept2018(const RansacCirclePercept2018& from);

  inline RansacCirclePercept2018& operator=(const RansacCirclePercept2018& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RansacCirclePercept2018(RansacCirclePercept2018&& from) noexcept
    : RansacCirclePercept2018() {
    *this = ::std::move(from);
  }

  inline RansacCirclePercept2018& operator=(RansacCirclePercept2018&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RansacCirclePercept2018& default_instance();

  static inline const RansacCirclePercept2018* internal_default_instance() {
    return reinterpret_cast<const RansacCirclePercept2018*>(
               &_RansacCirclePercept2018_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    21;

  void Swap(RansacCirclePercept2018* other);
  friend void swap(RansacCirclePercept2018& a, RansacCirclePercept2018& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RansacCirclePercept2018* New() const PROTOBUF_FINAL { return New(NULL); }

  RansacCirclePercept2018* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RansacCirclePercept2018& from);
  void MergeFrom(const RansacCirclePercept2018& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RansacCirclePercept2018* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.DoubleVector2 middleCircleCenter = 2;
  bool has_middlecirclecenter() const;
  void clear_middlecirclecenter();
  static const int kMiddleCircleCenterFieldNumber = 2;
  const ::naothmessages::DoubleVector2& middlecirclecenter() const;
  ::naothmessages::DoubleVector2* mutable_middlecirclecenter();
  ::naothmessages::DoubleVector2* release_middlecirclecenter();
  void set_allocated_middlecirclecenter(::naothmessages::DoubleVector2* middlecirclecenter);

  // optional bool wasSeen = 1;
  bool has_wasseen() const;
  void clear_wasseen();
  static const int kWasSeenFieldNumber = 1;
  bool wasseen() const;
  void set_wasseen(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.RansacCirclePercept2018)
 private:
  void set_has_wasseen();
  void clear_has_wasseen();
  void set_has_middlecirclecenter();
  void clear_has_middlecirclecenter();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector2* middlecirclecenter_;
  bool wasseen_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanLineEndPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.ScanLineEndPoint) */ {
 public:
  ScanLineEndPoint();
  virtual ~ScanLineEndPoint();

  ScanLineEndPoint(const ScanLineEndPoint& from);

  inline ScanLineEndPoint& operator=(const ScanLineEndPoint& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanLineEndPoint(ScanLineEndPoint&& from) noexcept
    : ScanLineEndPoint() {
    *this = ::std::move(from);
  }

  inline ScanLineEndPoint& operator=(ScanLineEndPoint&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanLineEndPoint& default_instance();

  static inline const ScanLineEndPoint* internal_default_instance() {
    return reinterpret_cast<const ScanLineEndPoint*>(
               &_ScanLineEndPoint_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    22;

  void Swap(ScanLineEndPoint* other);
  friend void swap(ScanLineEndPoint& a, ScanLineEndPoint& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanLineEndPoint* New() const PROTOBUF_FINAL { return New(NULL); }

  ScanLineEndPoint* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScanLineEndPoint& from);
  void MergeFrom(const ScanLineEndPoint& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScanLineEndPoint* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.IntVector2 posInImage = 1;
  bool has_posinimage() const;
  void clear_posinimage();
  static const int kPosInImageFieldNumber = 1;
  const ::naothmessages::IntVector2& posinimage() const;
  ::naothmessages::IntVector2* mutable_posinimage();
  ::naothmessages::IntVector2* release_posinimage();
  void set_allocated_posinimage(::naothmessages::IntVector2* posinimage);

  // required .naothmessages.DoubleVector2 posOnField = 2;
  bool has_posonfield() const;
  void clear_posonfield();
  static const int kPosOnFieldFieldNumber = 2;
  const ::naothmessages::DoubleVector2& posonfield() const;
  ::naothmessages::DoubleVector2* mutable_posonfield();
  ::naothmessages::DoubleVector2* release_posonfield();
  void set_allocated_posonfield(::naothmessages::DoubleVector2* posonfield);

  // required .naothmessages.Color color = 3;
  bool has_color() const;
  void clear_color();
  static const int kColorFieldNumber = 3;
  ::naothmessages::Color color() const;
  void set_color(::naothmessages::Color value);

  // required uint32 ScanLineID = 4;
  bool has_scanlineid() const;
  void clear_scanlineid();
  static const int kScanLineIDFieldNumber = 4;
  ::google::protobuf::uint32 scanlineid() const;
  void set_scanlineid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:naothmessages.ScanLineEndPoint)
 private:
  void set_has_posinimage();
  void clear_has_posinimage();
  void set_has_posonfield();
  void clear_has_posonfield();
  void set_has_color();
  void clear_has_color();
  void set_has_scanlineid();
  void clear_has_scanlineid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::IntVector2* posinimage_;
  ::naothmessages::DoubleVector2* posonfield_;
  int color_;
  ::google::protobuf::uint32 scanlineid_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DoubleEdgel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.DoubleEdgel) */ {
 public:
  DoubleEdgel();
  virtual ~DoubleEdgel();

  DoubleEdgel(const DoubleEdgel& from);

  inline DoubleEdgel& operator=(const DoubleEdgel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleEdgel(DoubleEdgel&& from) noexcept
    : DoubleEdgel() {
    *this = ::std::move(from);
  }

  inline DoubleEdgel& operator=(DoubleEdgel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DoubleEdgel& default_instance();

  static inline const DoubleEdgel* internal_default_instance() {
    return reinterpret_cast<const DoubleEdgel*>(
               &_DoubleEdgel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    23;

  void Swap(DoubleEdgel* other);
  friend void swap(DoubleEdgel& a, DoubleEdgel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleEdgel* New() const PROTOBUF_FINAL { return New(NULL); }

  DoubleEdgel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DoubleEdgel& from);
  void MergeFrom(const DoubleEdgel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DoubleEdgel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.DoubleVector2 point = 1;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::naothmessages::DoubleVector2& point() const;
  ::naothmessages::DoubleVector2* mutable_point();
  ::naothmessages::DoubleVector2* release_point();
  void set_allocated_point(::naothmessages::DoubleVector2* point);

  // required .naothmessages.DoubleVector2 direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  const ::naothmessages::DoubleVector2& direction() const;
  ::naothmessages::DoubleVector2* mutable_direction();
  ::naothmessages::DoubleVector2* release_direction();
  void set_allocated_direction(::naothmessages::DoubleVector2* direction);

  // @@protoc_insertion_point(class_scope:naothmessages.DoubleEdgel)
 private:
  void set_has_point();
  void clear_has_point();
  void set_has_direction();
  void clear_has_direction();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector2* point_;
  ::naothmessages::DoubleVector2* direction_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Edgel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.Edgel) */ {
 public:
  Edgel();
  virtual ~Edgel();

  Edgel(const Edgel& from);

  inline Edgel& operator=(const Edgel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Edgel(Edgel&& from) noexcept
    : Edgel() {
    *this = ::std::move(from);
  }

  inline Edgel& operator=(Edgel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Edgel& default_instance();

  static inline const Edgel* internal_default_instance() {
    return reinterpret_cast<const Edgel*>(
               &_Edgel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    24;

  void Swap(Edgel* other);
  friend void swap(Edgel& a, Edgel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Edgel* New() const PROTOBUF_FINAL { return New(NULL); }

  Edgel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Edgel& from);
  void MergeFrom(const Edgel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Edgel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.IntVector2 point = 1;
  bool has_point() const;
  void clear_point();
  static const int kPointFieldNumber = 1;
  const ::naothmessages::IntVector2& point() const;
  ::naothmessages::IntVector2* mutable_point();
  ::naothmessages::IntVector2* release_point();
  void set_allocated_point(::naothmessages::IntVector2* point);

  // required .naothmessages.DoubleVector2 direction = 2;
  bool has_direction() const;
  void clear_direction();
  static const int kDirectionFieldNumber = 2;
  const ::naothmessages::DoubleVector2& direction() const;
  ::naothmessages::DoubleVector2* mutable_direction();
  ::naothmessages::DoubleVector2* release_direction();
  void set_allocated_direction(::naothmessages::DoubleVector2* direction);

  // @@protoc_insertion_point(class_scope:naothmessages.Edgel)
 private:
  void set_has_point();
  void clear_has_point();
  void set_has_direction();
  void clear_has_direction();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::IntVector2* point_;
  ::naothmessages::DoubleVector2* direction_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class EdgelPair : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.EdgelPair) */ {
 public:
  EdgelPair();
  virtual ~EdgelPair();

  EdgelPair(const EdgelPair& from);

  inline EdgelPair& operator=(const EdgelPair& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  EdgelPair(EdgelPair&& from) noexcept
    : EdgelPair() {
    *this = ::std::move(from);
  }

  inline EdgelPair& operator=(EdgelPair&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EdgelPair& default_instance();

  static inline const EdgelPair* internal_default_instance() {
    return reinterpret_cast<const EdgelPair*>(
               &_EdgelPair_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    25;

  void Swap(EdgelPair* other);
  friend void swap(EdgelPair& a, EdgelPair& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline EdgelPair* New() const PROTOBUF_FINAL { return New(NULL); }

  EdgelPair* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const EdgelPair& from);
  void MergeFrom(const EdgelPair& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(EdgelPair* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 begin = 1;
  bool has_begin() const;
  void clear_begin();
  static const int kBeginFieldNumber = 1;
  ::google::protobuf::int32 begin() const;
  void set_begin(::google::protobuf::int32 value);

  // required int32 end = 2;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 2;
  ::google::protobuf::int32 end() const;
  void set_end(::google::protobuf::int32 value);

  // required int32 id = 3;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 3;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional bool adaptive = 4;
  bool has_adaptive() const;
  void clear_adaptive();
  static const int kAdaptiveFieldNumber = 4;
  bool adaptive() const;
  void set_adaptive(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.EdgelPair)
 private:
  void set_has_begin();
  void clear_has_begin();
  void set_has_end();
  void clear_has_end();
  void set_has_id();
  void clear_has_id();
  void set_has_adaptive();
  void clear_has_adaptive();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 begin_;
  ::google::protobuf::int32 end_;
  ::google::protobuf::int32 id_;
  bool adaptive_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ScanLineEdgelPercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.ScanLineEdgelPercept) */ {
 public:
  ScanLineEdgelPercept();
  virtual ~ScanLineEdgelPercept();

  ScanLineEdgelPercept(const ScanLineEdgelPercept& from);

  inline ScanLineEdgelPercept& operator=(const ScanLineEdgelPercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ScanLineEdgelPercept(ScanLineEdgelPercept&& from) noexcept
    : ScanLineEdgelPercept() {
    *this = ::std::move(from);
  }

  inline ScanLineEdgelPercept& operator=(ScanLineEdgelPercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ScanLineEdgelPercept& default_instance();

  static inline const ScanLineEdgelPercept* internal_default_instance() {
    return reinterpret_cast<const ScanLineEdgelPercept*>(
               &_ScanLineEdgelPercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    26;

  void Swap(ScanLineEdgelPercept* other);
  friend void swap(ScanLineEdgelPercept& a, ScanLineEdgelPercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ScanLineEdgelPercept* New() const PROTOBUF_FINAL { return New(NULL); }

  ScanLineEdgelPercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ScanLineEdgelPercept& from);
  void MergeFrom(const ScanLineEdgelPercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ScanLineEdgelPercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .naothmessages.Edgel edgels = 1;
  int edgels_size() const;
  void clear_edgels();
  static const int kEdgelsFieldNumber = 1;
  const ::naothmessages::Edgel& edgels(int index) const;
  ::naothmessages::Edgel* mutable_edgels(int index);
  ::naothmessages::Edgel* add_edgels();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >*
      mutable_edgels();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >&
      edgels() const;

  // repeated .naothmessages.ScanLineEndPoint endPoints = 2;
  int endpoints_size() const;
  void clear_endpoints();
  static const int kEndPointsFieldNumber = 2;
  const ::naothmessages::ScanLineEndPoint& endpoints(int index) const;
  ::naothmessages::ScanLineEndPoint* mutable_endpoints(int index);
  ::naothmessages::ScanLineEndPoint* add_endpoints();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::ScanLineEndPoint >*
      mutable_endpoints();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::ScanLineEndPoint >&
      endpoints() const;

  // repeated .naothmessages.EdgelPair pairs = 3;
  int pairs_size() const;
  void clear_pairs();
  static const int kPairsFieldNumber = 3;
  const ::naothmessages::EdgelPair& pairs(int index) const;
  ::naothmessages::EdgelPair* mutable_pairs(int index);
  ::naothmessages::EdgelPair* add_pairs();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::EdgelPair >*
      mutable_pairs();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::EdgelPair >&
      pairs() const;

  // @@protoc_insertion_point(class_scope:naothmessages.ScanLineEdgelPercept)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel > edgels_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::ScanLineEndPoint > endpoints_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::EdgelPair > pairs_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LineGraphPercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.LineGraphPercept) */ {
 public:
  LineGraphPercept();
  virtual ~LineGraphPercept();

  LineGraphPercept(const LineGraphPercept& from);

  inline LineGraphPercept& operator=(const LineGraphPercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LineGraphPercept(LineGraphPercept&& from) noexcept
    : LineGraphPercept() {
    *this = ::std::move(from);
  }

  inline LineGraphPercept& operator=(LineGraphPercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LineGraphPercept& default_instance();

  static inline const LineGraphPercept* internal_default_instance() {
    return reinterpret_cast<const LineGraphPercept*>(
               &_LineGraphPercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    27;

  void Swap(LineGraphPercept* other);
  friend void swap(LineGraphPercept& a, LineGraphPercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LineGraphPercept* New() const PROTOBUF_FINAL { return New(NULL); }

  LineGraphPercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const LineGraphPercept& from);
  void MergeFrom(const LineGraphPercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(LineGraphPercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .naothmessages.Edgel edgelsOnField = 1;
  int edgelsonfield_size() const;
  void clear_edgelsonfield();
  static const int kEdgelsOnFieldFieldNumber = 1;
  const ::naothmessages::Edgel& edgelsonfield(int index) const;
  ::naothmessages::Edgel* mutable_edgelsonfield(int index);
  ::naothmessages::Edgel* add_edgelsonfield();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >*
      mutable_edgelsonfield();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >&
      edgelsonfield() const;

  // repeated .naothmessages.DoubleEdgel edgelsInImageTop = 2;
  int edgelsinimagetop_size() const;
  void clear_edgelsinimagetop();
  static const int kEdgelsInImageTopFieldNumber = 2;
  const ::naothmessages::DoubleEdgel& edgelsinimagetop(int index) const;
  ::naothmessages::DoubleEdgel* mutable_edgelsinimagetop(int index);
  ::naothmessages::DoubleEdgel* add_edgelsinimagetop();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleEdgel >*
      mutable_edgelsinimagetop();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleEdgel >&
      edgelsinimagetop() const;

  // repeated .naothmessages.DoubleEdgel edgelsInImage = 3;
  int edgelsinimage_size() const;
  void clear_edgelsinimage();
  static const int kEdgelsInImageFieldNumber = 3;
  const ::naothmessages::DoubleEdgel& edgelsinimage(int index) const;
  ::naothmessages::DoubleEdgel* mutable_edgelsinimage(int index);
  ::naothmessages::DoubleEdgel* add_edgelsinimage();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleEdgel >*
      mutable_edgelsinimage();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleEdgel >&
      edgelsinimage() const;

  // @@protoc_insertion_point(class_scope:naothmessages.LineGraphPercept)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel > edgelsonfield_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleEdgel > edgelsinimagetop_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleEdgel > edgelsinimage_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StepControlStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.StepControlStatus) */ {
 public:
  StepControlStatus();
  virtual ~StepControlStatus();

  StepControlStatus(const StepControlStatus& from);

  inline StepControlStatus& operator=(const StepControlStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StepControlStatus(StepControlStatus&& from) noexcept
    : StepControlStatus() {
    *this = ::std::move(from);
  }

  inline StepControlStatus& operator=(StepControlStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StepControlStatus& default_instance();

  static inline const StepControlStatus* internal_default_instance() {
    return reinterpret_cast<const StepControlStatus*>(
               &_StepControlStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    28;

  void Swap(StepControlStatus* other);
  friend void swap(StepControlStatus& a, StepControlStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StepControlStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  StepControlStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StepControlStatus& from);
  void MergeFrom(const StepControlStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StepControlStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 stepID = 1;
  bool has_stepid() const;
  void clear_stepid();
  static const int kStepIDFieldNumber = 1;
  ::google::protobuf::uint32 stepid() const;
  void set_stepid(::google::protobuf::uint32 value);

  // required uint32 moveableFoot = 2;
  bool has_moveablefoot() const;
  void clear_moveablefoot();
  static const int kMoveableFootFieldNumber = 2;
  ::google::protobuf::uint32 moveablefoot() const;
  void set_moveablefoot(::google::protobuf::uint32 value);

  // required uint32 stepRequestID = 3;
  bool has_steprequestid() const;
  void clear_steprequestid();
  static const int kStepRequestIDFieldNumber = 3;
  ::google::protobuf::uint32 steprequestid() const;
  void set_steprequestid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:naothmessages.StepControlStatus)
 private:
  void set_has_stepid();
  void clear_has_stepid();
  void set_has_moveablefoot();
  void clear_has_moveablefoot();
  void set_has_steprequestid();
  void clear_has_steprequestid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 stepid_;
  ::google::protobuf::uint32 moveablefoot_;
  ::google::protobuf::uint32 steprequestid_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MotionStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.MotionStatus) */ {
 public:
  MotionStatus();
  virtual ~MotionStatus();

  MotionStatus(const MotionStatus& from);

  inline MotionStatus& operator=(const MotionStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MotionStatus(MotionStatus&& from) noexcept
    : MotionStatus() {
    *this = ::std::move(from);
  }

  inline MotionStatus& operator=(MotionStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotionStatus& default_instance();

  static inline const MotionStatus* internal_default_instance() {
    return reinterpret_cast<const MotionStatus*>(
               &_MotionStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    29;

  void Swap(MotionStatus* other);
  friend void swap(MotionStatus& a, MotionStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MotionStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  MotionStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MotionStatus& from);
  void MergeFrom(const MotionStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MotionStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.Pose2D plannedMotionLeftFoot = 6;
  bool has_plannedmotionleftfoot() const;
  void clear_plannedmotionleftfoot();
  static const int kPlannedMotionLeftFootFieldNumber = 6;
  const ::naothmessages::Pose2D& plannedmotionleftfoot() const;
  ::naothmessages::Pose2D* mutable_plannedmotionleftfoot();
  ::naothmessages::Pose2D* release_plannedmotionleftfoot();
  void set_allocated_plannedmotionleftfoot(::naothmessages::Pose2D* plannedmotionleftfoot);

  // required .naothmessages.Pose2D plannedMotionRightFoot = 7;
  bool has_plannedmotionrightfoot() const;
  void clear_plannedmotionrightfoot();
  static const int kPlannedMotionRightFootFieldNumber = 7;
  const ::naothmessages::Pose2D& plannedmotionrightfoot() const;
  ::naothmessages::Pose2D* mutable_plannedmotionrightfoot();
  ::naothmessages::Pose2D* release_plannedmotionrightfoot();
  void set_allocated_plannedmotionrightfoot(::naothmessages::Pose2D* plannedmotionrightfoot);

  // required .naothmessages.Pose2D plannedMotionHip = 8;
  bool has_plannedmotionhip() const;
  void clear_plannedmotionhip();
  static const int kPlannedMotionHipFieldNumber = 8;
  const ::naothmessages::Pose2D& plannedmotionhip() const;
  ::naothmessages::Pose2D* mutable_plannedmotionhip();
  ::naothmessages::Pose2D* release_plannedmotionhip();
  void set_allocated_plannedmotionhip(::naothmessages::Pose2D* plannedmotionhip);

  // optional .naothmessages.StepControlStatus stepControlStatus = 9;
  bool has_stepcontrolstatus() const;
  void clear_stepcontrolstatus();
  static const int kStepControlStatusFieldNumber = 9;
  const ::naothmessages::StepControlStatus& stepcontrolstatus() const;
  ::naothmessages::StepControlStatus* mutable_stepcontrolstatus();
  ::naothmessages::StepControlStatus* release_stepcontrolstatus();
  void set_allocated_stepcontrolstatus(::naothmessages::StepControlStatus* stepcontrolstatus);

  // required uint32 time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint32 time() const;
  void set_time(::google::protobuf::uint32 value);

  // required uint32 lastMotion = 2;
  bool has_lastmotion() const;
  void clear_lastmotion();
  static const int kLastMotionFieldNumber = 2;
  ::google::protobuf::uint32 lastmotion() const;
  void set_lastmotion(::google::protobuf::uint32 value);

  // required uint32 currentMotion = 3;
  bool has_currentmotion() const;
  void clear_currentmotion();
  static const int kCurrentMotionFieldNumber = 3;
  ::google::protobuf::uint32 currentmotion() const;
  void set_currentmotion(::google::protobuf::uint32 value);

  // required uint32 headMotion = 4;
  bool has_headmotion() const;
  void clear_headmotion();
  static const int kHeadMotionFieldNumber = 4;
  ::google::protobuf::uint32 headmotion() const;
  void set_headmotion(::google::protobuf::uint32 value);

  // required uint32 currentMotionState = 5;
  bool has_currentmotionstate() const;
  void clear_currentmotionstate();
  static const int kCurrentMotionStateFieldNumber = 5;
  ::google::protobuf::uint32 currentmotionstate() const;
  void set_currentmotionstate(::google::protobuf::uint32 value);

  // optional bool target_reached = 10;
  bool has_target_reached() const;
  void clear_target_reached();
  static const int kTargetReachedFieldNumber = 10;
  bool target_reached() const;
  void set_target_reached(bool value);

  // optional bool head_target_reached = 11;
  bool has_head_target_reached() const;
  void clear_head_target_reached();
  static const int kHeadTargetReachedFieldNumber = 11;
  bool head_target_reached() const;
  void set_head_target_reached(bool value);

  // optional bool head_got_stuck = 12;
  bool has_head_got_stuck() const;
  void clear_head_got_stuck();
  static const int kHeadGotStuckFieldNumber = 12;
  bool head_got_stuck() const;
  void set_head_got_stuck(bool value);

  // optional bool walk_emergency_stop = 13;
  bool has_walk_emergency_stop() const;
  void clear_walk_emergency_stop();
  static const int kWalkEmergencyStopFieldNumber = 13;
  bool walk_emergency_stop() const;
  void set_walk_emergency_stop(bool value);

  // optional bool head_at_rest = 14;
  bool has_head_at_rest() const;
  void clear_head_at_rest();
  static const int kHeadAtRestFieldNumber = 14;
  bool head_at_rest() const;
  void set_head_at_rest(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.MotionStatus)
 private:
  void set_has_time();
  void clear_has_time();
  void set_has_lastmotion();
  void clear_has_lastmotion();
  void set_has_currentmotion();
  void clear_has_currentmotion();
  void set_has_headmotion();
  void clear_has_headmotion();
  void set_has_currentmotionstate();
  void clear_has_currentmotionstate();
  void set_has_plannedmotionleftfoot();
  void clear_has_plannedmotionleftfoot();
  void set_has_plannedmotionrightfoot();
  void clear_has_plannedmotionrightfoot();
  void set_has_plannedmotionhip();
  void clear_has_plannedmotionhip();
  void set_has_stepcontrolstatus();
  void clear_has_stepcontrolstatus();
  void set_has_target_reached();
  void clear_has_target_reached();
  void set_has_head_target_reached();
  void clear_has_head_target_reached();
  void set_has_head_got_stuck();
  void clear_has_head_got_stuck();
  void set_has_walk_emergency_stop();
  void clear_has_walk_emergency_stop();
  void set_has_head_at_rest();
  void clear_has_head_at_rest();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::Pose2D* plannedmotionleftfoot_;
  ::naothmessages::Pose2D* plannedmotionrightfoot_;
  ::naothmessages::Pose2D* plannedmotionhip_;
  ::naothmessages::StepControlStatus* stepcontrolstatus_;
  ::google::protobuf::uint32 time_;
  ::google::protobuf::uint32 lastmotion_;
  ::google::protobuf::uint32 currentmotion_;
  ::google::protobuf::uint32 headmotion_;
  ::google::protobuf::uint32 currentmotionstate_;
  bool target_reached_;
  bool head_target_reached_;
  bool head_got_stuck_;
  bool walk_emergency_stop_;
  bool head_at_rest_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class OdometryData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.OdometryData) */ {
 public:
  OdometryData();
  virtual ~OdometryData();

  OdometryData(const OdometryData& from);

  inline OdometryData& operator=(const OdometryData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OdometryData(OdometryData&& from) noexcept
    : OdometryData() {
    *this = ::std::move(from);
  }

  inline OdometryData& operator=(OdometryData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OdometryData& default_instance();

  static inline const OdometryData* internal_default_instance() {
    return reinterpret_cast<const OdometryData*>(
               &_OdometryData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    30;

  void Swap(OdometryData* other);
  friend void swap(OdometryData& a, OdometryData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OdometryData* New() const PROTOBUF_FINAL { return New(NULL); }

  OdometryData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const OdometryData& from);
  void MergeFrom(const OdometryData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(OdometryData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.Pose2D pose = 1;
  bool has_pose() const;
  void clear_pose();
  static const int kPoseFieldNumber = 1;
  const ::naothmessages::Pose2D& pose() const;
  ::naothmessages::Pose2D* mutable_pose();
  ::naothmessages::Pose2D* release_pose();
  void set_allocated_pose(::naothmessages::Pose2D* pose);

  // @@protoc_insertion_point(class_scope:naothmessages.OdometryData)
 private:
  void set_has_pose();
  void clear_has_pose();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::Pose2D* pose_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BodyState : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.BodyState) */ {
 public:
  BodyState();
  virtual ~BodyState();

  BodyState(const BodyState& from);

  inline BodyState& operator=(const BodyState& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BodyState(BodyState&& from) noexcept
    : BodyState() {
    *this = ::std::move(from);
  }

  inline BodyState& operator=(BodyState&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BodyState& default_instance();

  static inline const BodyState* internal_default_instance() {
    return reinterpret_cast<const BodyState*>(
               &_BodyState_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    31;

  void Swap(BodyState* other);
  friend void swap(BodyState& a, BodyState& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BodyState* New() const PROTOBUF_FINAL { return New(NULL); }

  BodyState* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BodyState& from);
  void MergeFrom(const BodyState& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BodyState* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool isLiftedUp = 1;
  bool has_isliftedup() const;
  void clear_isliftedup();
  static const int kIsLiftedUpFieldNumber = 1;
  bool isliftedup() const;
  void set_isliftedup(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.BodyState)
 private:
  void set_has_isliftedup();
  void clear_has_isliftedup();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool isliftedup_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BodyStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.BodyStatus) */ {
 public:
  BodyStatus();
  virtual ~BodyStatus();

  BodyStatus(const BodyStatus& from);

  inline BodyStatus& operator=(const BodyStatus& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BodyStatus(BodyStatus&& from) noexcept
    : BodyStatus() {
    *this = ::std::move(from);
  }

  inline BodyStatus& operator=(BodyStatus&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BodyStatus& default_instance();

  static inline const BodyStatus* internal_default_instance() {
    return reinterpret_cast<const BodyStatus*>(
               &_BodyStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    32;

  void Swap(BodyStatus* other);
  friend void swap(BodyStatus& a, BodyStatus& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BodyStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  BodyStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BodyStatus& from);
  void MergeFrom(const BodyStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BodyStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double currentSum = 1;
  int currentsum_size() const;
  void clear_currentsum();
  static const int kCurrentSumFieldNumber = 1;
  double currentsum(int index) const;
  void set_currentsum(int index, double value);
  void add_currentsum(double value);
  const ::google::protobuf::RepeatedField< double >&
      currentsum() const;
  ::google::protobuf::RepeatedField< double >*
      mutable_currentsum();

  // required uint32 timestamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  ::google::protobuf::uint32 timestamp() const;
  void set_timestamp(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:naothmessages.BodyStatus)
 private:
  void set_has_timestamp();
  void clear_has_timestamp();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > currentsum_;
  ::google::protobuf::uint32 timestamp_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CalibrationData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.CalibrationData) */ {
 public:
  CalibrationData();
  virtual ~CalibrationData();

  CalibrationData(const CalibrationData& from);

  inline CalibrationData& operator=(const CalibrationData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CalibrationData(CalibrationData&& from) noexcept
    : CalibrationData() {
    *this = ::std::move(from);
  }

  inline CalibrationData& operator=(CalibrationData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationData& default_instance();

  static inline const CalibrationData* internal_default_instance() {
    return reinterpret_cast<const CalibrationData*>(
               &_CalibrationData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    33;

  void Swap(CalibrationData* other);
  friend void swap(CalibrationData& a, CalibrationData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalibrationData* New() const PROTOBUF_FINAL { return New(NULL); }

  CalibrationData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CalibrationData& from);
  void MergeFrom(const CalibrationData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CalibrationData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.DoubleVector2 inertialSensorOffset = 1;
  bool has_inertialsensoroffset() const;
  void clear_inertialsensoroffset();
  static const int kInertialSensorOffsetFieldNumber = 1;
  const ::naothmessages::DoubleVector2& inertialsensoroffset() const;
  ::naothmessages::DoubleVector2* mutable_inertialsensoroffset();
  ::naothmessages::DoubleVector2* release_inertialsensoroffset();
  void set_allocated_inertialsensoroffset(::naothmessages::DoubleVector2* inertialsensoroffset);

  // optional .naothmessages.DoubleVector3 accSensorOffset = 3;
  bool has_accsensoroffset() const;
  void clear_accsensoroffset();
  static const int kAccSensorOffsetFieldNumber = 3;
  const ::naothmessages::DoubleVector3& accsensoroffset() const;
  ::naothmessages::DoubleVector3* mutable_accsensoroffset();
  ::naothmessages::DoubleVector3* release_accsensoroffset();
  void set_allocated_accsensoroffset(::naothmessages::DoubleVector3* accsensoroffset);

  // optional .naothmessages.DoubleVector3 gyroSensorOffset = 5;
  bool has_gyrosensoroffset() const;
  void clear_gyrosensoroffset();
  static const int kGyroSensorOffsetFieldNumber = 5;
  const ::naothmessages::DoubleVector3& gyrosensoroffset() const;
  ::naothmessages::DoubleVector3* mutable_gyrosensoroffset();
  ::naothmessages::DoubleVector3* release_gyrosensoroffset();
  void set_allocated_gyrosensoroffset(::naothmessages::DoubleVector3* gyrosensoroffset);

  // required bool calibrated = 4;
  bool has_calibrated() const;
  void clear_calibrated();
  static const int kCalibratedFieldNumber = 4;
  bool calibrated() const;
  void set_calibrated(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.CalibrationData)
 private:
  void set_has_inertialsensoroffset();
  void clear_has_inertialsensoroffset();
  void set_has_gyrosensoroffset();
  void clear_has_gyrosensoroffset();
  void set_has_accsensoroffset();
  void clear_has_accsensoroffset();
  void set_has_calibrated();
  void clear_has_calibrated();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector2* inertialsensoroffset_;
  ::naothmessages::DoubleVector3* accsensoroffset_;
  ::naothmessages::DoubleVector3* gyrosensoroffset_;
  bool calibrated_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class InertialModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.InertialModel) */ {
 public:
  InertialModel();
  virtual ~InertialModel();

  InertialModel(const InertialModel& from);

  inline InertialModel& operator=(const InertialModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InertialModel(InertialModel&& from) noexcept
    : InertialModel() {
    *this = ::std::move(from);
  }

  inline InertialModel& operator=(InertialModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InertialModel& default_instance();

  static inline const InertialModel* internal_default_instance() {
    return reinterpret_cast<const InertialModel*>(
               &_InertialModel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    34;

  void Swap(InertialModel* other);
  friend void swap(InertialModel& a, InertialModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InertialModel* New() const PROTOBUF_FINAL { return New(NULL); }

  InertialModel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const InertialModel& from);
  void MergeFrom(const InertialModel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(InertialModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.DoubleVector2 orientation = 1;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 1;
  const ::naothmessages::DoubleVector2& orientation() const;
  ::naothmessages::DoubleVector2* mutable_orientation();
  ::naothmessages::DoubleVector2* release_orientation();
  void set_allocated_orientation(::naothmessages::DoubleVector2* orientation);

  // @@protoc_insertion_point(class_scope:naothmessages.InertialModel)
 private:
  void set_has_orientation();
  void clear_has_orientation();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector2* orientation_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CameraMatrixCalibration : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.CameraMatrixCalibration) */ {
 public:
  CameraMatrixCalibration();
  virtual ~CameraMatrixCalibration();

  CameraMatrixCalibration(const CameraMatrixCalibration& from);

  inline CameraMatrixCalibration& operator=(const CameraMatrixCalibration& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CameraMatrixCalibration(CameraMatrixCalibration&& from) noexcept
    : CameraMatrixCalibration() {
    *this = ::std::move(from);
  }

  inline CameraMatrixCalibration& operator=(CameraMatrixCalibration&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraMatrixCalibration& default_instance();

  static inline const CameraMatrixCalibration* internal_default_instance() {
    return reinterpret_cast<const CameraMatrixCalibration*>(
               &_CameraMatrixCalibration_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    35;

  void Swap(CameraMatrixCalibration* other);
  friend void swap(CameraMatrixCalibration& a, CameraMatrixCalibration& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CameraMatrixCalibration* New() const PROTOBUF_FINAL { return New(NULL); }

  CameraMatrixCalibration* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CameraMatrixCalibration& from);
  void MergeFrom(const CameraMatrixCalibration& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CameraMatrixCalibration* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .naothmessages.DoubleVector2 correctionOffset = 1 [deprecated = true];
  GOOGLE_PROTOBUF_DEPRECATED_ATTR int correctionoffset_size() const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR void clear_correctionoffset();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR static const int kCorrectionOffsetFieldNumber = 1;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::naothmessages::DoubleVector2& correctionoffset(int index) const;
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::naothmessages::DoubleVector2* mutable_correctionoffset(int index);
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::naothmessages::DoubleVector2* add_correctionoffset();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
      mutable_correctionoffset();
  GOOGLE_PROTOBUF_DEPRECATED_ATTR const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
      correctionoffset() const;

  // repeated .naothmessages.DoubleVector3 correctionOffsetCam = 4;
  int correctionoffsetcam_size() const;
  void clear_correctionoffsetcam();
  static const int kCorrectionOffsetCamFieldNumber = 4;
  const ::naothmessages::DoubleVector3& correctionoffsetcam(int index) const;
  ::naothmessages::DoubleVector3* mutable_correctionoffsetcam(int index);
  ::naothmessages::DoubleVector3* add_correctionoffsetcam();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector3 >*
      mutable_correctionoffsetcam();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector3 >&
      correctionoffsetcam() const;

  // optional .naothmessages.DoubleVector2 correctionOffsetBody = 2;
  bool has_correctionoffsetbody() const;
  void clear_correctionoffsetbody();
  static const int kCorrectionOffsetBodyFieldNumber = 2;
  const ::naothmessages::DoubleVector2& correctionoffsetbody() const;
  ::naothmessages::DoubleVector2* mutable_correctionoffsetbody();
  ::naothmessages::DoubleVector2* release_correctionoffsetbody();
  void set_allocated_correctionoffsetbody(::naothmessages::DoubleVector2* correctionoffsetbody);

  // optional .naothmessages.DoubleVector3 correctionOffsetHead = 3;
  bool has_correctionoffsethead() const;
  void clear_correctionoffsethead();
  static const int kCorrectionOffsetHeadFieldNumber = 3;
  const ::naothmessages::DoubleVector3& correctionoffsethead() const;
  ::naothmessages::DoubleVector3* mutable_correctionoffsethead();
  ::naothmessages::DoubleVector3* release_correctionoffsethead();
  void set_allocated_correctionoffsethead(::naothmessages::DoubleVector3* correctionoffsethead);

  // @@protoc_insertion_point(class_scope:naothmessages.CameraMatrixCalibration)
 private:
  void set_has_correctionoffsetbody();
  void clear_has_correctionoffsetbody();
  void set_has_correctionoffsethead();
  void clear_has_correctionoffsethead();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 > correctionoffset_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector3 > correctionoffsetcam_;
  ::naothmessages::DoubleVector2* correctionoffsetbody_;
  ::naothmessages::DoubleVector3* correctionoffsethead_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BallCandidates_Patch : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.BallCandidates.Patch) */ {
 public:
  BallCandidates_Patch();
  virtual ~BallCandidates_Patch();

  BallCandidates_Patch(const BallCandidates_Patch& from);

  inline BallCandidates_Patch& operator=(const BallCandidates_Patch& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BallCandidates_Patch(BallCandidates_Patch&& from) noexcept
    : BallCandidates_Patch() {
    *this = ::std::move(from);
  }

  inline BallCandidates_Patch& operator=(BallCandidates_Patch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallCandidates_Patch& default_instance();

  static inline const BallCandidates_Patch* internal_default_instance() {
    return reinterpret_cast<const BallCandidates_Patch*>(
               &_BallCandidates_Patch_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    36;

  void Swap(BallCandidates_Patch* other);
  friend void swap(BallCandidates_Patch& a, BallCandidates_Patch& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BallCandidates_Patch* New() const PROTOBUF_FINAL { return New(NULL); }

  BallCandidates_Patch* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BallCandidates_Patch& from);
  void MergeFrom(const BallCandidates_Patch& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BallCandidates_Patch* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef BallCandidates_Patch_Type Type;
  static const Type Y =
    BallCandidates_Patch_Type_Y;
  static const Type YUV =
    BallCandidates_Patch_Type_YUV;
  static const Type YUVC =
    BallCandidates_Patch_Type_YUVC;
  static inline bool Type_IsValid(int value) {
    return BallCandidates_Patch_Type_IsValid(value);
  }
  static const Type Type_MIN =
    BallCandidates_Patch_Type_Type_MIN;
  static const Type Type_MAX =
    BallCandidates_Patch_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    BallCandidates_Patch_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return BallCandidates_Patch_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return BallCandidates_Patch_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return BallCandidates_Patch_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bytes data = 5;
  bool has_data() const;
  void clear_data();
  static const int kDataFieldNumber = 5;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const void* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // required .naothmessages.IntVector2 min = 1;
  bool has_min() const;
  void clear_min();
  static const int kMinFieldNumber = 1;
  const ::naothmessages::IntVector2& min() const;
  ::naothmessages::IntVector2* mutable_min();
  ::naothmessages::IntVector2* release_min();
  void set_allocated_min(::naothmessages::IntVector2* min);

  // required .naothmessages.IntVector2 max = 2;
  bool has_max() const;
  void clear_max();
  static const int kMaxFieldNumber = 2;
  const ::naothmessages::IntVector2& max() const;
  ::naothmessages::IntVector2* mutable_max();
  ::naothmessages::IntVector2* release_max();
  void set_allocated_max(::naothmessages::IntVector2* max);

  // optional .naothmessages.BallCandidates.Patch.Type type = 3 [default = Y];
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::naothmessages::BallCandidates_Patch_Type type() const;
  void set_type(::naothmessages::BallCandidates_Patch_Type value);

  // @@protoc_insertion_point(class_scope:naothmessages.BallCandidates.Patch)
 private:
  void set_has_min();
  void clear_has_min();
  void set_has_max();
  void clear_has_max();
  void set_has_type();
  void clear_has_type();
  void set_has_data();
  void clear_has_data();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::naothmessages::IntVector2* min_;
  ::naothmessages::IntVector2* max_;
  int type_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class BallCandidates : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.BallCandidates) */ {
 public:
  BallCandidates();
  virtual ~BallCandidates();

  BallCandidates(const BallCandidates& from);

  inline BallCandidates& operator=(const BallCandidates& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BallCandidates(BallCandidates&& from) noexcept
    : BallCandidates() {
    *this = ::std::move(from);
  }

  inline BallCandidates& operator=(BallCandidates&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BallCandidates& default_instance();

  static inline const BallCandidates* internal_default_instance() {
    return reinterpret_cast<const BallCandidates*>(
               &_BallCandidates_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    37;

  void Swap(BallCandidates* other);
  friend void swap(BallCandidates& a, BallCandidates& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BallCandidates* New() const PROTOBUF_FINAL { return New(NULL); }

  BallCandidates* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const BallCandidates& from);
  void MergeFrom(const BallCandidates& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(BallCandidates* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef BallCandidates_Patch Patch;

  // accessors -------------------------------------------------------

  // repeated .naothmessages.BallCandidates.Patch patches = 1;
  int patches_size() const;
  void clear_patches();
  static const int kPatchesFieldNumber = 1;
  const ::naothmessages::BallCandidates_Patch& patches(int index) const;
  ::naothmessages::BallCandidates_Patch* mutable_patches(int index);
  ::naothmessages::BallCandidates_Patch* add_patches();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::BallCandidates_Patch >*
      mutable_patches();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::BallCandidates_Patch >&
      patches() const;

  // @@protoc_insertion_point(class_scope:naothmessages.BallCandidates)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::BallCandidates_Patch > patches_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RemoteControlCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.RemoteControlCommand) */ {
 public:
  RemoteControlCommand();
  virtual ~RemoteControlCommand();

  RemoteControlCommand(const RemoteControlCommand& from);

  inline RemoteControlCommand& operator=(const RemoteControlCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RemoteControlCommand(RemoteControlCommand&& from) noexcept
    : RemoteControlCommand() {
    *this = ::std::move(from);
  }

  inline RemoteControlCommand& operator=(RemoteControlCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RemoteControlCommand& default_instance();

  static inline const RemoteControlCommand* internal_default_instance() {
    return reinterpret_cast<const RemoteControlCommand*>(
               &_RemoteControlCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    38;

  void Swap(RemoteControlCommand* other);
  friend void swap(RemoteControlCommand& a, RemoteControlCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RemoteControlCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  RemoteControlCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RemoteControlCommand& from);
  void MergeFrom(const RemoteControlCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RemoteControlCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RemoteControlCommand_ControlMode ControlMode;
  static const ControlMode DIRECT_CONTROL =
    RemoteControlCommand_ControlMode_DIRECT_CONTROL;
  static const ControlMode LOCK_CONTROL =
    RemoteControlCommand_ControlMode_LOCK_CONTROL;
  static inline bool ControlMode_IsValid(int value) {
    return RemoteControlCommand_ControlMode_IsValid(value);
  }
  static const ControlMode ControlMode_MIN =
    RemoteControlCommand_ControlMode_ControlMode_MIN;
  static const ControlMode ControlMode_MAX =
    RemoteControlCommand_ControlMode_ControlMode_MAX;
  static const int ControlMode_ARRAYSIZE =
    RemoteControlCommand_ControlMode_ControlMode_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ControlMode_descriptor() {
    return RemoteControlCommand_ControlMode_descriptor();
  }
  static inline const ::std::string& ControlMode_Name(ControlMode value) {
    return RemoteControlCommand_ControlMode_Name(value);
  }
  static inline bool ControlMode_Parse(const ::std::string& name,
      ControlMode* value) {
    return RemoteControlCommand_ControlMode_Parse(name, value);
  }

  typedef RemoteControlCommand_ActionType ActionType;
  static const ActionType NONE =
    RemoteControlCommand_ActionType_NONE;
  static const ActionType STAND =
    RemoteControlCommand_ActionType_STAND;
  static const ActionType WALK =
    RemoteControlCommand_ActionType_WALK;
  static const ActionType KICK_RIGHT =
    RemoteControlCommand_ActionType_KICK_RIGHT;
  static const ActionType KICK_LEFT =
    RemoteControlCommand_ActionType_KICK_LEFT;
  static const ActionType KICK_FORWARD_LEFT =
    RemoteControlCommand_ActionType_KICK_FORWARD_LEFT;
  static const ActionType KICK_FORWARD_RIGHT =
    RemoteControlCommand_ActionType_KICK_FORWARD_RIGHT;
  static inline bool ActionType_IsValid(int value) {
    return RemoteControlCommand_ActionType_IsValid(value);
  }
  static const ActionType ActionType_MIN =
    RemoteControlCommand_ActionType_ActionType_MIN;
  static const ActionType ActionType_MAX =
    RemoteControlCommand_ActionType_ActionType_MAX;
  static const int ActionType_ARRAYSIZE =
    RemoteControlCommand_ActionType_ActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ActionType_descriptor() {
    return RemoteControlCommand_ActionType_descriptor();
  }
  static inline const ::std::string& ActionType_Name(ActionType value) {
    return RemoteControlCommand_ActionType_Name(value);
  }
  static inline bool ActionType_Parse(const ::std::string& name,
      ActionType* value) {
    return RemoteControlCommand_ActionType_Parse(name, value);
  }

  typedef RemoteControlCommand_SecondActionType SecondActionType;
  static const SecondActionType SECOND_NONE =
    RemoteControlCommand_SecondActionType_SECOND_NONE;
  static const SecondActionType BLINK =
    RemoteControlCommand_SecondActionType_BLINK;
  static const SecondActionType SAY =
    RemoteControlCommand_SecondActionType_SAY;
  static inline bool SecondActionType_IsValid(int value) {
    return RemoteControlCommand_SecondActionType_IsValid(value);
  }
  static const SecondActionType SecondActionType_MIN =
    RemoteControlCommand_SecondActionType_SecondActionType_MIN;
  static const SecondActionType SecondActionType_MAX =
    RemoteControlCommand_SecondActionType_SecondActionType_MAX;
  static const int SecondActionType_ARRAYSIZE =
    RemoteControlCommand_SecondActionType_SecondActionType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  SecondActionType_descriptor() {
    return RemoteControlCommand_SecondActionType_descriptor();
  }
  static inline const ::std::string& SecondActionType_Name(SecondActionType value) {
    return RemoteControlCommand_SecondActionType_Name(value);
  }
  static inline bool SecondActionType_Parse(const ::std::string& name,
      SecondActionType* value) {
    return RemoteControlCommand_SecondActionType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .naothmessages.Pose2D target = 4;
  bool has_target() const;
  void clear_target();
  static const int kTargetFieldNumber = 4;
  const ::naothmessages::Pose2D& target() const;
  ::naothmessages::Pose2D* mutable_target();
  ::naothmessages::Pose2D* release_target();
  void set_allocated_target(::naothmessages::Pose2D* target);

  // optional .naothmessages.RemoteControlCommand.ControlMode controlMode = 1;
  bool has_controlmode() const;
  void clear_controlmode();
  static const int kControlModeFieldNumber = 1;
  ::naothmessages::RemoteControlCommand_ControlMode controlmode() const;
  void set_controlmode(::naothmessages::RemoteControlCommand_ControlMode value);

  // optional .naothmessages.RemoteControlCommand.ActionType action = 2;
  bool has_action() const;
  void clear_action();
  static const int kActionFieldNumber = 2;
  ::naothmessages::RemoteControlCommand_ActionType action() const;
  void set_action(::naothmessages::RemoteControlCommand_ActionType value);

  // optional .naothmessages.RemoteControlCommand.SecondActionType second_action = 3;
  bool has_second_action() const;
  void clear_second_action();
  static const int kSecondActionFieldNumber = 3;
  ::naothmessages::RemoteControlCommand_SecondActionType second_action() const;
  void set_second_action(::naothmessages::RemoteControlCommand_SecondActionType value);

  // @@protoc_insertion_point(class_scope:naothmessages.RemoteControlCommand)
 private:
  void set_has_controlmode();
  void clear_has_controlmode();
  void set_has_action();
  void clear_has_action();
  void set_has_second_action();
  void clear_has_second_action();
  void set_has_target();
  void clear_has_target();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::Pose2D* target_;
  int controlmode_;
  int action_;
  int second_action_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GroundContactModel : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.GroundContactModel) */ {
 public:
  GroundContactModel();
  virtual ~GroundContactModel();

  GroundContactModel(const GroundContactModel& from);

  inline GroundContactModel& operator=(const GroundContactModel& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GroundContactModel(GroundContactModel&& from) noexcept
    : GroundContactModel() {
    *this = ::std::move(from);
  }

  inline GroundContactModel& operator=(GroundContactModel&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroundContactModel& default_instance();

  static inline const GroundContactModel* internal_default_instance() {
    return reinterpret_cast<const GroundContactModel*>(
               &_GroundContactModel_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    39;

  void Swap(GroundContactModel* other);
  friend void swap(GroundContactModel& a, GroundContactModel& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GroundContactModel* New() const PROTOBUF_FINAL { return New(NULL); }

  GroundContactModel* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GroundContactModel& from);
  void MergeFrom(const GroundContactModel& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GroundContactModel* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef GroundContactModel_Foot Foot;
  static const Foot LEFT =
    GroundContactModel_Foot_LEFT;
  static const Foot RIGHT =
    GroundContactModel_Foot_RIGHT;
  static const Foot NONE =
    GroundContactModel_Foot_NONE;
  static inline bool Foot_IsValid(int value) {
    return GroundContactModel_Foot_IsValid(value);
  }
  static const Foot Foot_MIN =
    GroundContactModel_Foot_Foot_MIN;
  static const Foot Foot_MAX =
    GroundContactModel_Foot_Foot_MAX;
  static const int Foot_ARRAYSIZE =
    GroundContactModel_Foot_Foot_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Foot_descriptor() {
    return GroundContactModel_Foot_descriptor();
  }
  static inline const ::std::string& Foot_Name(Foot value) {
    return GroundContactModel_Foot_Name(value);
  }
  static inline bool Foot_Parse(const ::std::string& name,
      Foot* value) {
    return GroundContactModel_Foot_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bool leftGroundContact = 1;
  bool has_leftgroundcontact() const;
  void clear_leftgroundcontact();
  static const int kLeftGroundContactFieldNumber = 1;
  bool leftgroundcontact() const;
  void set_leftgroundcontact(bool value);

  // required bool rightGroundContact = 2;
  bool has_rightgroundcontact() const;
  void clear_rightgroundcontact();
  static const int kRightGroundContactFieldNumber = 2;
  bool rightgroundcontact() const;
  void set_rightgroundcontact(bool value);

  // required .naothmessages.GroundContactModel.Foot supportFoot = 3;
  bool has_supportfoot() const;
  void clear_supportfoot();
  static const int kSupportFootFieldNumber = 3;
  ::naothmessages::GroundContactModel_Foot supportfoot() const;
  void set_supportfoot(::naothmessages::GroundContactModel_Foot value);

  // @@protoc_insertion_point(class_scope:naothmessages.GroundContactModel)
 private:
  void set_has_leftgroundcontact();
  void clear_has_leftgroundcontact();
  void set_has_rightgroundcontact();
  void clear_has_rightgroundcontact();
  void set_has_supportfoot();
  void clear_has_supportfoot();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  bool leftgroundcontact_;
  bool rightgroundcontact_;
  int supportfoot_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CollisionPercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.CollisionPercept) */ {
 public:
  CollisionPercept();
  virtual ~CollisionPercept();

  CollisionPercept(const CollisionPercept& from);

  inline CollisionPercept& operator=(const CollisionPercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CollisionPercept(CollisionPercept&& from) noexcept
    : CollisionPercept() {
    *this = ::std::move(from);
  }

  inline CollisionPercept& operator=(CollisionPercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CollisionPercept& default_instance();

  static inline const CollisionPercept* internal_default_instance() {
    return reinterpret_cast<const CollisionPercept*>(
               &_CollisionPercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    40;

  void Swap(CollisionPercept* other);
  friend void swap(CollisionPercept& a, CollisionPercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CollisionPercept* New() const PROTOBUF_FINAL { return New(NULL); }

  CollisionPercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CollisionPercept& from);
  void MergeFrom(const CollisionPercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CollisionPercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 timeCollisionArmLeft = 1;
  bool has_timecollisionarmleft() const;
  void clear_timecollisionarmleft();
  static const int kTimeCollisionArmLeftFieldNumber = 1;
  ::google::protobuf::uint32 timecollisionarmleft() const;
  void set_timecollisionarmleft(::google::protobuf::uint32 value);

  // required uint32 timeCollisionArmRight = 2;
  bool has_timecollisionarmright() const;
  void clear_timecollisionarmright();
  static const int kTimeCollisionArmRightFieldNumber = 2;
  ::google::protobuf::uint32 timecollisionarmright() const;
  void set_timecollisionarmright(::google::protobuf::uint32 value);

  // required double lastComputedCollisionLeft = 5;
  bool has_lastcomputedcollisionleft() const;
  void clear_lastcomputedcollisionleft();
  static const int kLastComputedCollisionLeftFieldNumber = 5;
  double lastcomputedcollisionleft() const;
  void set_lastcomputedcollisionleft(double value);

  // required double lastComputedCollisionRight = 6;
  bool has_lastcomputedcollisionright() const;
  void clear_lastcomputedcollisionright();
  static const int kLastComputedCollisionRightFieldNumber = 6;
  double lastcomputedcollisionright() const;
  void set_lastcomputedcollisionright(double value);

  // required bool isCollisionLeftBumper = 3;
  bool has_iscollisionleftbumper() const;
  void clear_iscollisionleftbumper();
  static const int kIsCollisionLeftBumperFieldNumber = 3;
  bool iscollisionleftbumper() const;
  void set_iscollisionleftbumper(bool value);

  // required bool isCollisionRightBumper = 4;
  bool has_iscollisionrightbumper() const;
  void clear_iscollisionrightbumper();
  static const int kIsCollisionRightBumperFieldNumber = 4;
  bool iscollisionrightbumper() const;
  void set_iscollisionrightbumper(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.CollisionPercept)
 private:
  void set_has_timecollisionarmleft();
  void clear_has_timecollisionarmleft();
  void set_has_timecollisionarmright();
  void clear_has_timecollisionarmright();
  void set_has_iscollisionleftbumper();
  void clear_has_iscollisionleftbumper();
  void set_has_iscollisionrightbumper();
  void clear_has_iscollisionrightbumper();
  void set_has_lastcomputedcollisionleft();
  void clear_has_lastcomputedcollisionleft();
  void set_has_lastcomputedcollisionright();
  void clear_has_lastcomputedcollisionright();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 timecollisionarmleft_;
  ::google::protobuf::uint32 timecollisionarmright_;
  double lastcomputedcollisionleft_;
  double lastcomputedcollisionright_;
  bool iscollisionleftbumper_;
  bool iscollisionrightbumper_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class IMUData : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.IMUData) */ {
 public:
  IMUData();
  virtual ~IMUData();

  IMUData(const IMUData& from);

  inline IMUData& operator=(const IMUData& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IMUData(IMUData&& from) noexcept
    : IMUData() {
    *this = ::std::move(from);
  }

  inline IMUData& operator=(IMUData&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IMUData& default_instance();

  static inline const IMUData* internal_default_instance() {
    return reinterpret_cast<const IMUData*>(
               &_IMUData_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    41;

  void Swap(IMUData* other);
  friend void swap(IMUData& a, IMUData& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IMUData* New() const PROTOBUF_FINAL { return New(NULL); }

  IMUData* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const IMUData& from);
  void MergeFrom(const IMUData& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(IMUData* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.DoubleVector3 location = 1;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::naothmessages::DoubleVector3& location() const;
  ::naothmessages::DoubleVector3* mutable_location();
  ::naothmessages::DoubleVector3* release_location();
  void set_allocated_location(::naothmessages::DoubleVector3* location);

  // required .naothmessages.DoubleVector3 velocity = 2;
  bool has_velocity() const;
  void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  const ::naothmessages::DoubleVector3& velocity() const;
  ::naothmessages::DoubleVector3* mutable_velocity();
  ::naothmessages::DoubleVector3* release_velocity();
  void set_allocated_velocity(::naothmessages::DoubleVector3* velocity);

  // required .naothmessages.DoubleVector3 acceleration = 3;
  bool has_acceleration() const;
  void clear_acceleration();
  static const int kAccelerationFieldNumber = 3;
  const ::naothmessages::DoubleVector3& acceleration() const;
  ::naothmessages::DoubleVector3* mutable_acceleration();
  ::naothmessages::DoubleVector3* release_acceleration();
  void set_allocated_acceleration(::naothmessages::DoubleVector3* acceleration);

  // optional .naothmessages.DoubleVector3 acceleration_sensor = 4;
  bool has_acceleration_sensor() const;
  void clear_acceleration_sensor();
  static const int kAccelerationSensorFieldNumber = 4;
  const ::naothmessages::DoubleVector3& acceleration_sensor() const;
  ::naothmessages::DoubleVector3* mutable_acceleration_sensor();
  ::naothmessages::DoubleVector3* release_acceleration_sensor();
  void set_allocated_acceleration_sensor(::naothmessages::DoubleVector3* acceleration_sensor);

  // required .naothmessages.DoubleVector3 rotation = 5;
  bool has_rotation() const;
  void clear_rotation();
  static const int kRotationFieldNumber = 5;
  const ::naothmessages::DoubleVector3& rotation() const;
  ::naothmessages::DoubleVector3* mutable_rotation();
  ::naothmessages::DoubleVector3* release_rotation();
  void set_allocated_rotation(::naothmessages::DoubleVector3* rotation);

  // required .naothmessages.DoubleVector3 rotational_velocity = 6;
  bool has_rotational_velocity() const;
  void clear_rotational_velocity();
  static const int kRotationalVelocityFieldNumber = 6;
  const ::naothmessages::DoubleVector3& rotational_velocity() const;
  ::naothmessages::DoubleVector3* mutable_rotational_velocity();
  ::naothmessages::DoubleVector3* release_rotational_velocity();
  void set_allocated_rotational_velocity(::naothmessages::DoubleVector3* rotational_velocity);

  // optional .naothmessages.DoubleVector3 rotational_velocity_sensor = 7;
  bool has_rotational_velocity_sensor() const;
  void clear_rotational_velocity_sensor();
  static const int kRotationalVelocitySensorFieldNumber = 7;
  const ::naothmessages::DoubleVector3& rotational_velocity_sensor() const;
  ::naothmessages::DoubleVector3* mutable_rotational_velocity_sensor();
  ::naothmessages::DoubleVector3* release_rotational_velocity_sensor();
  void set_allocated_rotational_velocity_sensor(::naothmessages::DoubleVector3* rotational_velocity_sensor);

  // required .naothmessages.DoubleVector2 orientation = 8;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 8;
  const ::naothmessages::DoubleVector2& orientation() const;
  ::naothmessages::DoubleVector2* mutable_orientation();
  ::naothmessages::DoubleVector2* release_orientation();
  void set_allocated_orientation(::naothmessages::DoubleVector2* orientation);

  // required .naothmessages.DoubleVector3 orientation_rotvec = 9;
  bool has_orientation_rotvec() const;
  void clear_orientation_rotvec();
  static const int kOrientationRotvecFieldNumber = 9;
  const ::naothmessages::DoubleVector3& orientation_rotvec() const;
  ::naothmessages::DoubleVector3* mutable_orientation_rotvec();
  ::naothmessages::DoubleVector3* release_orientation_rotvec();
  void set_allocated_orientation_rotvec(::naothmessages::DoubleVector3* orientation_rotvec);

  // @@protoc_insertion_point(class_scope:naothmessages.IMUData)
 private:
  void set_has_location();
  void clear_has_location();
  void set_has_velocity();
  void clear_has_velocity();
  void set_has_acceleration();
  void clear_has_acceleration();
  void set_has_acceleration_sensor();
  void clear_has_acceleration_sensor();
  void set_has_rotation();
  void clear_has_rotation();
  void set_has_rotational_velocity();
  void clear_has_rotational_velocity();
  void set_has_rotational_velocity_sensor();
  void clear_has_rotational_velocity_sensor();
  void set_has_orientation();
  void clear_has_orientation();
  void set_has_orientation_rotvec();
  void clear_has_orientation_rotvec();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector3* location_;
  ::naothmessages::DoubleVector3* velocity_;
  ::naothmessages::DoubleVector3* acceleration_;
  ::naothmessages::DoubleVector3* acceleration_sensor_;
  ::naothmessages::DoubleVector3* rotation_;
  ::naothmessages::DoubleVector3* rotational_velocity_;
  ::naothmessages::DoubleVector3* rotational_velocity_sensor_;
  ::naothmessages::DoubleVector2* orientation_;
  ::naothmessages::DoubleVector3* orientation_rotvec_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CentreOfPressure : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.CentreOfPressure) */ {
 public:
  CentreOfPressure();
  virtual ~CentreOfPressure();

  CentreOfPressure(const CentreOfPressure& from);

  inline CentreOfPressure& operator=(const CentreOfPressure& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CentreOfPressure(CentreOfPressure&& from) noexcept
    : CentreOfPressure() {
    *this = ::std::move(from);
  }

  inline CentreOfPressure& operator=(CentreOfPressure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CentreOfPressure& default_instance();

  static inline const CentreOfPressure* internal_default_instance() {
    return reinterpret_cast<const CentreOfPressure*>(
               &_CentreOfPressure_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    42;

  void Swap(CentreOfPressure* other);
  friend void swap(CentreOfPressure& a, CentreOfPressure& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CentreOfPressure* New() const PROTOBUF_FINAL { return New(NULL); }

  CentreOfPressure* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CentreOfPressure& from);
  void MergeFrom(const CentreOfPressure& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CentreOfPressure* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .naothmessages.DoubleVector3 in_and_only_left_foot_cop = 1;
  bool has_in_and_only_left_foot_cop() const;
  void clear_in_and_only_left_foot_cop();
  static const int kInAndOnlyLeftFootCopFieldNumber = 1;
  const ::naothmessages::DoubleVector3& in_and_only_left_foot_cop() const;
  ::naothmessages::DoubleVector3* mutable_in_and_only_left_foot_cop();
  ::naothmessages::DoubleVector3* release_in_and_only_left_foot_cop();
  void set_allocated_in_and_only_left_foot_cop(::naothmessages::DoubleVector3* in_and_only_left_foot_cop);

  // required .naothmessages.DoubleVector3 in_and_only_right_foot_cop = 4;
  bool has_in_and_only_right_foot_cop() const;
  void clear_in_and_only_right_foot_cop();
  static const int kInAndOnlyRightFootCopFieldNumber = 4;
  const ::naothmessages::DoubleVector3& in_and_only_right_foot_cop() const;
  ::naothmessages::DoubleVector3* mutable_in_and_only_right_foot_cop();
  ::naothmessages::DoubleVector3* release_in_and_only_right_foot_cop();
  void set_allocated_in_and_only_right_foot_cop(::naothmessages::DoubleVector3* in_and_only_right_foot_cop);

  // required .naothmessages.DoubleVector3 in_kinematic_chain_origin_cop = 7;
  bool has_in_kinematic_chain_origin_cop() const;
  void clear_in_kinematic_chain_origin_cop();
  static const int kInKinematicChainOriginCopFieldNumber = 7;
  const ::naothmessages::DoubleVector3& in_kinematic_chain_origin_cop() const;
  ::naothmessages::DoubleVector3* mutable_in_kinematic_chain_origin_cop();
  ::naothmessages::DoubleVector3* release_in_kinematic_chain_origin_cop();
  void set_allocated_in_kinematic_chain_origin_cop(::naothmessages::DoubleVector3* in_kinematic_chain_origin_cop);

  // required double in_and_only_left_foot_magnitude = 2;
  bool has_in_and_only_left_foot_magnitude() const;
  void clear_in_and_only_left_foot_magnitude();
  static const int kInAndOnlyLeftFootMagnitudeFieldNumber = 2;
  double in_and_only_left_foot_magnitude() const;
  void set_in_and_only_left_foot_magnitude(double value);

  // required double in_and_only_right_foot_magnitude = 5;
  bool has_in_and_only_right_foot_magnitude() const;
  void clear_in_and_only_right_foot_magnitude();
  static const int kInAndOnlyRightFootMagnitudeFieldNumber = 5;
  double in_and_only_right_foot_magnitude() const;
  void set_in_and_only_right_foot_magnitude(double value);

  // required double in_kinematic_chain_origin_magnitude = 8;
  bool has_in_kinematic_chain_origin_magnitude() const;
  void clear_in_kinematic_chain_origin_magnitude();
  static const int kInKinematicChainOriginMagnitudeFieldNumber = 8;
  double in_kinematic_chain_origin_magnitude() const;
  void set_in_kinematic_chain_origin_magnitude(double value);

  // required bool in_and_only_left_foot_valid = 3;
  bool has_in_and_only_left_foot_valid() const;
  void clear_in_and_only_left_foot_valid();
  static const int kInAndOnlyLeftFootValidFieldNumber = 3;
  bool in_and_only_left_foot_valid() const;
  void set_in_and_only_left_foot_valid(bool value);

  // required bool in_and_only_right_foot_valid = 6;
  bool has_in_and_only_right_foot_valid() const;
  void clear_in_and_only_right_foot_valid();
  static const int kInAndOnlyRightFootValidFieldNumber = 6;
  bool in_and_only_right_foot_valid() const;
  void set_in_and_only_right_foot_valid(bool value);

  // required bool in_kinematic_chain_origin_valid = 9;
  bool has_in_kinematic_chain_origin_valid() const;
  void clear_in_kinematic_chain_origin_valid();
  static const int kInKinematicChainOriginValidFieldNumber = 9;
  bool in_kinematic_chain_origin_valid() const;
  void set_in_kinematic_chain_origin_valid(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.CentreOfPressure)
 private:
  void set_has_in_and_only_left_foot_cop();
  void clear_has_in_and_only_left_foot_cop();
  void set_has_in_and_only_left_foot_magnitude();
  void clear_has_in_and_only_left_foot_magnitude();
  void set_has_in_and_only_left_foot_valid();
  void clear_has_in_and_only_left_foot_valid();
  void set_has_in_and_only_right_foot_cop();
  void clear_has_in_and_only_right_foot_cop();
  void set_has_in_and_only_right_foot_magnitude();
  void clear_has_in_and_only_right_foot_magnitude();
  void set_has_in_and_only_right_foot_valid();
  void clear_has_in_and_only_right_foot_valid();
  void set_has_in_kinematic_chain_origin_cop();
  void clear_has_in_kinematic_chain_origin_cop();
  void set_has_in_kinematic_chain_origin_magnitude();
  void clear_has_in_kinematic_chain_origin_magnitude();
  void set_has_in_kinematic_chain_origin_valid();
  void clear_has_in_kinematic_chain_origin_valid();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector3* in_and_only_left_foot_cop_;
  ::naothmessages::DoubleVector3* in_and_only_right_foot_cop_;
  ::naothmessages::DoubleVector3* in_kinematic_chain_origin_cop_;
  double in_and_only_left_foot_magnitude_;
  double in_and_only_right_foot_magnitude_;
  double in_kinematic_chain_origin_magnitude_;
  bool in_and_only_left_foot_valid_;
  bool in_and_only_right_foot_valid_;
  bool in_kinematic_chain_origin_valid_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CalibrationDataCMC_CalibrationDataSampleV3 : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3) */ {
 public:
  CalibrationDataCMC_CalibrationDataSampleV3();
  virtual ~CalibrationDataCMC_CalibrationDataSampleV3();

  CalibrationDataCMC_CalibrationDataSampleV3(const CalibrationDataCMC_CalibrationDataSampleV3& from);

  inline CalibrationDataCMC_CalibrationDataSampleV3& operator=(const CalibrationDataCMC_CalibrationDataSampleV3& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CalibrationDataCMC_CalibrationDataSampleV3(CalibrationDataCMC_CalibrationDataSampleV3&& from) noexcept
    : CalibrationDataCMC_CalibrationDataSampleV3() {
    *this = ::std::move(from);
  }

  inline CalibrationDataCMC_CalibrationDataSampleV3& operator=(CalibrationDataCMC_CalibrationDataSampleV3&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationDataCMC_CalibrationDataSampleV3& default_instance();

  static inline const CalibrationDataCMC_CalibrationDataSampleV3* internal_default_instance() {
    return reinterpret_cast<const CalibrationDataCMC_CalibrationDataSampleV3*>(
               &_CalibrationDataCMC_CalibrationDataSampleV3_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    43;

  void Swap(CalibrationDataCMC_CalibrationDataSampleV3* other);
  friend void swap(CalibrationDataCMC_CalibrationDataSampleV3& a, CalibrationDataCMC_CalibrationDataSampleV3& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalibrationDataCMC_CalibrationDataSampleV3* New() const PROTOBUF_FINAL { return New(NULL); }

  CalibrationDataCMC_CalibrationDataSampleV3* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CalibrationDataCMC_CalibrationDataSampleV3& from);
  void MergeFrom(const CalibrationDataCMC_CalibrationDataSampleV3& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CalibrationDataCMC_CalibrationDataSampleV3* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .naothmessages.DoubleVector2 edgelsInImage = 2;
  int edgelsinimage_size() const;
  void clear_edgelsinimage();
  static const int kEdgelsInImageFieldNumber = 2;
  const ::naothmessages::DoubleVector2& edgelsinimage(int index) const;
  ::naothmessages::DoubleVector2* mutable_edgelsinimage(int index);
  ::naothmessages::DoubleVector2* add_edgelsinimage();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
      mutable_edgelsinimage();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
      edgelsinimage() const;

  // repeated .naothmessages.DoubleVector2 edgelsInImageTop = 3;
  int edgelsinimagetop_size() const;
  void clear_edgelsinimagetop();
  static const int kEdgelsInImageTopFieldNumber = 3;
  const ::naothmessages::DoubleVector2& edgelsinimagetop(int index) const;
  ::naothmessages::DoubleVector2* mutable_edgelsinimagetop(int index);
  ::naothmessages::DoubleVector2* add_edgelsinimagetop();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
      mutable_edgelsinimagetop();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
      edgelsinimagetop() const;

  // optional .naothmessages.Pose3D chestPose = 1;
  bool has_chestpose() const;
  void clear_chestpose();
  static const int kChestPoseFieldNumber = 1;
  const ::naothmessages::Pose3D& chestpose() const;
  ::naothmessages::Pose3D* mutable_chestpose();
  ::naothmessages::Pose3D* release_chestpose();
  void set_allocated_chestpose(::naothmessages::Pose3D* chestpose);

  // optional .naothmessages.DoubleVector2 orientation = 4;
  bool has_orientation() const;
  void clear_orientation();
  static const int kOrientationFieldNumber = 4;
  const ::naothmessages::DoubleVector2& orientation() const;
  ::naothmessages::DoubleVector2* mutable_orientation();
  ::naothmessages::DoubleVector2* release_orientation();
  void set_allocated_orientation(::naothmessages::DoubleVector2* orientation);

  // optional double headYaw = 5;
  bool has_headyaw() const;
  void clear_headyaw();
  static const int kHeadYawFieldNumber = 5;
  double headyaw() const;
  void set_headyaw(double value);

  // optional double headPitch = 6;
  bool has_headpitch() const;
  void clear_headpitch();
  static const int kHeadPitchFieldNumber = 6;
  double headpitch() const;
  void set_headpitch(double value);

  // @@protoc_insertion_point(class_scope:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3)
 private:
  void set_has_chestpose();
  void clear_has_chestpose();
  void set_has_orientation();
  void clear_has_orientation();
  void set_has_headyaw();
  void clear_has_headyaw();
  void set_has_headpitch();
  void clear_has_headpitch();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 > edgelsinimage_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 > edgelsinimagetop_;
  ::naothmessages::Pose3D* chestpose_;
  ::naothmessages::DoubleVector2* orientation_;
  double headyaw_;
  double headpitch_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CalibrationDataCMC : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.CalibrationDataCMC) */ {
 public:
  CalibrationDataCMC();
  virtual ~CalibrationDataCMC();

  CalibrationDataCMC(const CalibrationDataCMC& from);

  inline CalibrationDataCMC& operator=(const CalibrationDataCMC& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CalibrationDataCMC(CalibrationDataCMC&& from) noexcept
    : CalibrationDataCMC() {
    *this = ::std::move(from);
  }

  inline CalibrationDataCMC& operator=(CalibrationDataCMC&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CalibrationDataCMC& default_instance();

  static inline const CalibrationDataCMC* internal_default_instance() {
    return reinterpret_cast<const CalibrationDataCMC*>(
               &_CalibrationDataCMC_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    44;

  void Swap(CalibrationDataCMC* other);
  friend void swap(CalibrationDataCMC& a, CalibrationDataCMC& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CalibrationDataCMC* New() const PROTOBUF_FINAL { return New(NULL); }

  CalibrationDataCMC* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const CalibrationDataCMC& from);
  void MergeFrom(const CalibrationDataCMC& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(CalibrationDataCMC* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef CalibrationDataCMC_CalibrationDataSampleV3 CalibrationDataSampleV3;

  // accessors -------------------------------------------------------

  // repeated .naothmessages.CalibrationDataCMC.CalibrationDataSampleV3 calibrationData = 1;
  int calibrationdata_size() const;
  void clear_calibrationdata();
  static const int kCalibrationDataFieldNumber = 1;
  const ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3& calibrationdata(int index) const;
  ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3* mutable_calibrationdata(int index);
  ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3* add_calibrationdata();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3 >*
      mutable_calibrationdata();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3 >&
      calibrationdata() const;

  // optional uint32 numberOfResudials = 2;
  bool has_numberofresudials() const;
  void clear_numberofresudials();
  static const int kNumberOfResudialsFieldNumber = 2;
  ::google::protobuf::uint32 numberofresudials() const;
  void set_numberofresudials(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:naothmessages.CalibrationDataCMC)
 private:
  void set_has_numberofresudials();
  void clear_has_numberofresudials();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3 > calibrationdata_;
  ::google::protobuf::uint32 numberofresudials_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WhistlePercept_Whistle : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.WhistlePercept.Whistle) */ {
 public:
  WhistlePercept_Whistle();
  virtual ~WhistlePercept_Whistle();

  WhistlePercept_Whistle(const WhistlePercept_Whistle& from);

  inline WhistlePercept_Whistle& operator=(const WhistlePercept_Whistle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WhistlePercept_Whistle(WhistlePercept_Whistle&& from) noexcept
    : WhistlePercept_Whistle() {
    *this = ::std::move(from);
  }

  inline WhistlePercept_Whistle& operator=(WhistlePercept_Whistle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WhistlePercept_Whistle& default_instance();

  static inline const WhistlePercept_Whistle* internal_default_instance() {
    return reinterpret_cast<const WhistlePercept_Whistle*>(
               &_WhistlePercept_Whistle_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    45;

  void Swap(WhistlePercept_Whistle* other);
  friend void swap(WhistlePercept_Whistle& a, WhistlePercept_Whistle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WhistlePercept_Whistle* New() const PROTOBUF_FINAL { return New(NULL); }

  WhistlePercept_Whistle* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WhistlePercept_Whistle& from);
  void MergeFrom(const WhistlePercept_Whistle& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WhistlePercept_Whistle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required int64 positionInCapture = 2;
  bool has_positionincapture() const;
  void clear_positionincapture();
  static const int kPositionInCaptureFieldNumber = 2;
  ::google::protobuf::int64 positionincapture() const;
  void set_positionincapture(::google::protobuf::int64 value);

  // required double responseValue = 3;
  bool has_responsevalue() const;
  void clear_responsevalue();
  static const int kResponseValueFieldNumber = 3;
  double responsevalue() const;
  void set_responsevalue(double value);

  // @@protoc_insertion_point(class_scope:naothmessages.WhistlePercept.Whistle)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_positionincapture();
  void clear_has_positionincapture();
  void set_has_responsevalue();
  void clear_has_responsevalue();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 positionincapture_;
  double responsevalue_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WhistlePercept : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.WhistlePercept) */ {
 public:
  WhistlePercept();
  virtual ~WhistlePercept();

  WhistlePercept(const WhistlePercept& from);

  inline WhistlePercept& operator=(const WhistlePercept& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WhistlePercept(WhistlePercept&& from) noexcept
    : WhistlePercept() {
    *this = ::std::move(from);
  }

  inline WhistlePercept& operator=(WhistlePercept&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WhistlePercept& default_instance();

  static inline const WhistlePercept* internal_default_instance() {
    return reinterpret_cast<const WhistlePercept*>(
               &_WhistlePercept_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    46;

  void Swap(WhistlePercept* other);
  friend void swap(WhistlePercept& a, WhistlePercept& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WhistlePercept* New() const PROTOBUF_FINAL { return New(NULL); }

  WhistlePercept* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const WhistlePercept& from);
  void MergeFrom(const WhistlePercept& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(WhistlePercept* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef WhistlePercept_Whistle Whistle;

  // accessors -------------------------------------------------------

  // repeated .naothmessages.WhistlePercept.Whistle recognizedWhistles = 3;
  int recognizedwhistles_size() const;
  void clear_recognizedwhistles();
  static const int kRecognizedWhistlesFieldNumber = 3;
  const ::naothmessages::WhistlePercept_Whistle& recognizedwhistles(int index) const;
  ::naothmessages::WhistlePercept_Whistle* mutable_recognizedwhistles(int index);
  ::naothmessages::WhistlePercept_Whistle* add_recognizedwhistles();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::WhistlePercept_Whistle >*
      mutable_recognizedwhistles();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::WhistlePercept_Whistle >&
      recognizedwhistles() const;

  // optional string captureFile = 2;
  bool has_capturefile() const;
  void clear_capturefile();
  static const int kCaptureFileFieldNumber = 2;
  const ::std::string& capturefile() const;
  void set_capturefile(const ::std::string& value);
  #if LANG_CXX11
  void set_capturefile(::std::string&& value);
  #endif
  void set_capturefile(const char* value);
  void set_capturefile(const char* value, size_t size);
  ::std::string* mutable_capturefile();
  ::std::string* release_capturefile();
  void set_allocated_capturefile(::std::string* capturefile);

  // optional uint32 frameWhenWhistleDetected = 1;
  bool has_framewhenwhistledetected() const;
  void clear_framewhenwhistledetected();
  static const int kFrameWhenWhistleDetectedFieldNumber = 1;
  ::google::protobuf::uint32 framewhenwhistledetected() const;
  void set_framewhenwhistledetected(::google::protobuf::uint32 value);

  // optional bool whistleDetected = 4;
  bool has_whistledetected() const;
  void clear_whistledetected();
  static const int kWhistleDetectedFieldNumber = 4;
  bool whistledetected() const;
  void set_whistledetected(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.WhistlePercept)
 private:
  void set_has_framewhenwhistledetected();
  void clear_has_framewhenwhistledetected();
  void set_has_capturefile();
  void clear_has_capturefile();
  void set_has_whistledetected();
  void clear_has_whistledetected();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::WhistlePercept_Whistle > recognizedwhistles_;
  ::google::protobuf::internal::ArenaStringPtr capturefile_;
  ::google::protobuf::uint32 framewhenwhistledetected_;
  bool whistledetected_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugModify_ModifyValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.DebugModify.ModifyValue) */ {
 public:
  DebugModify_ModifyValue();
  virtual ~DebugModify_ModifyValue();

  DebugModify_ModifyValue(const DebugModify_ModifyValue& from);

  inline DebugModify_ModifyValue& operator=(const DebugModify_ModifyValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugModify_ModifyValue(DebugModify_ModifyValue&& from) noexcept
    : DebugModify_ModifyValue() {
    *this = ::std::move(from);
  }

  inline DebugModify_ModifyValue& operator=(DebugModify_ModifyValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugModify_ModifyValue& default_instance();

  static inline const DebugModify_ModifyValue* internal_default_instance() {
    return reinterpret_cast<const DebugModify_ModifyValue*>(
               &_DebugModify_ModifyValue_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    47;

  void Swap(DebugModify_ModifyValue* other);
  friend void swap(DebugModify_ModifyValue& a, DebugModify_ModifyValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugModify_ModifyValue* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugModify_ModifyValue* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugModify_ModifyValue& from);
  void MergeFrom(const DebugModify_ModifyValue& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugModify_ModifyValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional double value = 3;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 3;
  double value() const;
  void set_value(double value);

  // optional bool modify = 2;
  bool has_modify() const;
  void clear_modify();
  static const int kModifyFieldNumber = 2;
  bool modify() const;
  void set_modify(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.DebugModify.ModifyValue)
 private:
  void set_has_name();
  void clear_has_name();
  void set_has_modify();
  void clear_has_modify();
  void set_has_value();
  void clear_has_value();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  double value_;
  bool modify_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DebugModify : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.DebugModify) */ {
 public:
  DebugModify();
  virtual ~DebugModify();

  DebugModify(const DebugModify& from);

  inline DebugModify& operator=(const DebugModify& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DebugModify(DebugModify&& from) noexcept
    : DebugModify() {
    *this = ::std::move(from);
  }

  inline DebugModify& operator=(DebugModify&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DebugModify& default_instance();

  static inline const DebugModify* internal_default_instance() {
    return reinterpret_cast<const DebugModify*>(
               &_DebugModify_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    48;

  void Swap(DebugModify* other);
  friend void swap(DebugModify& a, DebugModify& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DebugModify* New() const PROTOBUF_FINAL { return New(NULL); }

  DebugModify* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DebugModify& from);
  void MergeFrom(const DebugModify& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DebugModify* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef DebugModify_ModifyValue ModifyValue;

  // accessors -------------------------------------------------------

  // repeated .naothmessages.DebugModify.ModifyValue valueMap = 1;
  int valuemap_size() const;
  void clear_valuemap();
  static const int kValueMapFieldNumber = 1;
  const ::naothmessages::DebugModify_ModifyValue& valuemap(int index) const;
  ::naothmessages::DebugModify_ModifyValue* mutable_valuemap(int index);
  ::naothmessages::DebugModify_ModifyValue* add_valuemap();
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DebugModify_ModifyValue >*
      mutable_valuemap();
  const ::google::protobuf::RepeatedPtrField< ::naothmessages::DebugModify_ModifyValue >&
      valuemap() const;

  // @@protoc_insertion_point(class_scope:naothmessages.DebugModify)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::naothmessages::DebugModify_ModifyValue > valuemap_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StepBuffer : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.StepBuffer) */ {
 public:
  StepBuffer();
  virtual ~StepBuffer();

  StepBuffer(const StepBuffer& from);

  inline StepBuffer& operator=(const StepBuffer& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StepBuffer(StepBuffer&& from) noexcept
    : StepBuffer() {
    *this = ::std::move(from);
  }

  inline StepBuffer& operator=(StepBuffer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StepBuffer& default_instance();

  static inline const StepBuffer* internal_default_instance() {
    return reinterpret_cast<const StepBuffer*>(
               &_StepBuffer_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    49;

  void Swap(StepBuffer* other);
  friend void swap(StepBuffer& a, StepBuffer& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StepBuffer* New() const PROTOBUF_FINAL { return New(NULL); }

  StepBuffer* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StepBuffer& from);
  void MergeFrom(const StepBuffer& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StepBuffer* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.Pose3D support_foot = 1;
  bool has_support_foot() const;
  void clear_support_foot();
  static const int kSupportFootFieldNumber = 1;
  const ::naothmessages::Pose3D& support_foot() const;
  ::naothmessages::Pose3D* mutable_support_foot();
  ::naothmessages::Pose3D* release_support_foot();
  void set_allocated_support_foot(::naothmessages::Pose3D* support_foot);

  // @@protoc_insertion_point(class_scope:naothmessages.StepBuffer)
 private:
  void set_has_support_foot();
  void clear_has_support_foot();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::Pose3D* support_foot_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class bodyAwareness : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:naothmessages.bodyAwareness) */ {
 public:
  bodyAwareness();
  virtual ~bodyAwareness();

  bodyAwareness(const bodyAwareness& from);

  inline bodyAwareness& operator=(const bodyAwareness& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  bodyAwareness(bodyAwareness&& from) noexcept
    : bodyAwareness() {
    *this = ::std::move(from);
  }

  inline bodyAwareness& operator=(bodyAwareness&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const bodyAwareness& default_instance();

  static inline const bodyAwareness* internal_default_instance() {
    return reinterpret_cast<const bodyAwareness*>(
               &_bodyAwareness_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    50;

  void Swap(bodyAwareness* other);
  friend void swap(bodyAwareness& a, bodyAwareness& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline bodyAwareness* New() const PROTOBUF_FINAL { return New(NULL); }

  bodyAwareness* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const bodyAwareness& from);
  void MergeFrom(const bodyAwareness& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(bodyAwareness* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .naothmessages.DoubleVector3 calculatedCoM = 2;
  bool has_calculatedcom() const;
  void clear_calculatedcom();
  static const int kCalculatedCoMFieldNumber = 2;
  const ::naothmessages::DoubleVector3& calculatedcom() const;
  ::naothmessages::DoubleVector3* mutable_calculatedcom();
  ::naothmessages::DoubleVector3* release_calculatedcom();
  void set_allocated_calculatedcom(::naothmessages::DoubleVector3* calculatedcom);

  // optional .naothmessages.DoubleVector3 currentCoMError = 3;
  bool has_currentcomerror() const;
  void clear_currentcomerror();
  static const int kCurrentCoMErrorFieldNumber = 3;
  const ::naothmessages::DoubleVector3& currentcomerror() const;
  ::naothmessages::DoubleVector3* mutable_currentcomerror();
  ::naothmessages::DoubleVector3* release_currentcomerror();
  void set_allocated_currentcomerror(::naothmessages::DoubleVector3* currentcomerror);

  // optional bool isLifted = 1;
  bool has_islifted() const;
  void clear_islifted();
  static const int kIsLiftedFieldNumber = 1;
  bool islifted() const;
  void set_islifted(bool value);

  // @@protoc_insertion_point(class_scope:naothmessages.bodyAwareness)
 private:
  void set_has_islifted();
  void clear_has_islifted();
  void set_has_calculatedcom();
  void clear_has_calculatedcom();
  void set_has_currentcomerror();
  void clear_has_currentcomerror();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::naothmessages::DoubleVector3* calculatedcom_;
  ::naothmessages::DoubleVector3* currentcomerror_;
  bool islifted_;
  friend struct protobuf_Representations_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CameraMatrix

// required .naothmessages.Pose3D pose = 1;
inline bool CameraMatrix::has_pose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraMatrix::set_has_pose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraMatrix::clear_has_pose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraMatrix::clear_pose() {
  if (pose_ != NULL) pose_->::naothmessages::Pose3D::Clear();
  clear_has_pose();
}
inline const ::naothmessages::Pose3D& CameraMatrix::pose() const {
  const ::naothmessages::Pose3D* p = pose_;
  // @@protoc_insertion_point(field_get:naothmessages.CameraMatrix.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose3D*>(
      &::naothmessages::_Pose3D_default_instance_);
}
inline ::naothmessages::Pose3D* CameraMatrix::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::naothmessages::Pose3D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CameraMatrix.pose)
  return pose_;
}
inline ::naothmessages::Pose3D* CameraMatrix::release_pose() {
  // @@protoc_insertion_point(field_release:naothmessages.CameraMatrix.pose)
  clear_has_pose();
  ::naothmessages::Pose3D* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void CameraMatrix::set_allocated_pose(::naothmessages::Pose3D* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CameraMatrix.pose)
}

// optional .naothmessages.CameraID cameraID = 2 [default = bottom];
inline bool CameraMatrix::has_cameraid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CameraMatrix::set_has_cameraid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CameraMatrix::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CameraMatrix::clear_cameraid() {
  cameraid_ = 1;
  clear_has_cameraid();
}
inline ::naothmessages::CameraID CameraMatrix::cameraid() const {
  // @@protoc_insertion_point(field_get:naothmessages.CameraMatrix.cameraID)
  return static_cast< ::naothmessages::CameraID >(cameraid_);
}
inline void CameraMatrix::set_cameraid(::naothmessages::CameraID value) {
  assert(::naothmessages::CameraID_IsValid(value));
  set_has_cameraid();
  cameraid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CameraMatrix.cameraID)
}

// optional bool valid = 3;
inline bool CameraMatrix::has_valid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraMatrix::set_has_valid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraMatrix::clear_has_valid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraMatrix::clear_valid() {
  valid_ = false;
  clear_has_valid();
}
inline bool CameraMatrix::valid() const {
  // @@protoc_insertion_point(field_get:naothmessages.CameraMatrix.valid)
  return valid_;
}
inline void CameraMatrix::set_valid(bool value) {
  set_has_valid();
  valid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CameraMatrix.valid)
}

// optional uint32 timestamp = 4;
inline bool CameraMatrix::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CameraMatrix::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CameraMatrix::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CameraMatrix::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 CameraMatrix::timestamp() const {
  // @@protoc_insertion_point(field_get:naothmessages.CameraMatrix.timestamp)
  return timestamp_;
}
inline void CameraMatrix::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CameraMatrix.timestamp)
}

// -------------------------------------------------------------------

// BallPercept

// optional bool ballWasSeen = 1;
inline bool BallPercept::has_ballwasseen() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BallPercept::set_has_ballwasseen() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BallPercept::clear_has_ballwasseen() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BallPercept::clear_ballwasseen() {
  ballwasseen_ = false;
  clear_has_ballwasseen();
}
inline bool BallPercept::ballwasseen() const {
  // @@protoc_insertion_point(field_get:naothmessages.BallPercept.ballWasSeen)
  return ballwasseen_;
}
inline void BallPercept::set_ballwasseen(bool value) {
  set_has_ballwasseen();
  ballwasseen_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.BallPercept.ballWasSeen)
}

// optional .naothmessages.DoubleVector2 centerInImage = 2;
inline bool BallPercept::has_centerinimage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BallPercept::set_has_centerinimage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BallPercept::clear_has_centerinimage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BallPercept::clear_centerinimage() {
  if (centerinimage_ != NULL) centerinimage_->::naothmessages::DoubleVector2::Clear();
  clear_has_centerinimage();
}
inline const ::naothmessages::DoubleVector2& BallPercept::centerinimage() const {
  const ::naothmessages::DoubleVector2* p = centerinimage_;
  // @@protoc_insertion_point(field_get:naothmessages.BallPercept.centerInImage)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* BallPercept::mutable_centerinimage() {
  set_has_centerinimage();
  if (centerinimage_ == NULL) {
    centerinimage_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.BallPercept.centerInImage)
  return centerinimage_;
}
inline ::naothmessages::DoubleVector2* BallPercept::release_centerinimage() {
  // @@protoc_insertion_point(field_release:naothmessages.BallPercept.centerInImage)
  clear_has_centerinimage();
  ::naothmessages::DoubleVector2* temp = centerinimage_;
  centerinimage_ = NULL;
  return temp;
}
inline void BallPercept::set_allocated_centerinimage(::naothmessages::DoubleVector2* centerinimage) {
  delete centerinimage_;
  centerinimage_ = centerinimage;
  if (centerinimage) {
    set_has_centerinimage();
  } else {
    clear_has_centerinimage();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallPercept.centerInImage)
}

// optional double radiusInImage = 3;
inline bool BallPercept::has_radiusinimage() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BallPercept::set_has_radiusinimage() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BallPercept::clear_has_radiusinimage() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BallPercept::clear_radiusinimage() {
  radiusinimage_ = 0;
  clear_has_radiusinimage();
}
inline double BallPercept::radiusinimage() const {
  // @@protoc_insertion_point(field_get:naothmessages.BallPercept.radiusInImage)
  return radiusinimage_;
}
inline void BallPercept::set_radiusinimage(double value) {
  set_has_radiusinimage();
  radiusinimage_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.BallPercept.radiusInImage)
}

// optional .naothmessages.Color ballColor = 4;
inline bool BallPercept::has_ballcolor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BallPercept::set_has_ballcolor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BallPercept::clear_has_ballcolor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BallPercept::clear_ballcolor() {
  ballcolor_ = 0;
  clear_has_ballcolor();
}
inline ::naothmessages::Color BallPercept::ballcolor() const {
  // @@protoc_insertion_point(field_get:naothmessages.BallPercept.ballColor)
  return static_cast< ::naothmessages::Color >(ballcolor_);
}
inline void BallPercept::set_ballcolor(::naothmessages::Color value) {
  assert(::naothmessages::Color_IsValid(value));
  set_has_ballcolor();
  ballcolor_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.BallPercept.ballColor)
}

// optional .naothmessages.DoubleVector2 bearingBasedOffsetOnField = 5;
inline bool BallPercept::has_bearingbasedoffsetonfield() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BallPercept::set_has_bearingbasedoffsetonfield() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BallPercept::clear_has_bearingbasedoffsetonfield() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BallPercept::clear_bearingbasedoffsetonfield() {
  if (bearingbasedoffsetonfield_ != NULL) bearingbasedoffsetonfield_->::naothmessages::DoubleVector2::Clear();
  clear_has_bearingbasedoffsetonfield();
}
inline const ::naothmessages::DoubleVector2& BallPercept::bearingbasedoffsetonfield() const {
  const ::naothmessages::DoubleVector2* p = bearingbasedoffsetonfield_;
  // @@protoc_insertion_point(field_get:naothmessages.BallPercept.bearingBasedOffsetOnField)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* BallPercept::mutable_bearingbasedoffsetonfield() {
  set_has_bearingbasedoffsetonfield();
  if (bearingbasedoffsetonfield_ == NULL) {
    bearingbasedoffsetonfield_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.BallPercept.bearingBasedOffsetOnField)
  return bearingbasedoffsetonfield_;
}
inline ::naothmessages::DoubleVector2* BallPercept::release_bearingbasedoffsetonfield() {
  // @@protoc_insertion_point(field_release:naothmessages.BallPercept.bearingBasedOffsetOnField)
  clear_has_bearingbasedoffsetonfield();
  ::naothmessages::DoubleVector2* temp = bearingbasedoffsetonfield_;
  bearingbasedoffsetonfield_ = NULL;
  return temp;
}
inline void BallPercept::set_allocated_bearingbasedoffsetonfield(::naothmessages::DoubleVector2* bearingbasedoffsetonfield) {
  delete bearingbasedoffsetonfield_;
  bearingbasedoffsetonfield_ = bearingbasedoffsetonfield;
  if (bearingbasedoffsetonfield) {
    set_has_bearingbasedoffsetonfield();
  } else {
    clear_has_bearingbasedoffsetonfield();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallPercept.bearingBasedOffsetOnField)
}

// optional .naothmessages.FrameInfo frameInfoWhenBallWasSeen = 6;
inline bool BallPercept::has_frameinfowhenballwasseen() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BallPercept::set_has_frameinfowhenballwasseen() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BallPercept::clear_has_frameinfowhenballwasseen() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BallPercept::clear_frameinfowhenballwasseen() {
  if (frameinfowhenballwasseen_ != NULL) frameinfowhenballwasseen_->::naothmessages::FrameInfo::Clear();
  clear_has_frameinfowhenballwasseen();
}
inline const ::naothmessages::FrameInfo& BallPercept::frameinfowhenballwasseen() const {
  const ::naothmessages::FrameInfo* p = frameinfowhenballwasseen_;
  // @@protoc_insertion_point(field_get:naothmessages.BallPercept.frameInfoWhenBallWasSeen)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::FrameInfo*>(
      &::naothmessages::_FrameInfo_default_instance_);
}
inline ::naothmessages::FrameInfo* BallPercept::mutable_frameinfowhenballwasseen() {
  set_has_frameinfowhenballwasseen();
  if (frameinfowhenballwasseen_ == NULL) {
    frameinfowhenballwasseen_ = new ::naothmessages::FrameInfo;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.BallPercept.frameInfoWhenBallWasSeen)
  return frameinfowhenballwasseen_;
}
inline ::naothmessages::FrameInfo* BallPercept::release_frameinfowhenballwasseen() {
  // @@protoc_insertion_point(field_release:naothmessages.BallPercept.frameInfoWhenBallWasSeen)
  clear_has_frameinfowhenballwasseen();
  ::naothmessages::FrameInfo* temp = frameinfowhenballwasseen_;
  frameinfowhenballwasseen_ = NULL;
  return temp;
}
inline void BallPercept::set_allocated_frameinfowhenballwasseen(::naothmessages::FrameInfo* frameinfowhenballwasseen) {
  delete frameinfowhenballwasseen_;
  frameinfowhenballwasseen_ = frameinfowhenballwasseen;
  if (frameinfowhenballwasseen) {
    set_has_frameinfowhenballwasseen();
  } else {
    clear_has_frameinfowhenballwasseen();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallPercept.frameInfoWhenBallWasSeen)
}

// -------------------------------------------------------------------

// MultiBallPercept_BallPercept

// optional .naothmessages.DoubleVector2 centerInImage = 1;
inline bool MultiBallPercept_BallPercept::has_centerinimage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiBallPercept_BallPercept::set_has_centerinimage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiBallPercept_BallPercept::clear_has_centerinimage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiBallPercept_BallPercept::clear_centerinimage() {
  if (centerinimage_ != NULL) centerinimage_->::naothmessages::DoubleVector2::Clear();
  clear_has_centerinimage();
}
inline const ::naothmessages::DoubleVector2& MultiBallPercept_BallPercept::centerinimage() const {
  const ::naothmessages::DoubleVector2* p = centerinimage_;
  // @@protoc_insertion_point(field_get:naothmessages.MultiBallPercept.BallPercept.centerInImage)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* MultiBallPercept_BallPercept::mutable_centerinimage() {
  set_has_centerinimage();
  if (centerinimage_ == NULL) {
    centerinimage_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MultiBallPercept.BallPercept.centerInImage)
  return centerinimage_;
}
inline ::naothmessages::DoubleVector2* MultiBallPercept_BallPercept::release_centerinimage() {
  // @@protoc_insertion_point(field_release:naothmessages.MultiBallPercept.BallPercept.centerInImage)
  clear_has_centerinimage();
  ::naothmessages::DoubleVector2* temp = centerinimage_;
  centerinimage_ = NULL;
  return temp;
}
inline void MultiBallPercept_BallPercept::set_allocated_centerinimage(::naothmessages::DoubleVector2* centerinimage) {
  delete centerinimage_;
  centerinimage_ = centerinimage;
  if (centerinimage) {
    set_has_centerinimage();
  } else {
    clear_has_centerinimage();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MultiBallPercept.BallPercept.centerInImage)
}

// optional double radiusInImage = 2;
inline bool MultiBallPercept_BallPercept::has_radiusinimage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MultiBallPercept_BallPercept::set_has_radiusinimage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MultiBallPercept_BallPercept::clear_has_radiusinimage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MultiBallPercept_BallPercept::clear_radiusinimage() {
  radiusinimage_ = 0;
  clear_has_radiusinimage();
}
inline double MultiBallPercept_BallPercept::radiusinimage() const {
  // @@protoc_insertion_point(field_get:naothmessages.MultiBallPercept.BallPercept.radiusInImage)
  return radiusinimage_;
}
inline void MultiBallPercept_BallPercept::set_radiusinimage(double value) {
  set_has_radiusinimage();
  radiusinimage_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MultiBallPercept.BallPercept.radiusInImage)
}

// optional .naothmessages.DoubleVector2 positionOnField = 3;
inline bool MultiBallPercept_BallPercept::has_positiononfield() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MultiBallPercept_BallPercept::set_has_positiononfield() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MultiBallPercept_BallPercept::clear_has_positiononfield() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MultiBallPercept_BallPercept::clear_positiononfield() {
  if (positiononfield_ != NULL) positiononfield_->::naothmessages::DoubleVector2::Clear();
  clear_has_positiononfield();
}
inline const ::naothmessages::DoubleVector2& MultiBallPercept_BallPercept::positiononfield() const {
  const ::naothmessages::DoubleVector2* p = positiononfield_;
  // @@protoc_insertion_point(field_get:naothmessages.MultiBallPercept.BallPercept.positionOnField)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* MultiBallPercept_BallPercept::mutable_positiononfield() {
  set_has_positiononfield();
  if (positiononfield_ == NULL) {
    positiononfield_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MultiBallPercept.BallPercept.positionOnField)
  return positiononfield_;
}
inline ::naothmessages::DoubleVector2* MultiBallPercept_BallPercept::release_positiononfield() {
  // @@protoc_insertion_point(field_release:naothmessages.MultiBallPercept.BallPercept.positionOnField)
  clear_has_positiononfield();
  ::naothmessages::DoubleVector2* temp = positiononfield_;
  positiononfield_ = NULL;
  return temp;
}
inline void MultiBallPercept_BallPercept::set_allocated_positiononfield(::naothmessages::DoubleVector2* positiononfield) {
  delete positiononfield_;
  positiononfield_ = positiononfield;
  if (positiononfield) {
    set_has_positiononfield();
  } else {
    clear_has_positiononfield();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MultiBallPercept.BallPercept.positionOnField)
}

// optional .naothmessages.CameraID cameraId = 4;
inline bool MultiBallPercept_BallPercept::has_cameraid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MultiBallPercept_BallPercept::set_has_cameraid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MultiBallPercept_BallPercept::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MultiBallPercept_BallPercept::clear_cameraid() {
  cameraid_ = 0;
  clear_has_cameraid();
}
inline ::naothmessages::CameraID MultiBallPercept_BallPercept::cameraid() const {
  // @@protoc_insertion_point(field_get:naothmessages.MultiBallPercept.BallPercept.cameraId)
  return static_cast< ::naothmessages::CameraID >(cameraid_);
}
inline void MultiBallPercept_BallPercept::set_cameraid(::naothmessages::CameraID value) {
  assert(::naothmessages::CameraID_IsValid(value));
  set_has_cameraid();
  cameraid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MultiBallPercept.BallPercept.cameraId)
}

// -------------------------------------------------------------------

// MultiBallPercept

// optional .naothmessages.FrameInfo frameInfoWhenBallWasSeen = 1;
inline bool MultiBallPercept::has_frameinfowhenballwasseen() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MultiBallPercept::set_has_frameinfowhenballwasseen() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MultiBallPercept::clear_has_frameinfowhenballwasseen() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MultiBallPercept::clear_frameinfowhenballwasseen() {
  if (frameinfowhenballwasseen_ != NULL) frameinfowhenballwasseen_->::naothmessages::FrameInfo::Clear();
  clear_has_frameinfowhenballwasseen();
}
inline const ::naothmessages::FrameInfo& MultiBallPercept::frameinfowhenballwasseen() const {
  const ::naothmessages::FrameInfo* p = frameinfowhenballwasseen_;
  // @@protoc_insertion_point(field_get:naothmessages.MultiBallPercept.frameInfoWhenBallWasSeen)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::FrameInfo*>(
      &::naothmessages::_FrameInfo_default_instance_);
}
inline ::naothmessages::FrameInfo* MultiBallPercept::mutable_frameinfowhenballwasseen() {
  set_has_frameinfowhenballwasseen();
  if (frameinfowhenballwasseen_ == NULL) {
    frameinfowhenballwasseen_ = new ::naothmessages::FrameInfo;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MultiBallPercept.frameInfoWhenBallWasSeen)
  return frameinfowhenballwasseen_;
}
inline ::naothmessages::FrameInfo* MultiBallPercept::release_frameinfowhenballwasseen() {
  // @@protoc_insertion_point(field_release:naothmessages.MultiBallPercept.frameInfoWhenBallWasSeen)
  clear_has_frameinfowhenballwasseen();
  ::naothmessages::FrameInfo* temp = frameinfowhenballwasseen_;
  frameinfowhenballwasseen_ = NULL;
  return temp;
}
inline void MultiBallPercept::set_allocated_frameinfowhenballwasseen(::naothmessages::FrameInfo* frameinfowhenballwasseen) {
  delete frameinfowhenballwasseen_;
  frameinfowhenballwasseen_ = frameinfowhenballwasseen;
  if (frameinfowhenballwasseen) {
    set_has_frameinfowhenballwasseen();
  } else {
    clear_has_frameinfowhenballwasseen();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MultiBallPercept.frameInfoWhenBallWasSeen)
}

// repeated .naothmessages.MultiBallPercept.BallPercept percepts = 2;
inline int MultiBallPercept::percepts_size() const {
  return percepts_.size();
}
inline void MultiBallPercept::clear_percepts() {
  percepts_.Clear();
}
inline const ::naothmessages::MultiBallPercept_BallPercept& MultiBallPercept::percepts(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.MultiBallPercept.percepts)
  return percepts_.Get(index);
}
inline ::naothmessages::MultiBallPercept_BallPercept* MultiBallPercept::mutable_percepts(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.MultiBallPercept.percepts)
  return percepts_.Mutable(index);
}
inline ::naothmessages::MultiBallPercept_BallPercept* MultiBallPercept::add_percepts() {
  // @@protoc_insertion_point(field_add:naothmessages.MultiBallPercept.percepts)
  return percepts_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::MultiBallPercept_BallPercept >*
MultiBallPercept::mutable_percepts() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.MultiBallPercept.percepts)
  return &percepts_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::MultiBallPercept_BallPercept >&
MultiBallPercept::percepts() const {
  // @@protoc_insertion_point(field_list:naothmessages.MultiBallPercept.percepts)
  return percepts_;
}

// -------------------------------------------------------------------

// BallModel

// optional bool valid = 1;
inline bool BallModel::has_valid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BallModel::set_has_valid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BallModel::clear_has_valid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BallModel::clear_valid() {
  valid_ = false;
  clear_has_valid();
}
inline bool BallModel::valid() const {
  // @@protoc_insertion_point(field_get:naothmessages.BallModel.valid)
  return valid_;
}
inline void BallModel::set_valid(bool value) {
  set_has_valid();
  valid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.BallModel.valid)
}

// optional bool knows = 2;
inline bool BallModel::has_knows() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BallModel::set_has_knows() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BallModel::clear_has_knows() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BallModel::clear_knows() {
  knows_ = false;
  clear_has_knows();
}
inline bool BallModel::knows() const {
  // @@protoc_insertion_point(field_get:naothmessages.BallModel.knows)
  return knows_;
}
inline void BallModel::set_knows(bool value) {
  set_has_knows();
  knows_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.BallModel.knows)
}

// optional .naothmessages.DoubleVector2 position = 3;
inline bool BallModel::has_position() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BallModel::set_has_position() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BallModel::clear_has_position() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BallModel::clear_position() {
  if (position_ != NULL) position_->::naothmessages::DoubleVector2::Clear();
  clear_has_position();
}
inline const ::naothmessages::DoubleVector2& BallModel::position() const {
  const ::naothmessages::DoubleVector2* p = position_;
  // @@protoc_insertion_point(field_get:naothmessages.BallModel.position)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* BallModel::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.BallModel.position)
  return position_;
}
inline ::naothmessages::DoubleVector2* BallModel::release_position() {
  // @@protoc_insertion_point(field_release:naothmessages.BallModel.position)
  clear_has_position();
  ::naothmessages::DoubleVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void BallModel::set_allocated_position(::naothmessages::DoubleVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallModel.position)
}

// optional .naothmessages.DoubleVector2 speed = 4;
inline bool BallModel::has_speed() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BallModel::set_has_speed() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BallModel::clear_has_speed() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BallModel::clear_speed() {
  if (speed_ != NULL) speed_->::naothmessages::DoubleVector2::Clear();
  clear_has_speed();
}
inline const ::naothmessages::DoubleVector2& BallModel::speed() const {
  const ::naothmessages::DoubleVector2* p = speed_;
  // @@protoc_insertion_point(field_get:naothmessages.BallModel.speed)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* BallModel::mutable_speed() {
  set_has_speed();
  if (speed_ == NULL) {
    speed_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.BallModel.speed)
  return speed_;
}
inline ::naothmessages::DoubleVector2* BallModel::release_speed() {
  // @@protoc_insertion_point(field_release:naothmessages.BallModel.speed)
  clear_has_speed();
  ::naothmessages::DoubleVector2* temp = speed_;
  speed_ = NULL;
  return temp;
}
inline void BallModel::set_allocated_speed(::naothmessages::DoubleVector2* speed) {
  delete speed_;
  speed_ = speed;
  if (speed) {
    set_has_speed();
  } else {
    clear_has_speed();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallModel.speed)
}

// optional .naothmessages.DoubleVector2 positionPreview = 5;
inline bool BallModel::has_positionpreview() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BallModel::set_has_positionpreview() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BallModel::clear_has_positionpreview() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BallModel::clear_positionpreview() {
  if (positionpreview_ != NULL) positionpreview_->::naothmessages::DoubleVector2::Clear();
  clear_has_positionpreview();
}
inline const ::naothmessages::DoubleVector2& BallModel::positionpreview() const {
  const ::naothmessages::DoubleVector2* p = positionpreview_;
  // @@protoc_insertion_point(field_get:naothmessages.BallModel.positionPreview)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* BallModel::mutable_positionpreview() {
  set_has_positionpreview();
  if (positionpreview_ == NULL) {
    positionpreview_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.BallModel.positionPreview)
  return positionpreview_;
}
inline ::naothmessages::DoubleVector2* BallModel::release_positionpreview() {
  // @@protoc_insertion_point(field_release:naothmessages.BallModel.positionPreview)
  clear_has_positionpreview();
  ::naothmessages::DoubleVector2* temp = positionpreview_;
  positionpreview_ = NULL;
  return temp;
}
inline void BallModel::set_allocated_positionpreview(::naothmessages::DoubleVector2* positionpreview) {
  delete positionpreview_;
  positionpreview_ = positionpreview;
  if (positionpreview) {
    set_has_positionpreview();
  } else {
    clear_has_positionpreview();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallModel.positionPreview)
}

// optional .naothmessages.DoubleVector2 positionPreviewInLFoot = 6;
inline bool BallModel::has_positionpreviewinlfoot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BallModel::set_has_positionpreviewinlfoot() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BallModel::clear_has_positionpreviewinlfoot() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BallModel::clear_positionpreviewinlfoot() {
  if (positionpreviewinlfoot_ != NULL) positionpreviewinlfoot_->::naothmessages::DoubleVector2::Clear();
  clear_has_positionpreviewinlfoot();
}
inline const ::naothmessages::DoubleVector2& BallModel::positionpreviewinlfoot() const {
  const ::naothmessages::DoubleVector2* p = positionpreviewinlfoot_;
  // @@protoc_insertion_point(field_get:naothmessages.BallModel.positionPreviewInLFoot)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* BallModel::mutable_positionpreviewinlfoot() {
  set_has_positionpreviewinlfoot();
  if (positionpreviewinlfoot_ == NULL) {
    positionpreviewinlfoot_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.BallModel.positionPreviewInLFoot)
  return positionpreviewinlfoot_;
}
inline ::naothmessages::DoubleVector2* BallModel::release_positionpreviewinlfoot() {
  // @@protoc_insertion_point(field_release:naothmessages.BallModel.positionPreviewInLFoot)
  clear_has_positionpreviewinlfoot();
  ::naothmessages::DoubleVector2* temp = positionpreviewinlfoot_;
  positionpreviewinlfoot_ = NULL;
  return temp;
}
inline void BallModel::set_allocated_positionpreviewinlfoot(::naothmessages::DoubleVector2* positionpreviewinlfoot) {
  delete positionpreviewinlfoot_;
  positionpreviewinlfoot_ = positionpreviewinlfoot;
  if (positionpreviewinlfoot) {
    set_has_positionpreviewinlfoot();
  } else {
    clear_has_positionpreviewinlfoot();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallModel.positionPreviewInLFoot)
}

// optional .naothmessages.DoubleVector2 positionPreviewInRFoot = 7;
inline bool BallModel::has_positionpreviewinrfoot() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BallModel::set_has_positionpreviewinrfoot() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BallModel::clear_has_positionpreviewinrfoot() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BallModel::clear_positionpreviewinrfoot() {
  if (positionpreviewinrfoot_ != NULL) positionpreviewinrfoot_->::naothmessages::DoubleVector2::Clear();
  clear_has_positionpreviewinrfoot();
}
inline const ::naothmessages::DoubleVector2& BallModel::positionpreviewinrfoot() const {
  const ::naothmessages::DoubleVector2* p = positionpreviewinrfoot_;
  // @@protoc_insertion_point(field_get:naothmessages.BallModel.positionPreviewInRFoot)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* BallModel::mutable_positionpreviewinrfoot() {
  set_has_positionpreviewinrfoot();
  if (positionpreviewinrfoot_ == NULL) {
    positionpreviewinrfoot_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.BallModel.positionPreviewInRFoot)
  return positionpreviewinrfoot_;
}
inline ::naothmessages::DoubleVector2* BallModel::release_positionpreviewinrfoot() {
  // @@protoc_insertion_point(field_release:naothmessages.BallModel.positionPreviewInRFoot)
  clear_has_positionpreviewinrfoot();
  ::naothmessages::DoubleVector2* temp = positionpreviewinrfoot_;
  positionpreviewinrfoot_ = NULL;
  return temp;
}
inline void BallModel::set_allocated_positionpreviewinrfoot(::naothmessages::DoubleVector2* positionpreviewinrfoot) {
  delete positionpreviewinrfoot_;
  positionpreviewinrfoot_ = positionpreviewinrfoot;
  if (positionpreviewinrfoot) {
    set_has_positionpreviewinrfoot();
  } else {
    clear_has_positionpreviewinrfoot();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallModel.positionPreviewInRFoot)
}

// repeated .naothmessages.DoubleVector2 futurePosition = 8 [deprecated = true];
inline int BallModel::futureposition_size() const {
  return futureposition_.size();
}
inline void BallModel::clear_futureposition() {
  futureposition_.Clear();
}
inline const ::naothmessages::DoubleVector2& BallModel::futureposition(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.BallModel.futurePosition)
  return futureposition_.Get(index);
}
inline ::naothmessages::DoubleVector2* BallModel::mutable_futureposition(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.BallModel.futurePosition)
  return futureposition_.Mutable(index);
}
inline ::naothmessages::DoubleVector2* BallModel::add_futureposition() {
  // @@protoc_insertion_point(field_add:naothmessages.BallModel.futurePosition)
  return futureposition_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
BallModel::mutable_futureposition() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.BallModel.futurePosition)
  return &futureposition_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
BallModel::futureposition() const {
  // @@protoc_insertion_point(field_list:naothmessages.BallModel.futurePosition)
  return futureposition_;
}

// -------------------------------------------------------------------

// GoalPercept_GoalPost

// optional .naothmessages.IntVector2 basePoint = 1;
inline bool GoalPercept_GoalPost::has_basepoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoalPercept_GoalPost::set_has_basepoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoalPercept_GoalPost::clear_has_basepoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoalPercept_GoalPost::clear_basepoint() {
  if (basepoint_ != NULL) basepoint_->::naothmessages::IntVector2::Clear();
  clear_has_basepoint();
}
inline const ::naothmessages::IntVector2& GoalPercept_GoalPost::basepoint() const {
  const ::naothmessages::IntVector2* p = basepoint_;
  // @@protoc_insertion_point(field_get:naothmessages.GoalPercept.GoalPost.basePoint)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::IntVector2*>(
      &::naothmessages::_IntVector2_default_instance_);
}
inline ::naothmessages::IntVector2* GoalPercept_GoalPost::mutable_basepoint() {
  set_has_basepoint();
  if (basepoint_ == NULL) {
    basepoint_ = new ::naothmessages::IntVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.GoalPercept.GoalPost.basePoint)
  return basepoint_;
}
inline ::naothmessages::IntVector2* GoalPercept_GoalPost::release_basepoint() {
  // @@protoc_insertion_point(field_release:naothmessages.GoalPercept.GoalPost.basePoint)
  clear_has_basepoint();
  ::naothmessages::IntVector2* temp = basepoint_;
  basepoint_ = NULL;
  return temp;
}
inline void GoalPercept_GoalPost::set_allocated_basepoint(::naothmessages::IntVector2* basepoint) {
  delete basepoint_;
  basepoint_ = basepoint;
  if (basepoint) {
    set_has_basepoint();
  } else {
    clear_has_basepoint();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.GoalPercept.GoalPost.basePoint)
}

// optional .naothmessages.DoubleVector2 position = 2;
inline bool GoalPercept_GoalPost::has_position() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoalPercept_GoalPost::set_has_position() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoalPercept_GoalPost::clear_has_position() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoalPercept_GoalPost::clear_position() {
  if (position_ != NULL) position_->::naothmessages::DoubleVector2::Clear();
  clear_has_position();
}
inline const ::naothmessages::DoubleVector2& GoalPercept_GoalPost::position() const {
  const ::naothmessages::DoubleVector2* p = position_;
  // @@protoc_insertion_point(field_get:naothmessages.GoalPercept.GoalPost.position)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* GoalPercept_GoalPost::mutable_position() {
  set_has_position();
  if (position_ == NULL) {
    position_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.GoalPercept.GoalPost.position)
  return position_;
}
inline ::naothmessages::DoubleVector2* GoalPercept_GoalPost::release_position() {
  // @@protoc_insertion_point(field_release:naothmessages.GoalPercept.GoalPost.position)
  clear_has_position();
  ::naothmessages::DoubleVector2* temp = position_;
  position_ = NULL;
  return temp;
}
inline void GoalPercept_GoalPost::set_allocated_position(::naothmessages::DoubleVector2* position) {
  delete position_;
  position_ = position;
  if (position) {
    set_has_position();
  } else {
    clear_has_position();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.GoalPercept.GoalPost.position)
}

// optional .naothmessages.Color color = 3;
inline bool GoalPercept_GoalPost::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoalPercept_GoalPost::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoalPercept_GoalPost::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoalPercept_GoalPost::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::naothmessages::Color GoalPercept_GoalPost::color() const {
  // @@protoc_insertion_point(field_get:naothmessages.GoalPercept.GoalPost.color)
  return static_cast< ::naothmessages::Color >(color_);
}
inline void GoalPercept_GoalPost::set_color(::naothmessages::Color value) {
  assert(::naothmessages::Color_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GoalPercept.GoalPost.color)
}

// optional .naothmessages.GoalPercept.GoalPost.PostType type = 4;
inline bool GoalPercept_GoalPost::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GoalPercept_GoalPost::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GoalPercept_GoalPost::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GoalPercept_GoalPost::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::naothmessages::GoalPercept_GoalPost_PostType GoalPercept_GoalPost::type() const {
  // @@protoc_insertion_point(field_get:naothmessages.GoalPercept.GoalPost.type)
  return static_cast< ::naothmessages::GoalPercept_GoalPost_PostType >(type_);
}
inline void GoalPercept_GoalPost::set_type(::naothmessages::GoalPercept_GoalPost_PostType value) {
  assert(::naothmessages::GoalPercept_GoalPost_PostType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GoalPercept.GoalPost.type)
}

// optional bool positionReliable = 5;
inline bool GoalPercept_GoalPost::has_positionreliable() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GoalPercept_GoalPost::set_has_positionreliable() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GoalPercept_GoalPost::clear_has_positionreliable() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GoalPercept_GoalPost::clear_positionreliable() {
  positionreliable_ = false;
  clear_has_positionreliable();
}
inline bool GoalPercept_GoalPost::positionreliable() const {
  // @@protoc_insertion_point(field_get:naothmessages.GoalPercept.GoalPost.positionReliable)
  return positionreliable_;
}
inline void GoalPercept_GoalPost::set_positionreliable(bool value) {
  set_has_positionreliable();
  positionreliable_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GoalPercept.GoalPost.positionReliable)
}

// optional double seenHeight = 6;
inline bool GoalPercept_GoalPost::has_seenheight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GoalPercept_GoalPost::set_has_seenheight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GoalPercept_GoalPost::clear_has_seenheight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GoalPercept_GoalPost::clear_seenheight() {
  seenheight_ = 0;
  clear_has_seenheight();
}
inline double GoalPercept_GoalPost::seenheight() const {
  // @@protoc_insertion_point(field_get:naothmessages.GoalPercept.GoalPost.seenHeight)
  return seenheight_;
}
inline void GoalPercept_GoalPost::set_seenheight(double value) {
  set_has_seenheight();
  seenheight_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GoalPercept.GoalPost.seenHeight)
}

// -------------------------------------------------------------------

// GoalPercept

// optional double angleToSeenGoal = 1;
inline bool GoalPercept::has_angletoseengoal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GoalPercept::set_has_angletoseengoal() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GoalPercept::clear_has_angletoseengoal() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GoalPercept::clear_angletoseengoal() {
  angletoseengoal_ = 0;
  clear_has_angletoseengoal();
}
inline double GoalPercept::angletoseengoal() const {
  // @@protoc_insertion_point(field_get:naothmessages.GoalPercept.angleToSeenGoal)
  return angletoseengoal_;
}
inline void GoalPercept::set_angletoseengoal(double value) {
  set_has_angletoseengoal();
  angletoseengoal_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GoalPercept.angleToSeenGoal)
}

// optional .naothmessages.DoubleVector3 goalCentroid = 2;
inline bool GoalPercept::has_goalcentroid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GoalPercept::set_has_goalcentroid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GoalPercept::clear_has_goalcentroid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GoalPercept::clear_goalcentroid() {
  if (goalcentroid_ != NULL) goalcentroid_->::naothmessages::DoubleVector3::Clear();
  clear_has_goalcentroid();
}
inline const ::naothmessages::DoubleVector3& GoalPercept::goalcentroid() const {
  const ::naothmessages::DoubleVector3* p = goalcentroid_;
  // @@protoc_insertion_point(field_get:naothmessages.GoalPercept.goalCentroid)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* GoalPercept::mutable_goalcentroid() {
  set_has_goalcentroid();
  if (goalcentroid_ == NULL) {
    goalcentroid_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.GoalPercept.goalCentroid)
  return goalcentroid_;
}
inline ::naothmessages::DoubleVector3* GoalPercept::release_goalcentroid() {
  // @@protoc_insertion_point(field_release:naothmessages.GoalPercept.goalCentroid)
  clear_has_goalcentroid();
  ::naothmessages::DoubleVector3* temp = goalcentroid_;
  goalcentroid_ = NULL;
  return temp;
}
inline void GoalPercept::set_allocated_goalcentroid(::naothmessages::DoubleVector3* goalcentroid) {
  delete goalcentroid_;
  goalcentroid_ = goalcentroid;
  if (goalcentroid) {
    set_has_goalcentroid();
  } else {
    clear_has_goalcentroid();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.GoalPercept.goalCentroid)
}

// optional int32 numberOfSeenPosts = 3;
inline bool GoalPercept::has_numberofseenposts() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GoalPercept::set_has_numberofseenposts() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GoalPercept::clear_has_numberofseenposts() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GoalPercept::clear_numberofseenposts() {
  numberofseenposts_ = 0;
  clear_has_numberofseenposts();
}
inline ::google::protobuf::int32 GoalPercept::numberofseenposts() const {
  // @@protoc_insertion_point(field_get:naothmessages.GoalPercept.numberOfSeenPosts)
  return numberofseenposts_;
}
inline void GoalPercept::set_numberofseenposts(::google::protobuf::int32 value) {
  set_has_numberofseenposts();
  numberofseenposts_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GoalPercept.numberOfSeenPosts)
}

// repeated .naothmessages.GoalPercept.GoalPost post = 4;
inline int GoalPercept::post_size() const {
  return post_.size();
}
inline void GoalPercept::clear_post() {
  post_.Clear();
}
inline const ::naothmessages::GoalPercept_GoalPost& GoalPercept::post(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.GoalPercept.post)
  return post_.Get(index);
}
inline ::naothmessages::GoalPercept_GoalPost* GoalPercept::mutable_post(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.GoalPercept.post)
  return post_.Mutable(index);
}
inline ::naothmessages::GoalPercept_GoalPost* GoalPercept::add_post() {
  // @@protoc_insertion_point(field_add:naothmessages.GoalPercept.post)
  return post_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::GoalPercept_GoalPost >*
GoalPercept::mutable_post() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.GoalPercept.post)
  return &post_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::GoalPercept_GoalPost >&
GoalPercept::post() const {
  // @@protoc_insertion_point(field_list:naothmessages.GoalPercept.post)
  return post_;
}

// -------------------------------------------------------------------

// HeadMotionRequest

// required uint32 id = 1;
inline bool HeadMotionRequest::has_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void HeadMotionRequest::set_has_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void HeadMotionRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void HeadMotionRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 HeadMotionRequest::id() const {
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.id)
  return id_;
}
inline void HeadMotionRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.HeadMotionRequest.id)
}

// required uint32 cameraID = 2;
inline bool HeadMotionRequest::has_cameraid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void HeadMotionRequest::set_has_cameraid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void HeadMotionRequest::clear_has_cameraid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void HeadMotionRequest::clear_cameraid() {
  cameraid_ = 0u;
  clear_has_cameraid();
}
inline ::google::protobuf::uint32 HeadMotionRequest::cameraid() const {
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.cameraID)
  return cameraid_;
}
inline void HeadMotionRequest::set_cameraid(::google::protobuf::uint32 value) {
  set_has_cameraid();
  cameraid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.HeadMotionRequest.cameraID)
}

// optional .naothmessages.DoubleVector2 targetJointPosition = 3;
inline bool HeadMotionRequest::has_targetjointposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HeadMotionRequest::set_has_targetjointposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HeadMotionRequest::clear_has_targetjointposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HeadMotionRequest::clear_targetjointposition() {
  if (targetjointposition_ != NULL) targetjointposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_targetjointposition();
}
inline const ::naothmessages::DoubleVector2& HeadMotionRequest::targetjointposition() const {
  const ::naothmessages::DoubleVector2* p = targetjointposition_;
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.targetJointPosition)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::mutable_targetjointposition() {
  set_has_targetjointposition();
  if (targetjointposition_ == NULL) {
    targetjointposition_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.HeadMotionRequest.targetJointPosition)
  return targetjointposition_;
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::release_targetjointposition() {
  // @@protoc_insertion_point(field_release:naothmessages.HeadMotionRequest.targetJointPosition)
  clear_has_targetjointposition();
  ::naothmessages::DoubleVector2* temp = targetjointposition_;
  targetjointposition_ = NULL;
  return temp;
}
inline void HeadMotionRequest::set_allocated_targetjointposition(::naothmessages::DoubleVector2* targetjointposition) {
  delete targetjointposition_;
  targetjointposition_ = targetjointposition;
  if (targetjointposition) {
    set_has_targetjointposition();
  } else {
    clear_has_targetjointposition();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.HeadMotionRequest.targetJointPosition)
}

// optional .naothmessages.DoubleVector2 targetPointInImage = 4;
inline bool HeadMotionRequest::has_targetpointinimage() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HeadMotionRequest::set_has_targetpointinimage() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HeadMotionRequest::clear_has_targetpointinimage() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HeadMotionRequest::clear_targetpointinimage() {
  if (targetpointinimage_ != NULL) targetpointinimage_->::naothmessages::DoubleVector2::Clear();
  clear_has_targetpointinimage();
}
inline const ::naothmessages::DoubleVector2& HeadMotionRequest::targetpointinimage() const {
  const ::naothmessages::DoubleVector2* p = targetpointinimage_;
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.targetPointInImage)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::mutable_targetpointinimage() {
  set_has_targetpointinimage();
  if (targetpointinimage_ == NULL) {
    targetpointinimage_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.HeadMotionRequest.targetPointInImage)
  return targetpointinimage_;
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::release_targetpointinimage() {
  // @@protoc_insertion_point(field_release:naothmessages.HeadMotionRequest.targetPointInImage)
  clear_has_targetpointinimage();
  ::naothmessages::DoubleVector2* temp = targetpointinimage_;
  targetpointinimage_ = NULL;
  return temp;
}
inline void HeadMotionRequest::set_allocated_targetpointinimage(::naothmessages::DoubleVector2* targetpointinimage) {
  delete targetpointinimage_;
  targetpointinimage_ = targetpointinimage;
  if (targetpointinimage) {
    set_has_targetpointinimage();
  } else {
    clear_has_targetpointinimage();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.HeadMotionRequest.targetPointInImage)
}

// optional .naothmessages.DoubleVector3 targetPointInTheWorld = 5;
inline bool HeadMotionRequest::has_targetpointintheworld() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HeadMotionRequest::set_has_targetpointintheworld() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HeadMotionRequest::clear_has_targetpointintheworld() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HeadMotionRequest::clear_targetpointintheworld() {
  if (targetpointintheworld_ != NULL) targetpointintheworld_->::naothmessages::DoubleVector3::Clear();
  clear_has_targetpointintheworld();
}
inline const ::naothmessages::DoubleVector3& HeadMotionRequest::targetpointintheworld() const {
  const ::naothmessages::DoubleVector3* p = targetpointintheworld_;
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.targetPointInTheWorld)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::mutable_targetpointintheworld() {
  set_has_targetpointintheworld();
  if (targetpointintheworld_ == NULL) {
    targetpointintheworld_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.HeadMotionRequest.targetPointInTheWorld)
  return targetpointintheworld_;
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::release_targetpointintheworld() {
  // @@protoc_insertion_point(field_release:naothmessages.HeadMotionRequest.targetPointInTheWorld)
  clear_has_targetpointintheworld();
  ::naothmessages::DoubleVector3* temp = targetpointintheworld_;
  targetpointintheworld_ = NULL;
  return temp;
}
inline void HeadMotionRequest::set_allocated_targetpointintheworld(::naothmessages::DoubleVector3* targetpointintheworld) {
  delete targetpointintheworld_;
  targetpointintheworld_ = targetpointintheworld;
  if (targetpointintheworld) {
    set_has_targetpointintheworld();
  } else {
    clear_has_targetpointintheworld();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.HeadMotionRequest.targetPointInTheWorld)
}

// optional .naothmessages.DoubleVector3 searchCenter = 6;
inline bool HeadMotionRequest::has_searchcenter() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HeadMotionRequest::set_has_searchcenter() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HeadMotionRequest::clear_has_searchcenter() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HeadMotionRequest::clear_searchcenter() {
  if (searchcenter_ != NULL) searchcenter_->::naothmessages::DoubleVector3::Clear();
  clear_has_searchcenter();
}
inline const ::naothmessages::DoubleVector3& HeadMotionRequest::searchcenter() const {
  const ::naothmessages::DoubleVector3* p = searchcenter_;
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.searchCenter)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::mutable_searchcenter() {
  set_has_searchcenter();
  if (searchcenter_ == NULL) {
    searchcenter_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.HeadMotionRequest.searchCenter)
  return searchcenter_;
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::release_searchcenter() {
  // @@protoc_insertion_point(field_release:naothmessages.HeadMotionRequest.searchCenter)
  clear_has_searchcenter();
  ::naothmessages::DoubleVector3* temp = searchcenter_;
  searchcenter_ = NULL;
  return temp;
}
inline void HeadMotionRequest::set_allocated_searchcenter(::naothmessages::DoubleVector3* searchcenter) {
  delete searchcenter_;
  searchcenter_ = searchcenter;
  if (searchcenter) {
    set_has_searchcenter();
  } else {
    clear_has_searchcenter();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.HeadMotionRequest.searchCenter)
}

// optional .naothmessages.DoubleVector3 searchSize = 7;
inline bool HeadMotionRequest::has_searchsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HeadMotionRequest::set_has_searchsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HeadMotionRequest::clear_has_searchsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HeadMotionRequest::clear_searchsize() {
  if (searchsize_ != NULL) searchsize_->::naothmessages::DoubleVector3::Clear();
  clear_has_searchsize();
}
inline const ::naothmessages::DoubleVector3& HeadMotionRequest::searchsize() const {
  const ::naothmessages::DoubleVector3* p = searchsize_;
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.searchSize)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::mutable_searchsize() {
  set_has_searchsize();
  if (searchsize_ == NULL) {
    searchsize_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.HeadMotionRequest.searchSize)
  return searchsize_;
}
inline ::naothmessages::DoubleVector3* HeadMotionRequest::release_searchsize() {
  // @@protoc_insertion_point(field_release:naothmessages.HeadMotionRequest.searchSize)
  clear_has_searchsize();
  ::naothmessages::DoubleVector3* temp = searchsize_;
  searchsize_ = NULL;
  return temp;
}
inline void HeadMotionRequest::set_allocated_searchsize(::naothmessages::DoubleVector3* searchsize) {
  delete searchsize_;
  searchsize_ = searchsize;
  if (searchsize) {
    set_has_searchsize();
  } else {
    clear_has_searchsize();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.HeadMotionRequest.searchSize)
}

// optional bool searchDirection = 8;
inline bool HeadMotionRequest::has_searchdirection() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void HeadMotionRequest::set_has_searchdirection() {
  _has_bits_[0] |= 0x00000100u;
}
inline void HeadMotionRequest::clear_has_searchdirection() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void HeadMotionRequest::clear_searchdirection() {
  searchdirection_ = false;
  clear_has_searchdirection();
}
inline bool HeadMotionRequest::searchdirection() const {
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.searchDirection)
  return searchdirection_;
}
inline void HeadMotionRequest::set_searchdirection(bool value) {
  set_has_searchdirection();
  searchdirection_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.HeadMotionRequest.searchDirection)
}

// optional .naothmessages.DoubleVector2 targetPointOnTheGround = 9;
inline bool HeadMotionRequest::has_targetpointontheground() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void HeadMotionRequest::set_has_targetpointontheground() {
  _has_bits_[0] |= 0x00000020u;
}
inline void HeadMotionRequest::clear_has_targetpointontheground() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void HeadMotionRequest::clear_targetpointontheground() {
  if (targetpointontheground_ != NULL) targetpointontheground_->::naothmessages::DoubleVector2::Clear();
  clear_has_targetpointontheground();
}
inline const ::naothmessages::DoubleVector2& HeadMotionRequest::targetpointontheground() const {
  const ::naothmessages::DoubleVector2* p = targetpointontheground_;
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.targetPointOnTheGround)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::mutable_targetpointontheground() {
  set_has_targetpointontheground();
  if (targetpointontheground_ == NULL) {
    targetpointontheground_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.HeadMotionRequest.targetPointOnTheGround)
  return targetpointontheground_;
}
inline ::naothmessages::DoubleVector2* HeadMotionRequest::release_targetpointontheground() {
  // @@protoc_insertion_point(field_release:naothmessages.HeadMotionRequest.targetPointOnTheGround)
  clear_has_targetpointontheground();
  ::naothmessages::DoubleVector2* temp = targetpointontheground_;
  targetpointontheground_ = NULL;
  return temp;
}
inline void HeadMotionRequest::set_allocated_targetpointontheground(::naothmessages::DoubleVector2* targetpointontheground) {
  delete targetpointontheground_;
  targetpointontheground_ = targetpointontheground;
  if (targetpointontheground) {
    set_has_targetpointontheground();
  } else {
    clear_has_targetpointontheground();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.HeadMotionRequest.targetPointOnTheGround)
}

// optional uint32 coordinate = 10;
inline bool HeadMotionRequest::has_coordinate() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void HeadMotionRequest::set_has_coordinate() {
  _has_bits_[0] |= 0x00000200u;
}
inline void HeadMotionRequest::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void HeadMotionRequest::clear_coordinate() {
  coordinate_ = 0u;
  clear_has_coordinate();
}
inline ::google::protobuf::uint32 HeadMotionRequest::coordinate() const {
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.coordinate)
  return coordinate_;
}
inline void HeadMotionRequest::set_coordinate(::google::protobuf::uint32 value) {
  set_has_coordinate();
  coordinate_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.HeadMotionRequest.coordinate)
}

// optional double velocity = 11;
inline bool HeadMotionRequest::has_velocity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void HeadMotionRequest::set_has_velocity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void HeadMotionRequest::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void HeadMotionRequest::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline double HeadMotionRequest::velocity() const {
  // @@protoc_insertion_point(field_get:naothmessages.HeadMotionRequest.velocity)
  return velocity_;
}
inline void HeadMotionRequest::set_velocity(double value) {
  set_has_velocity();
  velocity_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.HeadMotionRequest.velocity)
}

// -------------------------------------------------------------------

// StepControlRequest

// required uint32 stepID = 1;
inline bool StepControlRequest::has_stepid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StepControlRequest::set_has_stepid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StepControlRequest::clear_has_stepid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StepControlRequest::clear_stepid() {
  stepid_ = 0u;
  clear_has_stepid();
}
inline ::google::protobuf::uint32 StepControlRequest::stepid() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlRequest.stepID)
  return stepid_;
}
inline void StepControlRequest::set_stepid(::google::protobuf::uint32 value) {
  set_has_stepid();
  stepid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlRequest.stepID)
}

// required bool moveLeftFoot = 2;
inline bool StepControlRequest::has_moveleftfoot() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StepControlRequest::set_has_moveleftfoot() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StepControlRequest::clear_has_moveleftfoot() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StepControlRequest::clear_moveleftfoot() {
  moveleftfoot_ = false;
  clear_has_moveleftfoot();
}
inline bool StepControlRequest::moveleftfoot() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlRequest.moveLeftFoot)
  return moveleftfoot_;
}
inline void StepControlRequest::set_moveleftfoot(bool value) {
  set_has_moveleftfoot();
  moveleftfoot_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlRequest.moveLeftFoot)
}

// required .naothmessages.Pose2D target = 3;
inline bool StepControlRequest::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StepControlRequest::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StepControlRequest::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StepControlRequest::clear_target() {
  if (target_ != NULL) target_->::naothmessages::Pose2D::Clear();
  clear_has_target();
}
inline const ::naothmessages::Pose2D& StepControlRequest::target() const {
  const ::naothmessages::Pose2D* p = target_;
  // @@protoc_insertion_point(field_get:naothmessages.StepControlRequest.target)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose2D*>(
      &::naothmessages::_Pose2D_default_instance_);
}
inline ::naothmessages::Pose2D* StepControlRequest::mutable_target() {
  set_has_target();
  if (target_ == NULL) {
    target_ = new ::naothmessages::Pose2D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.StepControlRequest.target)
  return target_;
}
inline ::naothmessages::Pose2D* StepControlRequest::release_target() {
  // @@protoc_insertion_point(field_release:naothmessages.StepControlRequest.target)
  clear_has_target();
  ::naothmessages::Pose2D* temp = target_;
  target_ = NULL;
  return temp;
}
inline void StepControlRequest::set_allocated_target(::naothmessages::Pose2D* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.StepControlRequest.target)
}

// required uint32 time = 4;
inline bool StepControlRequest::has_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StepControlRequest::set_has_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StepControlRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StepControlRequest::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 StepControlRequest::time() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlRequest.time)
  return time_;
}
inline void StepControlRequest::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlRequest.time)
}

// required double speedDirection = 5;
inline bool StepControlRequest::has_speeddirection() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StepControlRequest::set_has_speeddirection() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StepControlRequest::clear_has_speeddirection() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StepControlRequest::clear_speeddirection() {
  speeddirection_ = 0;
  clear_has_speeddirection();
}
inline double StepControlRequest::speeddirection() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlRequest.speedDirection)
  return speeddirection_;
}
inline void StepControlRequest::set_speeddirection(double value) {
  set_has_speeddirection();
  speeddirection_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlRequest.speedDirection)
}

// required double scale = 6;
inline bool StepControlRequest::has_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StepControlRequest::set_has_scale() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StepControlRequest::clear_has_scale() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StepControlRequest::clear_scale() {
  scale_ = 0;
  clear_has_scale();
}
inline double StepControlRequest::scale() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlRequest.scale)
  return scale_;
}
inline void StepControlRequest::set_scale(double value) {
  set_has_scale();
  scale_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlRequest.scale)
}

// required .naothmessages.StepControlRequest.StepType steptype = 7;
inline bool StepControlRequest::has_steptype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StepControlRequest::set_has_steptype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StepControlRequest::clear_has_steptype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StepControlRequest::clear_steptype() {
  steptype_ = 0;
  clear_has_steptype();
}
inline ::naothmessages::StepControlRequest_StepType StepControlRequest::steptype() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlRequest.steptype)
  return static_cast< ::naothmessages::StepControlRequest_StepType >(steptype_);
}
inline void StepControlRequest::set_steptype(::naothmessages::StepControlRequest_StepType value) {
  assert(::naothmessages::StepControlRequest_StepType_IsValid(value));
  set_has_steptype();
  steptype_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlRequest.steptype)
}

// required .naothmessages.StepControlRequest.RestrictionMode restriction = 8;
inline bool StepControlRequest::has_restriction() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StepControlRequest::set_has_restriction() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StepControlRequest::clear_has_restriction() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StepControlRequest::clear_restriction() {
  restriction_ = 0;
  clear_has_restriction();
}
inline ::naothmessages::StepControlRequest_RestrictionMode StepControlRequest::restriction() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlRequest.restriction)
  return static_cast< ::naothmessages::StepControlRequest_RestrictionMode >(restriction_);
}
inline void StepControlRequest::set_restriction(::naothmessages::StepControlRequest_RestrictionMode value) {
  assert(::naothmessages::StepControlRequest_RestrictionMode_IsValid(value));
  set_has_restriction();
  restriction_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlRequest.restriction)
}

// required bool isProtected = 9;
inline bool StepControlRequest::has_isprotected() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StepControlRequest::set_has_isprotected() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StepControlRequest::clear_has_isprotected() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StepControlRequest::clear_isprotected() {
  isprotected_ = false;
  clear_has_isprotected();
}
inline bool StepControlRequest::isprotected() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlRequest.isProtected)
  return isprotected_;
}
inline void StepControlRequest::set_isprotected(bool value) {
  set_has_isprotected();
  isprotected_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlRequest.isProtected)
}

// required uint32 stepRequestID = 10;
inline bool StepControlRequest::has_steprequestid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StepControlRequest::set_has_steprequestid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StepControlRequest::clear_has_steprequestid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StepControlRequest::clear_steprequestid() {
  steprequestid_ = 0u;
  clear_has_steprequestid();
}
inline ::google::protobuf::uint32 StepControlRequest::steprequestid() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlRequest.stepRequestID)
  return steprequestid_;
}
inline void StepControlRequest::set_steprequestid(::google::protobuf::uint32 value) {
  set_has_steprequestid();
  steprequestid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlRequest.stepRequestID)
}

// -------------------------------------------------------------------

// WalkRequest

// required uint32 coordinate = 1;
inline bool WalkRequest::has_coordinate() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WalkRequest::set_has_coordinate() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WalkRequest::clear_has_coordinate() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WalkRequest::clear_coordinate() {
  coordinate_ = 0u;
  clear_has_coordinate();
}
inline ::google::protobuf::uint32 WalkRequest::coordinate() const {
  // @@protoc_insertion_point(field_get:naothmessages.WalkRequest.coordinate)
  return coordinate_;
}
inline void WalkRequest::set_coordinate(::google::protobuf::uint32 value) {
  set_has_coordinate();
  coordinate_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.WalkRequest.coordinate)
}

// required double character = 2;
inline bool WalkRequest::has_character() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WalkRequest::set_has_character() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WalkRequest::clear_has_character() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WalkRequest::clear_character() {
  character_ = 0;
  clear_has_character();
}
inline double WalkRequest::character() const {
  // @@protoc_insertion_point(field_get:naothmessages.WalkRequest.character)
  return character_;
}
inline void WalkRequest::set_character(double value) {
  set_has_character();
  character_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.WalkRequest.character)
}

// required .naothmessages.Pose2D target = 3;
inline bool WalkRequest::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WalkRequest::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WalkRequest::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WalkRequest::clear_target() {
  if (target_ != NULL) target_->::naothmessages::Pose2D::Clear();
  clear_has_target();
}
inline const ::naothmessages::Pose2D& WalkRequest::target() const {
  const ::naothmessages::Pose2D* p = target_;
  // @@protoc_insertion_point(field_get:naothmessages.WalkRequest.target)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose2D*>(
      &::naothmessages::_Pose2D_default_instance_);
}
inline ::naothmessages::Pose2D* WalkRequest::mutable_target() {
  set_has_target();
  if (target_ == NULL) {
    target_ = new ::naothmessages::Pose2D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.WalkRequest.target)
  return target_;
}
inline ::naothmessages::Pose2D* WalkRequest::release_target() {
  // @@protoc_insertion_point(field_release:naothmessages.WalkRequest.target)
  clear_has_target();
  ::naothmessages::Pose2D* temp = target_;
  target_ = NULL;
  return temp;
}
inline void WalkRequest::set_allocated_target(::naothmessages::Pose2D* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.WalkRequest.target)
}

// optional .naothmessages.StepControlRequest stepControl = 4;
inline bool WalkRequest::has_stepcontrol() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WalkRequest::set_has_stepcontrol() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WalkRequest::clear_has_stepcontrol() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WalkRequest::clear_stepcontrol() {
  if (stepcontrol_ != NULL) stepcontrol_->::naothmessages::StepControlRequest::Clear();
  clear_has_stepcontrol();
}
inline const ::naothmessages::StepControlRequest& WalkRequest::stepcontrol() const {
  const ::naothmessages::StepControlRequest* p = stepcontrol_;
  // @@protoc_insertion_point(field_get:naothmessages.WalkRequest.stepControl)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::StepControlRequest*>(
      &::naothmessages::_StepControlRequest_default_instance_);
}
inline ::naothmessages::StepControlRequest* WalkRequest::mutable_stepcontrol() {
  set_has_stepcontrol();
  if (stepcontrol_ == NULL) {
    stepcontrol_ = new ::naothmessages::StepControlRequest;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.WalkRequest.stepControl)
  return stepcontrol_;
}
inline ::naothmessages::StepControlRequest* WalkRequest::release_stepcontrol() {
  // @@protoc_insertion_point(field_release:naothmessages.WalkRequest.stepControl)
  clear_has_stepcontrol();
  ::naothmessages::StepControlRequest* temp = stepcontrol_;
  stepcontrol_ = NULL;
  return temp;
}
inline void WalkRequest::set_allocated_stepcontrol(::naothmessages::StepControlRequest* stepcontrol) {
  delete stepcontrol_;
  stepcontrol_ = stepcontrol;
  if (stepcontrol) {
    set_has_stepcontrol();
  } else {
    clear_has_stepcontrol();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.WalkRequest.stepControl)
}

// required .naothmessages.Pose2D offset = 5;
inline bool WalkRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WalkRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WalkRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WalkRequest::clear_offset() {
  if (offset_ != NULL) offset_->::naothmessages::Pose2D::Clear();
  clear_has_offset();
}
inline const ::naothmessages::Pose2D& WalkRequest::offset() const {
  const ::naothmessages::Pose2D* p = offset_;
  // @@protoc_insertion_point(field_get:naothmessages.WalkRequest.offset)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose2D*>(
      &::naothmessages::_Pose2D_default_instance_);
}
inline ::naothmessages::Pose2D* WalkRequest::mutable_offset() {
  set_has_offset();
  if (offset_ == NULL) {
    offset_ = new ::naothmessages::Pose2D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.WalkRequest.offset)
  return offset_;
}
inline ::naothmessages::Pose2D* WalkRequest::release_offset() {
  // @@protoc_insertion_point(field_release:naothmessages.WalkRequest.offset)
  clear_has_offset();
  ::naothmessages::Pose2D* temp = offset_;
  offset_ = NULL;
  return temp;
}
inline void WalkRequest::set_allocated_offset(::naothmessages::Pose2D* offset) {
  delete offset_;
  offset_ = offset;
  if (offset) {
    set_has_offset();
  } else {
    clear_has_offset();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.WalkRequest.offset)
}

// -------------------------------------------------------------------

// KickRequest

// required .naothmessages.DoubleVector3 kickPoint = 1;
inline bool KickRequest::has_kickpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KickRequest::set_has_kickpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KickRequest::clear_has_kickpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KickRequest::clear_kickpoint() {
  if (kickpoint_ != NULL) kickpoint_->::naothmessages::DoubleVector3::Clear();
  clear_has_kickpoint();
}
inline const ::naothmessages::DoubleVector3& KickRequest::kickpoint() const {
  const ::naothmessages::DoubleVector3* p = kickpoint_;
  // @@protoc_insertion_point(field_get:naothmessages.KickRequest.kickPoint)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* KickRequest::mutable_kickpoint() {
  set_has_kickpoint();
  if (kickpoint_ == NULL) {
    kickpoint_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.KickRequest.kickPoint)
  return kickpoint_;
}
inline ::naothmessages::DoubleVector3* KickRequest::release_kickpoint() {
  // @@protoc_insertion_point(field_release:naothmessages.KickRequest.kickPoint)
  clear_has_kickpoint();
  ::naothmessages::DoubleVector3* temp = kickpoint_;
  kickpoint_ = NULL;
  return temp;
}
inline void KickRequest::set_allocated_kickpoint(::naothmessages::DoubleVector3* kickpoint) {
  delete kickpoint_;
  kickpoint_ = kickpoint;
  if (kickpoint) {
    set_has_kickpoint();
  } else {
    clear_has_kickpoint();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.KickRequest.kickPoint)
}

// required double kickDirection = 2;
inline bool KickRequest::has_kickdirection() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KickRequest::set_has_kickdirection() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KickRequest::clear_has_kickdirection() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KickRequest::clear_kickdirection() {
  kickdirection_ = 0;
  clear_has_kickdirection();
}
inline double KickRequest::kickdirection() const {
  // @@protoc_insertion_point(field_get:naothmessages.KickRequest.kickDirection)
  return kickdirection_;
}
inline void KickRequest::set_kickdirection(double value) {
  set_has_kickdirection();
  kickdirection_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.KickRequest.kickDirection)
}

// required int32 kickFoot = 3;
inline bool KickRequest::has_kickfoot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KickRequest::set_has_kickfoot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KickRequest::clear_has_kickfoot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KickRequest::clear_kickfoot() {
  kickfoot_ = 0;
  clear_has_kickfoot();
}
inline ::google::protobuf::int32 KickRequest::kickfoot() const {
  // @@protoc_insertion_point(field_get:naothmessages.KickRequest.kickFoot)
  return kickfoot_;
}
inline void KickRequest::set_kickfoot(::google::protobuf::int32 value) {
  set_has_kickfoot();
  kickfoot_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.KickRequest.kickFoot)
}

// required bool finishKick = 4;
inline bool KickRequest::has_finishkick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KickRequest::set_has_finishkick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KickRequest::clear_has_finishkick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KickRequest::clear_finishkick() {
  finishkick_ = false;
  clear_has_finishkick();
}
inline bool KickRequest::finishkick() const {
  // @@protoc_insertion_point(field_get:naothmessages.KickRequest.finishKick)
  return finishkick_;
}
inline void KickRequest::set_finishkick(bool value) {
  set_has_finishkick();
  finishkick_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.KickRequest.finishKick)
}

// -------------------------------------------------------------------

// GraspRequest

// required .naothmessages.DoubleVector3 graspingPoint = 1;
inline bool GraspRequest::has_graspingpoint() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GraspRequest::set_has_graspingpoint() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GraspRequest::clear_has_graspingpoint() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GraspRequest::clear_graspingpoint() {
  if (graspingpoint_ != NULL) graspingpoint_->::naothmessages::DoubleVector3::Clear();
  clear_has_graspingpoint();
}
inline const ::naothmessages::DoubleVector3& GraspRequest::graspingpoint() const {
  const ::naothmessages::DoubleVector3* p = graspingpoint_;
  // @@protoc_insertion_point(field_get:naothmessages.GraspRequest.graspingPoint)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* GraspRequest::mutable_graspingpoint() {
  set_has_graspingpoint();
  if (graspingpoint_ == NULL) {
    graspingpoint_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.GraspRequest.graspingPoint)
  return graspingpoint_;
}
inline ::naothmessages::DoubleVector3* GraspRequest::release_graspingpoint() {
  // @@protoc_insertion_point(field_release:naothmessages.GraspRequest.graspingPoint)
  clear_has_graspingpoint();
  ::naothmessages::DoubleVector3* temp = graspingpoint_;
  graspingpoint_ = NULL;
  return temp;
}
inline void GraspRequest::set_allocated_graspingpoint(::naothmessages::DoubleVector3* graspingpoint) {
  delete graspingpoint_;
  graspingpoint_ = graspingpoint;
  if (graspingpoint) {
    set_has_graspingpoint();
  } else {
    clear_has_graspingpoint();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.GraspRequest.graspingPoint)
}

// required uint32 graspingState = 2;
inline bool GraspRequest::has_graspingstate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GraspRequest::set_has_graspingstate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GraspRequest::clear_has_graspingstate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GraspRequest::clear_graspingstate() {
  graspingstate_ = 0u;
  clear_has_graspingstate();
}
inline ::google::protobuf::uint32 GraspRequest::graspingstate() const {
  // @@protoc_insertion_point(field_get:naothmessages.GraspRequest.graspingState)
  return graspingstate_;
}
inline void GraspRequest::set_graspingstate(::google::protobuf::uint32 value) {
  set_has_graspingstate();
  graspingstate_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GraspRequest.graspingState)
}

// required uint32 graspDistState = 3;
inline bool GraspRequest::has_graspdiststate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GraspRequest::set_has_graspdiststate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GraspRequest::clear_has_graspdiststate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GraspRequest::clear_graspdiststate() {
  graspdiststate_ = 0u;
  clear_has_graspdiststate();
}
inline ::google::protobuf::uint32 GraspRequest::graspdiststate() const {
  // @@protoc_insertion_point(field_get:naothmessages.GraspRequest.graspDistState)
  return graspdiststate_;
}
inline void GraspRequest::set_graspdiststate(::google::protobuf::uint32 value) {
  set_has_graspdiststate();
  graspdiststate_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GraspRequest.graspDistState)
}

// required uint32 graspStiffState = 4;
inline bool GraspRequest::has_graspstiffstate() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GraspRequest::set_has_graspstiffstate() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GraspRequest::clear_has_graspstiffstate() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GraspRequest::clear_graspstiffstate() {
  graspstiffstate_ = 0u;
  clear_has_graspstiffstate();
}
inline ::google::protobuf::uint32 GraspRequest::graspstiffstate() const {
  // @@protoc_insertion_point(field_get:naothmessages.GraspRequest.graspStiffState)
  return graspstiffstate_;
}
inline void GraspRequest::set_graspstiffstate(::google::protobuf::uint32 value) {
  set_has_graspstiffstate();
  graspstiffstate_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GraspRequest.graspStiffState)
}

// -------------------------------------------------------------------

// ArmMotionRequest

// required uint32 id = 1;
inline bool ArmMotionRequest::has_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ArmMotionRequest::set_has_id() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ArmMotionRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ArmMotionRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ArmMotionRequest::id() const {
  // @@protoc_insertion_point(field_get:naothmessages.ArmMotionRequest.id)
  return id_;
}
inline void ArmMotionRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.ArmMotionRequest.id)
}

// optional .naothmessages.DoubleVector2 lShoulderPosition = 2;
inline bool ArmMotionRequest::has_lshoulderposition() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ArmMotionRequest::set_has_lshoulderposition() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ArmMotionRequest::clear_has_lshoulderposition() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ArmMotionRequest::clear_lshoulderposition() {
  if (lshoulderposition_ != NULL) lshoulderposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_lshoulderposition();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::lshoulderposition() const {
  const ::naothmessages::DoubleVector2* p = lshoulderposition_;
  // @@protoc_insertion_point(field_get:naothmessages.ArmMotionRequest.lShoulderPosition)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_lshoulderposition() {
  set_has_lshoulderposition();
  if (lshoulderposition_ == NULL) {
    lshoulderposition_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.ArmMotionRequest.lShoulderPosition)
  return lshoulderposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_lshoulderposition() {
  // @@protoc_insertion_point(field_release:naothmessages.ArmMotionRequest.lShoulderPosition)
  clear_has_lshoulderposition();
  ::naothmessages::DoubleVector2* temp = lshoulderposition_;
  lshoulderposition_ = NULL;
  return temp;
}
inline void ArmMotionRequest::set_allocated_lshoulderposition(::naothmessages::DoubleVector2* lshoulderposition) {
  delete lshoulderposition_;
  lshoulderposition_ = lshoulderposition;
  if (lshoulderposition) {
    set_has_lshoulderposition();
  } else {
    clear_has_lshoulderposition();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.ArmMotionRequest.lShoulderPosition)
}

// optional .naothmessages.DoubleVector2 lShoulderStiffness = 3;
inline bool ArmMotionRequest::has_lshoulderstiffness() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ArmMotionRequest::set_has_lshoulderstiffness() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ArmMotionRequest::clear_has_lshoulderstiffness() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ArmMotionRequest::clear_lshoulderstiffness() {
  if (lshoulderstiffness_ != NULL) lshoulderstiffness_->::naothmessages::DoubleVector2::Clear();
  clear_has_lshoulderstiffness();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::lshoulderstiffness() const {
  const ::naothmessages::DoubleVector2* p = lshoulderstiffness_;
  // @@protoc_insertion_point(field_get:naothmessages.ArmMotionRequest.lShoulderStiffness)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_lshoulderstiffness() {
  set_has_lshoulderstiffness();
  if (lshoulderstiffness_ == NULL) {
    lshoulderstiffness_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.ArmMotionRequest.lShoulderStiffness)
  return lshoulderstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_lshoulderstiffness() {
  // @@protoc_insertion_point(field_release:naothmessages.ArmMotionRequest.lShoulderStiffness)
  clear_has_lshoulderstiffness();
  ::naothmessages::DoubleVector2* temp = lshoulderstiffness_;
  lshoulderstiffness_ = NULL;
  return temp;
}
inline void ArmMotionRequest::set_allocated_lshoulderstiffness(::naothmessages::DoubleVector2* lshoulderstiffness) {
  delete lshoulderstiffness_;
  lshoulderstiffness_ = lshoulderstiffness;
  if (lshoulderstiffness) {
    set_has_lshoulderstiffness();
  } else {
    clear_has_lshoulderstiffness();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.ArmMotionRequest.lShoulderStiffness)
}

// optional .naothmessages.DoubleVector2 lElbowPosition = 4;
inline bool ArmMotionRequest::has_lelbowposition() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ArmMotionRequest::set_has_lelbowposition() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ArmMotionRequest::clear_has_lelbowposition() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ArmMotionRequest::clear_lelbowposition() {
  if (lelbowposition_ != NULL) lelbowposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_lelbowposition();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::lelbowposition() const {
  const ::naothmessages::DoubleVector2* p = lelbowposition_;
  // @@protoc_insertion_point(field_get:naothmessages.ArmMotionRequest.lElbowPosition)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_lelbowposition() {
  set_has_lelbowposition();
  if (lelbowposition_ == NULL) {
    lelbowposition_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.ArmMotionRequest.lElbowPosition)
  return lelbowposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_lelbowposition() {
  // @@protoc_insertion_point(field_release:naothmessages.ArmMotionRequest.lElbowPosition)
  clear_has_lelbowposition();
  ::naothmessages::DoubleVector2* temp = lelbowposition_;
  lelbowposition_ = NULL;
  return temp;
}
inline void ArmMotionRequest::set_allocated_lelbowposition(::naothmessages::DoubleVector2* lelbowposition) {
  delete lelbowposition_;
  lelbowposition_ = lelbowposition;
  if (lelbowposition) {
    set_has_lelbowposition();
  } else {
    clear_has_lelbowposition();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.ArmMotionRequest.lElbowPosition)
}

// optional .naothmessages.DoubleVector2 lElbowStiffness = 5;
inline bool ArmMotionRequest::has_lelbowstiffness() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ArmMotionRequest::set_has_lelbowstiffness() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ArmMotionRequest::clear_has_lelbowstiffness() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ArmMotionRequest::clear_lelbowstiffness() {
  if (lelbowstiffness_ != NULL) lelbowstiffness_->::naothmessages::DoubleVector2::Clear();
  clear_has_lelbowstiffness();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::lelbowstiffness() const {
  const ::naothmessages::DoubleVector2* p = lelbowstiffness_;
  // @@protoc_insertion_point(field_get:naothmessages.ArmMotionRequest.lElbowStiffness)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_lelbowstiffness() {
  set_has_lelbowstiffness();
  if (lelbowstiffness_ == NULL) {
    lelbowstiffness_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.ArmMotionRequest.lElbowStiffness)
  return lelbowstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_lelbowstiffness() {
  // @@protoc_insertion_point(field_release:naothmessages.ArmMotionRequest.lElbowStiffness)
  clear_has_lelbowstiffness();
  ::naothmessages::DoubleVector2* temp = lelbowstiffness_;
  lelbowstiffness_ = NULL;
  return temp;
}
inline void ArmMotionRequest::set_allocated_lelbowstiffness(::naothmessages::DoubleVector2* lelbowstiffness) {
  delete lelbowstiffness_;
  lelbowstiffness_ = lelbowstiffness;
  if (lelbowstiffness) {
    set_has_lelbowstiffness();
  } else {
    clear_has_lelbowstiffness();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.ArmMotionRequest.lElbowStiffness)
}

// optional .naothmessages.DoubleVector2 rShoulderPosition = 6;
inline bool ArmMotionRequest::has_rshoulderposition() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ArmMotionRequest::set_has_rshoulderposition() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ArmMotionRequest::clear_has_rshoulderposition() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ArmMotionRequest::clear_rshoulderposition() {
  if (rshoulderposition_ != NULL) rshoulderposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_rshoulderposition();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::rshoulderposition() const {
  const ::naothmessages::DoubleVector2* p = rshoulderposition_;
  // @@protoc_insertion_point(field_get:naothmessages.ArmMotionRequest.rShoulderPosition)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_rshoulderposition() {
  set_has_rshoulderposition();
  if (rshoulderposition_ == NULL) {
    rshoulderposition_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.ArmMotionRequest.rShoulderPosition)
  return rshoulderposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_rshoulderposition() {
  // @@protoc_insertion_point(field_release:naothmessages.ArmMotionRequest.rShoulderPosition)
  clear_has_rshoulderposition();
  ::naothmessages::DoubleVector2* temp = rshoulderposition_;
  rshoulderposition_ = NULL;
  return temp;
}
inline void ArmMotionRequest::set_allocated_rshoulderposition(::naothmessages::DoubleVector2* rshoulderposition) {
  delete rshoulderposition_;
  rshoulderposition_ = rshoulderposition;
  if (rshoulderposition) {
    set_has_rshoulderposition();
  } else {
    clear_has_rshoulderposition();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.ArmMotionRequest.rShoulderPosition)
}

// optional .naothmessages.DoubleVector2 rShoulderStiffness = 7;
inline bool ArmMotionRequest::has_rshoulderstiffness() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ArmMotionRequest::set_has_rshoulderstiffness() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ArmMotionRequest::clear_has_rshoulderstiffness() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ArmMotionRequest::clear_rshoulderstiffness() {
  if (rshoulderstiffness_ != NULL) rshoulderstiffness_->::naothmessages::DoubleVector2::Clear();
  clear_has_rshoulderstiffness();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::rshoulderstiffness() const {
  const ::naothmessages::DoubleVector2* p = rshoulderstiffness_;
  // @@protoc_insertion_point(field_get:naothmessages.ArmMotionRequest.rShoulderStiffness)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_rshoulderstiffness() {
  set_has_rshoulderstiffness();
  if (rshoulderstiffness_ == NULL) {
    rshoulderstiffness_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.ArmMotionRequest.rShoulderStiffness)
  return rshoulderstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_rshoulderstiffness() {
  // @@protoc_insertion_point(field_release:naothmessages.ArmMotionRequest.rShoulderStiffness)
  clear_has_rshoulderstiffness();
  ::naothmessages::DoubleVector2* temp = rshoulderstiffness_;
  rshoulderstiffness_ = NULL;
  return temp;
}
inline void ArmMotionRequest::set_allocated_rshoulderstiffness(::naothmessages::DoubleVector2* rshoulderstiffness) {
  delete rshoulderstiffness_;
  rshoulderstiffness_ = rshoulderstiffness;
  if (rshoulderstiffness) {
    set_has_rshoulderstiffness();
  } else {
    clear_has_rshoulderstiffness();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.ArmMotionRequest.rShoulderStiffness)
}

// optional .naothmessages.DoubleVector2 rElbowPosition = 8;
inline bool ArmMotionRequest::has_relbowposition() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ArmMotionRequest::set_has_relbowposition() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ArmMotionRequest::clear_has_relbowposition() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ArmMotionRequest::clear_relbowposition() {
  if (relbowposition_ != NULL) relbowposition_->::naothmessages::DoubleVector2::Clear();
  clear_has_relbowposition();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::relbowposition() const {
  const ::naothmessages::DoubleVector2* p = relbowposition_;
  // @@protoc_insertion_point(field_get:naothmessages.ArmMotionRequest.rElbowPosition)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_relbowposition() {
  set_has_relbowposition();
  if (relbowposition_ == NULL) {
    relbowposition_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.ArmMotionRequest.rElbowPosition)
  return relbowposition_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_relbowposition() {
  // @@protoc_insertion_point(field_release:naothmessages.ArmMotionRequest.rElbowPosition)
  clear_has_relbowposition();
  ::naothmessages::DoubleVector2* temp = relbowposition_;
  relbowposition_ = NULL;
  return temp;
}
inline void ArmMotionRequest::set_allocated_relbowposition(::naothmessages::DoubleVector2* relbowposition) {
  delete relbowposition_;
  relbowposition_ = relbowposition;
  if (relbowposition) {
    set_has_relbowposition();
  } else {
    clear_has_relbowposition();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.ArmMotionRequest.rElbowPosition)
}

// optional .naothmessages.DoubleVector2 rElbowStiffness = 9;
inline bool ArmMotionRequest::has_relbowstiffness() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ArmMotionRequest::set_has_relbowstiffness() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ArmMotionRequest::clear_has_relbowstiffness() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ArmMotionRequest::clear_relbowstiffness() {
  if (relbowstiffness_ != NULL) relbowstiffness_->::naothmessages::DoubleVector2::Clear();
  clear_has_relbowstiffness();
}
inline const ::naothmessages::DoubleVector2& ArmMotionRequest::relbowstiffness() const {
  const ::naothmessages::DoubleVector2* p = relbowstiffness_;
  // @@protoc_insertion_point(field_get:naothmessages.ArmMotionRequest.rElbowStiffness)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::mutable_relbowstiffness() {
  set_has_relbowstiffness();
  if (relbowstiffness_ == NULL) {
    relbowstiffness_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.ArmMotionRequest.rElbowStiffness)
  return relbowstiffness_;
}
inline ::naothmessages::DoubleVector2* ArmMotionRequest::release_relbowstiffness() {
  // @@protoc_insertion_point(field_release:naothmessages.ArmMotionRequest.rElbowStiffness)
  clear_has_relbowstiffness();
  ::naothmessages::DoubleVector2* temp = relbowstiffness_;
  relbowstiffness_ = NULL;
  return temp;
}
inline void ArmMotionRequest::set_allocated_relbowstiffness(::naothmessages::DoubleVector2* relbowstiffness) {
  delete relbowstiffness_;
  relbowstiffness_ = relbowstiffness;
  if (relbowstiffness) {
    set_has_relbowstiffness();
  } else {
    clear_has_relbowstiffness();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.ArmMotionRequest.rElbowStiffness)
}

// -------------------------------------------------------------------

// MotionRequest

// required uint32 id = 1;
inline bool MotionRequest::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MotionRequest::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MotionRequest::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MotionRequest::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 MotionRequest::id() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.id)
  return id_;
}
inline void MotionRequest::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionRequest.id)
}

// required uint32 time = 2;
inline bool MotionRequest::has_time() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MotionRequest::set_has_time() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MotionRequest::clear_has_time() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MotionRequest::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 MotionRequest::time() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.time)
  return time_;
}
inline void MotionRequest::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionRequest.time)
}

// required bool forced = 3;
inline bool MotionRequest::has_forced() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MotionRequest::set_has_forced() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MotionRequest::clear_has_forced() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MotionRequest::clear_forced() {
  forced_ = false;
  clear_has_forced();
}
inline bool MotionRequest::forced() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.forced)
  return forced_;
}
inline void MotionRequest::set_forced(bool value) {
  set_has_forced();
  forced_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionRequest.forced)
}

// optional .naothmessages.WalkRequest walkRequest = 4;
inline bool MotionRequest::has_walkrequest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotionRequest::set_has_walkrequest() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotionRequest::clear_has_walkrequest() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MotionRequest::clear_walkrequest() {
  if (walkrequest_ != NULL) walkrequest_->::naothmessages::WalkRequest::Clear();
  clear_has_walkrequest();
}
inline const ::naothmessages::WalkRequest& MotionRequest::walkrequest() const {
  const ::naothmessages::WalkRequest* p = walkrequest_;
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.walkRequest)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::WalkRequest*>(
      &::naothmessages::_WalkRequest_default_instance_);
}
inline ::naothmessages::WalkRequest* MotionRequest::mutable_walkrequest() {
  set_has_walkrequest();
  if (walkrequest_ == NULL) {
    walkrequest_ = new ::naothmessages::WalkRequest;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MotionRequest.walkRequest)
  return walkrequest_;
}
inline ::naothmessages::WalkRequest* MotionRequest::release_walkrequest() {
  // @@protoc_insertion_point(field_release:naothmessages.MotionRequest.walkRequest)
  clear_has_walkrequest();
  ::naothmessages::WalkRequest* temp = walkrequest_;
  walkrequest_ = NULL;
  return temp;
}
inline void MotionRequest::set_allocated_walkrequest(::naothmessages::WalkRequest* walkrequest) {
  delete walkrequest_;
  walkrequest_ = walkrequest;
  if (walkrequest) {
    set_has_walkrequest();
  } else {
    clear_has_walkrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MotionRequest.walkRequest)
}

// optional bool starndardStand = 5;
inline bool MotionRequest::has_starndardstand() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MotionRequest::set_has_starndardstand() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MotionRequest::clear_has_starndardstand() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MotionRequest::clear_starndardstand() {
  starndardstand_ = false;
  clear_has_starndardstand();
}
inline bool MotionRequest::starndardstand() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.starndardStand)
  return starndardstand_;
}
inline void MotionRequest::set_starndardstand(bool value) {
  set_has_starndardstand();
  starndardstand_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionRequest.starndardStand)
}

// optional .naothmessages.KickRequest kickRequest = 6;
inline bool MotionRequest::has_kickrequest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MotionRequest::set_has_kickrequest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MotionRequest::clear_has_kickrequest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MotionRequest::clear_kickrequest() {
  if (kickrequest_ != NULL) kickrequest_->::naothmessages::KickRequest::Clear();
  clear_has_kickrequest();
}
inline const ::naothmessages::KickRequest& MotionRequest::kickrequest() const {
  const ::naothmessages::KickRequest* p = kickrequest_;
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.kickRequest)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::KickRequest*>(
      &::naothmessages::_KickRequest_default_instance_);
}
inline ::naothmessages::KickRequest* MotionRequest::mutable_kickrequest() {
  set_has_kickrequest();
  if (kickrequest_ == NULL) {
    kickrequest_ = new ::naothmessages::KickRequest;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MotionRequest.kickRequest)
  return kickrequest_;
}
inline ::naothmessages::KickRequest* MotionRequest::release_kickrequest() {
  // @@protoc_insertion_point(field_release:naothmessages.MotionRequest.kickRequest)
  clear_has_kickrequest();
  ::naothmessages::KickRequest* temp = kickrequest_;
  kickrequest_ = NULL;
  return temp;
}
inline void MotionRequest::set_allocated_kickrequest(::naothmessages::KickRequest* kickrequest) {
  delete kickrequest_;
  kickrequest_ = kickrequest;
  if (kickrequest) {
    set_has_kickrequest();
  } else {
    clear_has_kickrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MotionRequest.kickRequest)
}

// optional double standHeight = 7;
inline bool MotionRequest::has_standheight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MotionRequest::set_has_standheight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MotionRequest::clear_has_standheight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MotionRequest::clear_standheight() {
  standheight_ = 0;
  clear_has_standheight();
}
inline double MotionRequest::standheight() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.standHeight)
  return standheight_;
}
inline void MotionRequest::set_standheight(double value) {
  set_has_standheight();
  standheight_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionRequest.standHeight)
}

// optional bool calibrateFootTouchDetector = 8;
inline bool MotionRequest::has_calibratefoottouchdetector() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MotionRequest::set_has_calibratefoottouchdetector() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MotionRequest::clear_has_calibratefoottouchdetector() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MotionRequest::clear_calibratefoottouchdetector() {
  calibratefoottouchdetector_ = false;
  clear_has_calibratefoottouchdetector();
}
inline bool MotionRequest::calibratefoottouchdetector() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.calibrateFootTouchDetector)
  return calibratefoottouchdetector_;
}
inline void MotionRequest::set_calibratefoottouchdetector(bool value) {
  set_has_calibratefoottouchdetector();
  calibratefoottouchdetector_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionRequest.calibrateFootTouchDetector)
}

// optional uint32 cognitionFrameNumber = 9;
inline bool MotionRequest::has_cognitionframenumber() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MotionRequest::set_has_cognitionframenumber() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MotionRequest::clear_has_cognitionframenumber() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MotionRequest::clear_cognitionframenumber() {
  cognitionframenumber_ = 0u;
  clear_has_cognitionframenumber();
}
inline ::google::protobuf::uint32 MotionRequest::cognitionframenumber() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.cognitionFrameNumber)
  return cognitionframenumber_;
}
inline void MotionRequest::set_cognitionframenumber(::google::protobuf::uint32 value) {
  set_has_cognitionframenumber();
  cognitionframenumber_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionRequest.cognitionFrameNumber)
}

// optional .naothmessages.GraspRequest graspRequest = 10;
inline bool MotionRequest::has_grasprequest() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotionRequest::set_has_grasprequest() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotionRequest::clear_has_grasprequest() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MotionRequest::clear_grasprequest() {
  if (grasprequest_ != NULL) grasprequest_->::naothmessages::GraspRequest::Clear();
  clear_has_grasprequest();
}
inline const ::naothmessages::GraspRequest& MotionRequest::grasprequest() const {
  const ::naothmessages::GraspRequest* p = grasprequest_;
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.graspRequest)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::GraspRequest*>(
      &::naothmessages::_GraspRequest_default_instance_);
}
inline ::naothmessages::GraspRequest* MotionRequest::mutable_grasprequest() {
  set_has_grasprequest();
  if (grasprequest_ == NULL) {
    grasprequest_ = new ::naothmessages::GraspRequest;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MotionRequest.graspRequest)
  return grasprequest_;
}
inline ::naothmessages::GraspRequest* MotionRequest::release_grasprequest() {
  // @@protoc_insertion_point(field_release:naothmessages.MotionRequest.graspRequest)
  clear_has_grasprequest();
  ::naothmessages::GraspRequest* temp = grasprequest_;
  grasprequest_ = NULL;
  return temp;
}
inline void MotionRequest::set_allocated_grasprequest(::naothmessages::GraspRequest* grasprequest) {
  delete grasprequest_;
  grasprequest_ = grasprequest;
  if (grasprequest) {
    set_has_grasprequest();
  } else {
    clear_has_grasprequest();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MotionRequest.graspRequest)
}

// optional .naothmessages.ArmMotionRequest armMotionRequest = 11;
inline bool MotionRequest::has_armmotionrequest() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotionRequest::set_has_armmotionrequest() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotionRequest::clear_has_armmotionrequest() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MotionRequest::clear_armmotionrequest() {
  if (armmotionrequest_ != NULL) armmotionrequest_->::naothmessages::ArmMotionRequest::Clear();
  clear_has_armmotionrequest();
}
inline const ::naothmessages::ArmMotionRequest& MotionRequest::armmotionrequest() const {
  const ::naothmessages::ArmMotionRequest* p = armmotionrequest_;
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.armMotionRequest)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::ArmMotionRequest*>(
      &::naothmessages::_ArmMotionRequest_default_instance_);
}
inline ::naothmessages::ArmMotionRequest* MotionRequest::mutable_armmotionrequest() {
  set_has_armmotionrequest();
  if (armmotionrequest_ == NULL) {
    armmotionrequest_ = new ::naothmessages::ArmMotionRequest;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MotionRequest.armMotionRequest)
  return armmotionrequest_;
}
inline ::naothmessages::ArmMotionRequest* MotionRequest::release_armmotionrequest() {
  // @@protoc_insertion_point(field_release:naothmessages.MotionRequest.armMotionRequest)
  clear_has_armmotionrequest();
  ::naothmessages::ArmMotionRequest* temp = armmotionrequest_;
  armmotionrequest_ = NULL;
  return temp;
}
inline void MotionRequest::set_allocated_armmotionrequest(::naothmessages::ArmMotionRequest* armmotionrequest) {
  delete armmotionrequest_;
  armmotionrequest_ = armmotionrequest;
  if (armmotionrequest) {
    set_has_armmotionrequest();
  } else {
    clear_has_armmotionrequest();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MotionRequest.armMotionRequest)
}

// optional bool disable_relaxed_stand = 12;
inline bool MotionRequest::has_disable_relaxed_stand() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MotionRequest::set_has_disable_relaxed_stand() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MotionRequest::clear_has_disable_relaxed_stand() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MotionRequest::clear_disable_relaxed_stand() {
  disable_relaxed_stand_ = false;
  clear_has_disable_relaxed_stand();
}
inline bool MotionRequest::disable_relaxed_stand() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionRequest.disable_relaxed_stand)
  return disable_relaxed_stand_;
}
inline void MotionRequest::set_disable_relaxed_stand(bool value) {
  set_has_disable_relaxed_stand();
  disable_relaxed_stand_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionRequest.disable_relaxed_stand)
}

// -------------------------------------------------------------------

// LinePercept_Intersection

// optional .naothmessages.DoubleVector2 posInImage = 1;
inline bool LinePercept_Intersection::has_posinimage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinePercept_Intersection::set_has_posinimage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinePercept_Intersection::clear_has_posinimage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinePercept_Intersection::clear_posinimage() {
  if (posinimage_ != NULL) posinimage_->::naothmessages::DoubleVector2::Clear();
  clear_has_posinimage();
}
inline const ::naothmessages::DoubleVector2& LinePercept_Intersection::posinimage() const {
  const ::naothmessages::DoubleVector2* p = posinimage_;
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.Intersection.posInImage)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* LinePercept_Intersection::mutable_posinimage() {
  set_has_posinimage();
  if (posinimage_ == NULL) {
    posinimage_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.LinePercept.Intersection.posInImage)
  return posinimage_;
}
inline ::naothmessages::DoubleVector2* LinePercept_Intersection::release_posinimage() {
  // @@protoc_insertion_point(field_release:naothmessages.LinePercept.Intersection.posInImage)
  clear_has_posinimage();
  ::naothmessages::DoubleVector2* temp = posinimage_;
  posinimage_ = NULL;
  return temp;
}
inline void LinePercept_Intersection::set_allocated_posinimage(::naothmessages::DoubleVector2* posinimage) {
  delete posinimage_;
  posinimage_ = posinimage;
  if (posinimage) {
    set_has_posinimage();
  } else {
    clear_has_posinimage();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.LinePercept.Intersection.posInImage)
}

// optional .naothmessages.DoubleVector2 posOnField = 2;
inline bool LinePercept_Intersection::has_posonfield() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinePercept_Intersection::set_has_posonfield() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinePercept_Intersection::clear_has_posonfield() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinePercept_Intersection::clear_posonfield() {
  if (posonfield_ != NULL) posonfield_->::naothmessages::DoubleVector2::Clear();
  clear_has_posonfield();
}
inline const ::naothmessages::DoubleVector2& LinePercept_Intersection::posonfield() const {
  const ::naothmessages::DoubleVector2* p = posonfield_;
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.Intersection.posOnField)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* LinePercept_Intersection::mutable_posonfield() {
  set_has_posonfield();
  if (posonfield_ == NULL) {
    posonfield_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.LinePercept.Intersection.posOnField)
  return posonfield_;
}
inline ::naothmessages::DoubleVector2* LinePercept_Intersection::release_posonfield() {
  // @@protoc_insertion_point(field_release:naothmessages.LinePercept.Intersection.posOnField)
  clear_has_posonfield();
  ::naothmessages::DoubleVector2* temp = posonfield_;
  posonfield_ = NULL;
  return temp;
}
inline void LinePercept_Intersection::set_allocated_posonfield(::naothmessages::DoubleVector2* posonfield) {
  delete posonfield_;
  posonfield_ = posonfield;
  if (posonfield) {
    set_has_posonfield();
  } else {
    clear_has_posonfield();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.LinePercept.Intersection.posOnField)
}

// optional .naothmessages.LinePercept.Intersection.IntersectionType type = 3;
inline bool LinePercept_Intersection::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinePercept_Intersection::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinePercept_Intersection::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinePercept_Intersection::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::naothmessages::LinePercept_Intersection_IntersectionType LinePercept_Intersection::type() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.Intersection.type)
  return static_cast< ::naothmessages::LinePercept_Intersection_IntersectionType >(type_);
}
inline void LinePercept_Intersection::set_type(::naothmessages::LinePercept_Intersection_IntersectionType value) {
  assert(::naothmessages::LinePercept_Intersection_IntersectionType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.Intersection.type)
}

// optional uint32 segmentOneIndex = 6;
inline bool LinePercept_Intersection::has_segmentoneindex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LinePercept_Intersection::set_has_segmentoneindex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LinePercept_Intersection::clear_has_segmentoneindex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LinePercept_Intersection::clear_segmentoneindex() {
  segmentoneindex_ = 0u;
  clear_has_segmentoneindex();
}
inline ::google::protobuf::uint32 LinePercept_Intersection::segmentoneindex() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.Intersection.segmentOneIndex)
  return segmentoneindex_;
}
inline void LinePercept_Intersection::set_segmentoneindex(::google::protobuf::uint32 value) {
  set_has_segmentoneindex();
  segmentoneindex_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.Intersection.segmentOneIndex)
}

// optional uint32 segmentTwoIndex = 7;
inline bool LinePercept_Intersection::has_segmenttwoindex() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LinePercept_Intersection::set_has_segmenttwoindex() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LinePercept_Intersection::clear_has_segmenttwoindex() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LinePercept_Intersection::clear_segmenttwoindex() {
  segmenttwoindex_ = 0u;
  clear_has_segmenttwoindex();
}
inline ::google::protobuf::uint32 LinePercept_Intersection::segmenttwoindex() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.Intersection.segmentTwoIndex)
  return segmenttwoindex_;
}
inline void LinePercept_Intersection::set_segmenttwoindex(::google::protobuf::uint32 value) {
  set_has_segmenttwoindex();
  segmenttwoindex_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.Intersection.segmentTwoIndex)
}

// optional double segmentOneDistance = 8;
inline bool LinePercept_Intersection::has_segmentonedistance() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LinePercept_Intersection::set_has_segmentonedistance() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LinePercept_Intersection::clear_has_segmentonedistance() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LinePercept_Intersection::clear_segmentonedistance() {
  segmentonedistance_ = 0;
  clear_has_segmentonedistance();
}
inline double LinePercept_Intersection::segmentonedistance() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.Intersection.segmentOneDistance)
  return segmentonedistance_;
}
inline void LinePercept_Intersection::set_segmentonedistance(double value) {
  set_has_segmentonedistance();
  segmentonedistance_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.Intersection.segmentOneDistance)
}

// optional double segmentTwoDistance = 9;
inline bool LinePercept_Intersection::has_segmenttwodistance() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LinePercept_Intersection::set_has_segmenttwodistance() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LinePercept_Intersection::clear_has_segmenttwodistance() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LinePercept_Intersection::clear_segmenttwodistance() {
  segmenttwodistance_ = 0;
  clear_has_segmenttwodistance();
}
inline double LinePercept_Intersection::segmenttwodistance() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.Intersection.segmentTwoDistance)
  return segmenttwodistance_;
}
inline void LinePercept_Intersection::set_segmenttwodistance(double value) {
  set_has_segmenttwodistance();
  segmenttwodistance_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.Intersection.segmentTwoDistance)
}

// -------------------------------------------------------------------

// LinePercept_FieldLineSegment

// optional .naothmessages.LineSegment lineInImage = 1;
inline bool LinePercept_FieldLineSegment::has_lineinimage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinePercept_FieldLineSegment::set_has_lineinimage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinePercept_FieldLineSegment::clear_has_lineinimage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinePercept_FieldLineSegment::clear_lineinimage() {
  if (lineinimage_ != NULL) lineinimage_->::naothmessages::LineSegment::Clear();
  clear_has_lineinimage();
}
inline const ::naothmessages::LineSegment& LinePercept_FieldLineSegment::lineinimage() const {
  const ::naothmessages::LineSegment* p = lineinimage_;
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.FieldLineSegment.lineInImage)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::LineSegment*>(
      &::naothmessages::_LineSegment_default_instance_);
}
inline ::naothmessages::LineSegment* LinePercept_FieldLineSegment::mutable_lineinimage() {
  set_has_lineinimage();
  if (lineinimage_ == NULL) {
    lineinimage_ = new ::naothmessages::LineSegment;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.LinePercept.FieldLineSegment.lineInImage)
  return lineinimage_;
}
inline ::naothmessages::LineSegment* LinePercept_FieldLineSegment::release_lineinimage() {
  // @@protoc_insertion_point(field_release:naothmessages.LinePercept.FieldLineSegment.lineInImage)
  clear_has_lineinimage();
  ::naothmessages::LineSegment* temp = lineinimage_;
  lineinimage_ = NULL;
  return temp;
}
inline void LinePercept_FieldLineSegment::set_allocated_lineinimage(::naothmessages::LineSegment* lineinimage) {
  delete lineinimage_;
  lineinimage_ = lineinimage;
  if (lineinimage) {
    set_has_lineinimage();
  } else {
    clear_has_lineinimage();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.LinePercept.FieldLineSegment.lineInImage)
}

// optional .naothmessages.LineSegment lineOnField = 2;
inline bool LinePercept_FieldLineSegment::has_lineonfield() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LinePercept_FieldLineSegment::set_has_lineonfield() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LinePercept_FieldLineSegment::clear_has_lineonfield() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LinePercept_FieldLineSegment::clear_lineonfield() {
  if (lineonfield_ != NULL) lineonfield_->::naothmessages::LineSegment::Clear();
  clear_has_lineonfield();
}
inline const ::naothmessages::LineSegment& LinePercept_FieldLineSegment::lineonfield() const {
  const ::naothmessages::LineSegment* p = lineonfield_;
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.FieldLineSegment.lineOnField)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::LineSegment*>(
      &::naothmessages::_LineSegment_default_instance_);
}
inline ::naothmessages::LineSegment* LinePercept_FieldLineSegment::mutable_lineonfield() {
  set_has_lineonfield();
  if (lineonfield_ == NULL) {
    lineonfield_ = new ::naothmessages::LineSegment;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.LinePercept.FieldLineSegment.lineOnField)
  return lineonfield_;
}
inline ::naothmessages::LineSegment* LinePercept_FieldLineSegment::release_lineonfield() {
  // @@protoc_insertion_point(field_release:naothmessages.LinePercept.FieldLineSegment.lineOnField)
  clear_has_lineonfield();
  ::naothmessages::LineSegment* temp = lineonfield_;
  lineonfield_ = NULL;
  return temp;
}
inline void LinePercept_FieldLineSegment::set_allocated_lineonfield(::naothmessages::LineSegment* lineonfield) {
  delete lineonfield_;
  lineonfield_ = lineonfield;
  if (lineonfield) {
    set_has_lineonfield();
  } else {
    clear_has_lineonfield();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.LinePercept.FieldLineSegment.lineOnField)
}

// optional int32 beginExtendCount = 3;
inline bool LinePercept_FieldLineSegment::has_beginextendcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LinePercept_FieldLineSegment::set_has_beginextendcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LinePercept_FieldLineSegment::clear_has_beginextendcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LinePercept_FieldLineSegment::clear_beginextendcount() {
  beginextendcount_ = 0;
  clear_has_beginextendcount();
}
inline ::google::protobuf::int32 LinePercept_FieldLineSegment::beginextendcount() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.FieldLineSegment.beginExtendCount)
  return beginextendcount_;
}
inline void LinePercept_FieldLineSegment::set_beginextendcount(::google::protobuf::int32 value) {
  set_has_beginextendcount();
  beginextendcount_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.FieldLineSegment.beginExtendCount)
}

// optional int32 endExtendCount = 4;
inline bool LinePercept_FieldLineSegment::has_endextendcount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LinePercept_FieldLineSegment::set_has_endextendcount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LinePercept_FieldLineSegment::clear_has_endextendcount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LinePercept_FieldLineSegment::clear_endextendcount() {
  endextendcount_ = 0;
  clear_has_endextendcount();
}
inline ::google::protobuf::int32 LinePercept_FieldLineSegment::endextendcount() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.FieldLineSegment.endExtendCount)
  return endextendcount_;
}
inline void LinePercept_FieldLineSegment::set_endextendcount(::google::protobuf::int32 value) {
  set_has_endextendcount();
  endextendcount_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.FieldLineSegment.endExtendCount)
}

// optional double thickness = 5;
inline bool LinePercept_FieldLineSegment::has_thickness() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LinePercept_FieldLineSegment::set_has_thickness() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LinePercept_FieldLineSegment::clear_has_thickness() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LinePercept_FieldLineSegment::clear_thickness() {
  thickness_ = 0;
  clear_has_thickness();
}
inline double LinePercept_FieldLineSegment::thickness() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.FieldLineSegment.thickness)
  return thickness_;
}
inline void LinePercept_FieldLineSegment::set_thickness(double value) {
  set_has_thickness();
  thickness_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.FieldLineSegment.thickness)
}

// optional double slope = 6;
inline bool LinePercept_FieldLineSegment::has_slope() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LinePercept_FieldLineSegment::set_has_slope() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LinePercept_FieldLineSegment::clear_has_slope() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LinePercept_FieldLineSegment::clear_slope() {
  slope_ = 0;
  clear_has_slope();
}
inline double LinePercept_FieldLineSegment::slope() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.FieldLineSegment.slope)
  return slope_;
}
inline void LinePercept_FieldLineSegment::set_slope(double value) {
  set_has_slope();
  slope_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.FieldLineSegment.slope)
}

// optional double angle = 7;
inline bool LinePercept_FieldLineSegment::has_angle() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LinePercept_FieldLineSegment::set_has_angle() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LinePercept_FieldLineSegment::clear_has_angle() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LinePercept_FieldLineSegment::clear_angle() {
  angle_ = 0;
  clear_has_angle();
}
inline double LinePercept_FieldLineSegment::angle() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.FieldLineSegment.angle)
  return angle_;
}
inline void LinePercept_FieldLineSegment::set_angle(double value) {
  set_has_angle();
  angle_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.FieldLineSegment.angle)
}

// optional bool valid = 8;
inline bool LinePercept_FieldLineSegment::has_valid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LinePercept_FieldLineSegment::set_has_valid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LinePercept_FieldLineSegment::clear_has_valid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LinePercept_FieldLineSegment::clear_valid() {
  valid_ = false;
  clear_has_valid();
}
inline bool LinePercept_FieldLineSegment::valid() const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.FieldLineSegment.valid)
  return valid_;
}
inline void LinePercept_FieldLineSegment::set_valid(bool value) {
  set_has_valid();
  valid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.LinePercept.FieldLineSegment.valid)
}

// -------------------------------------------------------------------

// LinePercept

// repeated .naothmessages.LinePercept.FieldLineSegment lines = 1;
inline int LinePercept::lines_size() const {
  return lines_.size();
}
inline void LinePercept::clear_lines() {
  lines_.Clear();
}
inline const ::naothmessages::LinePercept_FieldLineSegment& LinePercept::lines(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.lines)
  return lines_.Get(index);
}
inline ::naothmessages::LinePercept_FieldLineSegment* LinePercept::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.LinePercept.lines)
  return lines_.Mutable(index);
}
inline ::naothmessages::LinePercept_FieldLineSegment* LinePercept::add_lines() {
  // @@protoc_insertion_point(field_add:naothmessages.LinePercept.lines)
  return lines_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::LinePercept_FieldLineSegment >*
LinePercept::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.LinePercept.lines)
  return &lines_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::LinePercept_FieldLineSegment >&
LinePercept::lines() const {
  // @@protoc_insertion_point(field_list:naothmessages.LinePercept.lines)
  return lines_;
}

// repeated .naothmessages.LinePercept.Intersection intersections = 2;
inline int LinePercept::intersections_size() const {
  return intersections_.size();
}
inline void LinePercept::clear_intersections() {
  intersections_.Clear();
}
inline const ::naothmessages::LinePercept_Intersection& LinePercept::intersections(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.intersections)
  return intersections_.Get(index);
}
inline ::naothmessages::LinePercept_Intersection* LinePercept::mutable_intersections(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.LinePercept.intersections)
  return intersections_.Mutable(index);
}
inline ::naothmessages::LinePercept_Intersection* LinePercept::add_intersections() {
  // @@protoc_insertion_point(field_add:naothmessages.LinePercept.intersections)
  return intersections_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::LinePercept_Intersection >*
LinePercept::mutable_intersections() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.LinePercept.intersections)
  return &intersections_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::LinePercept_Intersection >&
LinePercept::intersections() const {
  // @@protoc_insertion_point(field_list:naothmessages.LinePercept.intersections)
  return intersections_;
}

// optional .naothmessages.DoubleVector2 middleCircleCenter = 3;
inline bool LinePercept::has_middlecirclecenter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LinePercept::set_has_middlecirclecenter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LinePercept::clear_has_middlecirclecenter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LinePercept::clear_middlecirclecenter() {
  if (middlecirclecenter_ != NULL) middlecirclecenter_->::naothmessages::DoubleVector2::Clear();
  clear_has_middlecirclecenter();
}
inline const ::naothmessages::DoubleVector2& LinePercept::middlecirclecenter() const {
  const ::naothmessages::DoubleVector2* p = middlecirclecenter_;
  // @@protoc_insertion_point(field_get:naothmessages.LinePercept.middleCircleCenter)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* LinePercept::mutable_middlecirclecenter() {
  set_has_middlecirclecenter();
  if (middlecirclecenter_ == NULL) {
    middlecirclecenter_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.LinePercept.middleCircleCenter)
  return middlecirclecenter_;
}
inline ::naothmessages::DoubleVector2* LinePercept::release_middlecirclecenter() {
  // @@protoc_insertion_point(field_release:naothmessages.LinePercept.middleCircleCenter)
  clear_has_middlecirclecenter();
  ::naothmessages::DoubleVector2* temp = middlecirclecenter_;
  middlecirclecenter_ = NULL;
  return temp;
}
inline void LinePercept::set_allocated_middlecirclecenter(::naothmessages::DoubleVector2* middlecirclecenter) {
  delete middlecirclecenter_;
  middlecirclecenter_ = middlecirclecenter;
  if (middlecirclecenter) {
    set_has_middlecirclecenter();
  } else {
    clear_has_middlecirclecenter();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.LinePercept.middleCircleCenter)
}

// -------------------------------------------------------------------

// ShortLinePercept

// repeated .naothmessages.LineSegment fieldLineSegments = 1;
inline int ShortLinePercept::fieldlinesegments_size() const {
  return fieldlinesegments_.size();
}
inline void ShortLinePercept::clear_fieldlinesegments() {
  fieldlinesegments_.Clear();
}
inline const ::naothmessages::LineSegment& ShortLinePercept::fieldlinesegments(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.ShortLinePercept.fieldLineSegments)
  return fieldlinesegments_.Get(index);
}
inline ::naothmessages::LineSegment* ShortLinePercept::mutable_fieldlinesegments(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.ShortLinePercept.fieldLineSegments)
  return fieldlinesegments_.Mutable(index);
}
inline ::naothmessages::LineSegment* ShortLinePercept::add_fieldlinesegments() {
  // @@protoc_insertion_point(field_add:naothmessages.ShortLinePercept.fieldLineSegments)
  return fieldlinesegments_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::LineSegment >*
ShortLinePercept::mutable_fieldlinesegments() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.ShortLinePercept.fieldLineSegments)
  return &fieldlinesegments_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::LineSegment >&
ShortLinePercept::fieldlinesegments() const {
  // @@protoc_insertion_point(field_list:naothmessages.ShortLinePercept.fieldLineSegments)
  return fieldlinesegments_;
}

// -------------------------------------------------------------------

// Polygon

// repeated .naothmessages.IntVector2 points = 1;
inline int Polygon::points_size() const {
  return points_.size();
}
inline void Polygon::clear_points() {
  points_.Clear();
}
inline const ::naothmessages::IntVector2& Polygon::points(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.Polygon.points)
  return points_.Get(index);
}
inline ::naothmessages::IntVector2* Polygon::mutable_points(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.Polygon.points)
  return points_.Mutable(index);
}
inline ::naothmessages::IntVector2* Polygon::add_points() {
  // @@protoc_insertion_point(field_add:naothmessages.Polygon.points)
  return points_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::IntVector2 >*
Polygon::mutable_points() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.Polygon.points)
  return &points_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::IntVector2 >&
Polygon::points() const {
  // @@protoc_insertion_point(field_list:naothmessages.Polygon.points)
  return points_;
}

// -------------------------------------------------------------------

// FieldPercept

// required .naothmessages.Polygon fieldPoly = 1;
inline bool FieldPercept::has_fieldpoly() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FieldPercept::set_has_fieldpoly() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FieldPercept::clear_has_fieldpoly() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FieldPercept::clear_fieldpoly() {
  if (fieldpoly_ != NULL) fieldpoly_->::naothmessages::Polygon::Clear();
  clear_has_fieldpoly();
}
inline const ::naothmessages::Polygon& FieldPercept::fieldpoly() const {
  const ::naothmessages::Polygon* p = fieldpoly_;
  // @@protoc_insertion_point(field_get:naothmessages.FieldPercept.fieldPoly)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Polygon*>(
      &::naothmessages::_Polygon_default_instance_);
}
inline ::naothmessages::Polygon* FieldPercept::mutable_fieldpoly() {
  set_has_fieldpoly();
  if (fieldpoly_ == NULL) {
    fieldpoly_ = new ::naothmessages::Polygon;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.FieldPercept.fieldPoly)
  return fieldpoly_;
}
inline ::naothmessages::Polygon* FieldPercept::release_fieldpoly() {
  // @@protoc_insertion_point(field_release:naothmessages.FieldPercept.fieldPoly)
  clear_has_fieldpoly();
  ::naothmessages::Polygon* temp = fieldpoly_;
  fieldpoly_ = NULL;
  return temp;
}
inline void FieldPercept::set_allocated_fieldpoly(::naothmessages::Polygon* fieldpoly) {
  delete fieldpoly_;
  fieldpoly_ = fieldpoly;
  if (fieldpoly) {
    set_has_fieldpoly();
  } else {
    clear_has_fieldpoly();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.FieldPercept.fieldPoly)
}

// -------------------------------------------------------------------

// RansacLinePercept

// repeated .naothmessages.LineSegment fieldLineSegments = 1;
inline int RansacLinePercept::fieldlinesegments_size() const {
  return fieldlinesegments_.size();
}
inline void RansacLinePercept::clear_fieldlinesegments() {
  fieldlinesegments_.Clear();
}
inline const ::naothmessages::LineSegment& RansacLinePercept::fieldlinesegments(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.RansacLinePercept.fieldLineSegments)
  return fieldlinesegments_.Get(index);
}
inline ::naothmessages::LineSegment* RansacLinePercept::mutable_fieldlinesegments(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.RansacLinePercept.fieldLineSegments)
  return fieldlinesegments_.Mutable(index);
}
inline ::naothmessages::LineSegment* RansacLinePercept::add_fieldlinesegments() {
  // @@protoc_insertion_point(field_add:naothmessages.RansacLinePercept.fieldLineSegments)
  return fieldlinesegments_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::LineSegment >*
RansacLinePercept::mutable_fieldlinesegments() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.RansacLinePercept.fieldLineSegments)
  return &fieldlinesegments_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::LineSegment >&
RansacLinePercept::fieldlinesegments() const {
  // @@protoc_insertion_point(field_list:naothmessages.RansacLinePercept.fieldLineSegments)
  return fieldlinesegments_;
}

// -------------------------------------------------------------------

// RansacCirclePercept2018

// optional bool wasSeen = 1;
inline bool RansacCirclePercept2018::has_wasseen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RansacCirclePercept2018::set_has_wasseen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RansacCirclePercept2018::clear_has_wasseen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RansacCirclePercept2018::clear_wasseen() {
  wasseen_ = false;
  clear_has_wasseen();
}
inline bool RansacCirclePercept2018::wasseen() const {
  // @@protoc_insertion_point(field_get:naothmessages.RansacCirclePercept2018.wasSeen)
  return wasseen_;
}
inline void RansacCirclePercept2018::set_wasseen(bool value) {
  set_has_wasseen();
  wasseen_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.RansacCirclePercept2018.wasSeen)
}

// optional .naothmessages.DoubleVector2 middleCircleCenter = 2;
inline bool RansacCirclePercept2018::has_middlecirclecenter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RansacCirclePercept2018::set_has_middlecirclecenter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RansacCirclePercept2018::clear_has_middlecirclecenter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RansacCirclePercept2018::clear_middlecirclecenter() {
  if (middlecirclecenter_ != NULL) middlecirclecenter_->::naothmessages::DoubleVector2::Clear();
  clear_has_middlecirclecenter();
}
inline const ::naothmessages::DoubleVector2& RansacCirclePercept2018::middlecirclecenter() const {
  const ::naothmessages::DoubleVector2* p = middlecirclecenter_;
  // @@protoc_insertion_point(field_get:naothmessages.RansacCirclePercept2018.middleCircleCenter)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* RansacCirclePercept2018::mutable_middlecirclecenter() {
  set_has_middlecirclecenter();
  if (middlecirclecenter_ == NULL) {
    middlecirclecenter_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.RansacCirclePercept2018.middleCircleCenter)
  return middlecirclecenter_;
}
inline ::naothmessages::DoubleVector2* RansacCirclePercept2018::release_middlecirclecenter() {
  // @@protoc_insertion_point(field_release:naothmessages.RansacCirclePercept2018.middleCircleCenter)
  clear_has_middlecirclecenter();
  ::naothmessages::DoubleVector2* temp = middlecirclecenter_;
  middlecirclecenter_ = NULL;
  return temp;
}
inline void RansacCirclePercept2018::set_allocated_middlecirclecenter(::naothmessages::DoubleVector2* middlecirclecenter) {
  delete middlecirclecenter_;
  middlecirclecenter_ = middlecirclecenter;
  if (middlecirclecenter) {
    set_has_middlecirclecenter();
  } else {
    clear_has_middlecirclecenter();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.RansacCirclePercept2018.middleCircleCenter)
}

// -------------------------------------------------------------------

// ScanLineEndPoint

// required .naothmessages.IntVector2 posInImage = 1;
inline bool ScanLineEndPoint::has_posinimage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScanLineEndPoint::set_has_posinimage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScanLineEndPoint::clear_has_posinimage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScanLineEndPoint::clear_posinimage() {
  if (posinimage_ != NULL) posinimage_->::naothmessages::IntVector2::Clear();
  clear_has_posinimage();
}
inline const ::naothmessages::IntVector2& ScanLineEndPoint::posinimage() const {
  const ::naothmessages::IntVector2* p = posinimage_;
  // @@protoc_insertion_point(field_get:naothmessages.ScanLineEndPoint.posInImage)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::IntVector2*>(
      &::naothmessages::_IntVector2_default_instance_);
}
inline ::naothmessages::IntVector2* ScanLineEndPoint::mutable_posinimage() {
  set_has_posinimage();
  if (posinimage_ == NULL) {
    posinimage_ = new ::naothmessages::IntVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.ScanLineEndPoint.posInImage)
  return posinimage_;
}
inline ::naothmessages::IntVector2* ScanLineEndPoint::release_posinimage() {
  // @@protoc_insertion_point(field_release:naothmessages.ScanLineEndPoint.posInImage)
  clear_has_posinimage();
  ::naothmessages::IntVector2* temp = posinimage_;
  posinimage_ = NULL;
  return temp;
}
inline void ScanLineEndPoint::set_allocated_posinimage(::naothmessages::IntVector2* posinimage) {
  delete posinimage_;
  posinimage_ = posinimage;
  if (posinimage) {
    set_has_posinimage();
  } else {
    clear_has_posinimage();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.ScanLineEndPoint.posInImage)
}

// required .naothmessages.DoubleVector2 posOnField = 2;
inline bool ScanLineEndPoint::has_posonfield() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScanLineEndPoint::set_has_posonfield() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScanLineEndPoint::clear_has_posonfield() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScanLineEndPoint::clear_posonfield() {
  if (posonfield_ != NULL) posonfield_->::naothmessages::DoubleVector2::Clear();
  clear_has_posonfield();
}
inline const ::naothmessages::DoubleVector2& ScanLineEndPoint::posonfield() const {
  const ::naothmessages::DoubleVector2* p = posonfield_;
  // @@protoc_insertion_point(field_get:naothmessages.ScanLineEndPoint.posOnField)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* ScanLineEndPoint::mutable_posonfield() {
  set_has_posonfield();
  if (posonfield_ == NULL) {
    posonfield_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.ScanLineEndPoint.posOnField)
  return posonfield_;
}
inline ::naothmessages::DoubleVector2* ScanLineEndPoint::release_posonfield() {
  // @@protoc_insertion_point(field_release:naothmessages.ScanLineEndPoint.posOnField)
  clear_has_posonfield();
  ::naothmessages::DoubleVector2* temp = posonfield_;
  posonfield_ = NULL;
  return temp;
}
inline void ScanLineEndPoint::set_allocated_posonfield(::naothmessages::DoubleVector2* posonfield) {
  delete posonfield_;
  posonfield_ = posonfield;
  if (posonfield) {
    set_has_posonfield();
  } else {
    clear_has_posonfield();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.ScanLineEndPoint.posOnField)
}

// required .naothmessages.Color color = 3;
inline bool ScanLineEndPoint::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScanLineEndPoint::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScanLineEndPoint::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScanLineEndPoint::clear_color() {
  color_ = 0;
  clear_has_color();
}
inline ::naothmessages::Color ScanLineEndPoint::color() const {
  // @@protoc_insertion_point(field_get:naothmessages.ScanLineEndPoint.color)
  return static_cast< ::naothmessages::Color >(color_);
}
inline void ScanLineEndPoint::set_color(::naothmessages::Color value) {
  assert(::naothmessages::Color_IsValid(value));
  set_has_color();
  color_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.ScanLineEndPoint.color)
}

// required uint32 ScanLineID = 4;
inline bool ScanLineEndPoint::has_scanlineid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScanLineEndPoint::set_has_scanlineid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScanLineEndPoint::clear_has_scanlineid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScanLineEndPoint::clear_scanlineid() {
  scanlineid_ = 0u;
  clear_has_scanlineid();
}
inline ::google::protobuf::uint32 ScanLineEndPoint::scanlineid() const {
  // @@protoc_insertion_point(field_get:naothmessages.ScanLineEndPoint.ScanLineID)
  return scanlineid_;
}
inline void ScanLineEndPoint::set_scanlineid(::google::protobuf::uint32 value) {
  set_has_scanlineid();
  scanlineid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.ScanLineEndPoint.ScanLineID)
}

// -------------------------------------------------------------------

// DoubleEdgel

// required .naothmessages.DoubleVector2 point = 1;
inline bool DoubleEdgel::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleEdgel::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DoubleEdgel::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DoubleEdgel::clear_point() {
  if (point_ != NULL) point_->::naothmessages::DoubleVector2::Clear();
  clear_has_point();
}
inline const ::naothmessages::DoubleVector2& DoubleEdgel::point() const {
  const ::naothmessages::DoubleVector2* p = point_;
  // @@protoc_insertion_point(field_get:naothmessages.DoubleEdgel.point)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* DoubleEdgel::mutable_point() {
  set_has_point();
  if (point_ == NULL) {
    point_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.DoubleEdgel.point)
  return point_;
}
inline ::naothmessages::DoubleVector2* DoubleEdgel::release_point() {
  // @@protoc_insertion_point(field_release:naothmessages.DoubleEdgel.point)
  clear_has_point();
  ::naothmessages::DoubleVector2* temp = point_;
  point_ = NULL;
  return temp;
}
inline void DoubleEdgel::set_allocated_point(::naothmessages::DoubleVector2* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.DoubleEdgel.point)
}

// required .naothmessages.DoubleVector2 direction = 2;
inline bool DoubleEdgel::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DoubleEdgel::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DoubleEdgel::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DoubleEdgel::clear_direction() {
  if (direction_ != NULL) direction_->::naothmessages::DoubleVector2::Clear();
  clear_has_direction();
}
inline const ::naothmessages::DoubleVector2& DoubleEdgel::direction() const {
  const ::naothmessages::DoubleVector2* p = direction_;
  // @@protoc_insertion_point(field_get:naothmessages.DoubleEdgel.direction)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* DoubleEdgel::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.DoubleEdgel.direction)
  return direction_;
}
inline ::naothmessages::DoubleVector2* DoubleEdgel::release_direction() {
  // @@protoc_insertion_point(field_release:naothmessages.DoubleEdgel.direction)
  clear_has_direction();
  ::naothmessages::DoubleVector2* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void DoubleEdgel::set_allocated_direction(::naothmessages::DoubleVector2* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.DoubleEdgel.direction)
}

// -------------------------------------------------------------------

// Edgel

// required .naothmessages.IntVector2 point = 1;
inline bool Edgel::has_point() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Edgel::set_has_point() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Edgel::clear_has_point() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Edgel::clear_point() {
  if (point_ != NULL) point_->::naothmessages::IntVector2::Clear();
  clear_has_point();
}
inline const ::naothmessages::IntVector2& Edgel::point() const {
  const ::naothmessages::IntVector2* p = point_;
  // @@protoc_insertion_point(field_get:naothmessages.Edgel.point)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::IntVector2*>(
      &::naothmessages::_IntVector2_default_instance_);
}
inline ::naothmessages::IntVector2* Edgel::mutable_point() {
  set_has_point();
  if (point_ == NULL) {
    point_ = new ::naothmessages::IntVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.Edgel.point)
  return point_;
}
inline ::naothmessages::IntVector2* Edgel::release_point() {
  // @@protoc_insertion_point(field_release:naothmessages.Edgel.point)
  clear_has_point();
  ::naothmessages::IntVector2* temp = point_;
  point_ = NULL;
  return temp;
}
inline void Edgel::set_allocated_point(::naothmessages::IntVector2* point) {
  delete point_;
  point_ = point;
  if (point) {
    set_has_point();
  } else {
    clear_has_point();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.Edgel.point)
}

// required .naothmessages.DoubleVector2 direction = 2;
inline bool Edgel::has_direction() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Edgel::set_has_direction() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Edgel::clear_has_direction() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Edgel::clear_direction() {
  if (direction_ != NULL) direction_->::naothmessages::DoubleVector2::Clear();
  clear_has_direction();
}
inline const ::naothmessages::DoubleVector2& Edgel::direction() const {
  const ::naothmessages::DoubleVector2* p = direction_;
  // @@protoc_insertion_point(field_get:naothmessages.Edgel.direction)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* Edgel::mutable_direction() {
  set_has_direction();
  if (direction_ == NULL) {
    direction_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.Edgel.direction)
  return direction_;
}
inline ::naothmessages::DoubleVector2* Edgel::release_direction() {
  // @@protoc_insertion_point(field_release:naothmessages.Edgel.direction)
  clear_has_direction();
  ::naothmessages::DoubleVector2* temp = direction_;
  direction_ = NULL;
  return temp;
}
inline void Edgel::set_allocated_direction(::naothmessages::DoubleVector2* direction) {
  delete direction_;
  direction_ = direction;
  if (direction) {
    set_has_direction();
  } else {
    clear_has_direction();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.Edgel.direction)
}

// -------------------------------------------------------------------

// EdgelPair

// required int32 begin = 1;
inline bool EdgelPair::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EdgelPair::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EdgelPair::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EdgelPair::clear_begin() {
  begin_ = 0;
  clear_has_begin();
}
inline ::google::protobuf::int32 EdgelPair::begin() const {
  // @@protoc_insertion_point(field_get:naothmessages.EdgelPair.begin)
  return begin_;
}
inline void EdgelPair::set_begin(::google::protobuf::int32 value) {
  set_has_begin();
  begin_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.EdgelPair.begin)
}

// required int32 end = 2;
inline bool EdgelPair::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EdgelPair::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EdgelPair::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EdgelPair::clear_end() {
  end_ = 0;
  clear_has_end();
}
inline ::google::protobuf::int32 EdgelPair::end() const {
  // @@protoc_insertion_point(field_get:naothmessages.EdgelPair.end)
  return end_;
}
inline void EdgelPair::set_end(::google::protobuf::int32 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.EdgelPair.end)
}

// required int32 id = 3;
inline bool EdgelPair::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EdgelPair::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EdgelPair::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EdgelPair::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 EdgelPair::id() const {
  // @@protoc_insertion_point(field_get:naothmessages.EdgelPair.id)
  return id_;
}
inline void EdgelPair::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.EdgelPair.id)
}

// optional bool adaptive = 4;
inline bool EdgelPair::has_adaptive() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EdgelPair::set_has_adaptive() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EdgelPair::clear_has_adaptive() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EdgelPair::clear_adaptive() {
  adaptive_ = false;
  clear_has_adaptive();
}
inline bool EdgelPair::adaptive() const {
  // @@protoc_insertion_point(field_get:naothmessages.EdgelPair.adaptive)
  return adaptive_;
}
inline void EdgelPair::set_adaptive(bool value) {
  set_has_adaptive();
  adaptive_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.EdgelPair.adaptive)
}

// -------------------------------------------------------------------

// ScanLineEdgelPercept

// repeated .naothmessages.Edgel edgels = 1;
inline int ScanLineEdgelPercept::edgels_size() const {
  return edgels_.size();
}
inline void ScanLineEdgelPercept::clear_edgels() {
  edgels_.Clear();
}
inline const ::naothmessages::Edgel& ScanLineEdgelPercept::edgels(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.ScanLineEdgelPercept.edgels)
  return edgels_.Get(index);
}
inline ::naothmessages::Edgel* ScanLineEdgelPercept::mutable_edgels(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.ScanLineEdgelPercept.edgels)
  return edgels_.Mutable(index);
}
inline ::naothmessages::Edgel* ScanLineEdgelPercept::add_edgels() {
  // @@protoc_insertion_point(field_add:naothmessages.ScanLineEdgelPercept.edgels)
  return edgels_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >*
ScanLineEdgelPercept::mutable_edgels() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.ScanLineEdgelPercept.edgels)
  return &edgels_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >&
ScanLineEdgelPercept::edgels() const {
  // @@protoc_insertion_point(field_list:naothmessages.ScanLineEdgelPercept.edgels)
  return edgels_;
}

// repeated .naothmessages.EdgelPair pairs = 3;
inline int ScanLineEdgelPercept::pairs_size() const {
  return pairs_.size();
}
inline void ScanLineEdgelPercept::clear_pairs() {
  pairs_.Clear();
}
inline const ::naothmessages::EdgelPair& ScanLineEdgelPercept::pairs(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.ScanLineEdgelPercept.pairs)
  return pairs_.Get(index);
}
inline ::naothmessages::EdgelPair* ScanLineEdgelPercept::mutable_pairs(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.ScanLineEdgelPercept.pairs)
  return pairs_.Mutable(index);
}
inline ::naothmessages::EdgelPair* ScanLineEdgelPercept::add_pairs() {
  // @@protoc_insertion_point(field_add:naothmessages.ScanLineEdgelPercept.pairs)
  return pairs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::EdgelPair >*
ScanLineEdgelPercept::mutable_pairs() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.ScanLineEdgelPercept.pairs)
  return &pairs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::EdgelPair >&
ScanLineEdgelPercept::pairs() const {
  // @@protoc_insertion_point(field_list:naothmessages.ScanLineEdgelPercept.pairs)
  return pairs_;
}

// repeated .naothmessages.ScanLineEndPoint endPoints = 2;
inline int ScanLineEdgelPercept::endpoints_size() const {
  return endpoints_.size();
}
inline void ScanLineEdgelPercept::clear_endpoints() {
  endpoints_.Clear();
}
inline const ::naothmessages::ScanLineEndPoint& ScanLineEdgelPercept::endpoints(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.ScanLineEdgelPercept.endPoints)
  return endpoints_.Get(index);
}
inline ::naothmessages::ScanLineEndPoint* ScanLineEdgelPercept::mutable_endpoints(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.ScanLineEdgelPercept.endPoints)
  return endpoints_.Mutable(index);
}
inline ::naothmessages::ScanLineEndPoint* ScanLineEdgelPercept::add_endpoints() {
  // @@protoc_insertion_point(field_add:naothmessages.ScanLineEdgelPercept.endPoints)
  return endpoints_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::ScanLineEndPoint >*
ScanLineEdgelPercept::mutable_endpoints() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.ScanLineEdgelPercept.endPoints)
  return &endpoints_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::ScanLineEndPoint >&
ScanLineEdgelPercept::endpoints() const {
  // @@protoc_insertion_point(field_list:naothmessages.ScanLineEdgelPercept.endPoints)
  return endpoints_;
}

// -------------------------------------------------------------------

// LineGraphPercept

// repeated .naothmessages.Edgel edgelsOnField = 1;
inline int LineGraphPercept::edgelsonfield_size() const {
  return edgelsonfield_.size();
}
inline void LineGraphPercept::clear_edgelsonfield() {
  edgelsonfield_.Clear();
}
inline const ::naothmessages::Edgel& LineGraphPercept::edgelsonfield(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.LineGraphPercept.edgelsOnField)
  return edgelsonfield_.Get(index);
}
inline ::naothmessages::Edgel* LineGraphPercept::mutable_edgelsonfield(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.LineGraphPercept.edgelsOnField)
  return edgelsonfield_.Mutable(index);
}
inline ::naothmessages::Edgel* LineGraphPercept::add_edgelsonfield() {
  // @@protoc_insertion_point(field_add:naothmessages.LineGraphPercept.edgelsOnField)
  return edgelsonfield_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >*
LineGraphPercept::mutable_edgelsonfield() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.LineGraphPercept.edgelsOnField)
  return &edgelsonfield_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::Edgel >&
LineGraphPercept::edgelsonfield() const {
  // @@protoc_insertion_point(field_list:naothmessages.LineGraphPercept.edgelsOnField)
  return edgelsonfield_;
}

// repeated .naothmessages.DoubleEdgel edgelsInImageTop = 2;
inline int LineGraphPercept::edgelsinimagetop_size() const {
  return edgelsinimagetop_.size();
}
inline void LineGraphPercept::clear_edgelsinimagetop() {
  edgelsinimagetop_.Clear();
}
inline const ::naothmessages::DoubleEdgel& LineGraphPercept::edgelsinimagetop(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.LineGraphPercept.edgelsInImageTop)
  return edgelsinimagetop_.Get(index);
}
inline ::naothmessages::DoubleEdgel* LineGraphPercept::mutable_edgelsinimagetop(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.LineGraphPercept.edgelsInImageTop)
  return edgelsinimagetop_.Mutable(index);
}
inline ::naothmessages::DoubleEdgel* LineGraphPercept::add_edgelsinimagetop() {
  // @@protoc_insertion_point(field_add:naothmessages.LineGraphPercept.edgelsInImageTop)
  return edgelsinimagetop_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleEdgel >*
LineGraphPercept::mutable_edgelsinimagetop() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.LineGraphPercept.edgelsInImageTop)
  return &edgelsinimagetop_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleEdgel >&
LineGraphPercept::edgelsinimagetop() const {
  // @@protoc_insertion_point(field_list:naothmessages.LineGraphPercept.edgelsInImageTop)
  return edgelsinimagetop_;
}

// repeated .naothmessages.DoubleEdgel edgelsInImage = 3;
inline int LineGraphPercept::edgelsinimage_size() const {
  return edgelsinimage_.size();
}
inline void LineGraphPercept::clear_edgelsinimage() {
  edgelsinimage_.Clear();
}
inline const ::naothmessages::DoubleEdgel& LineGraphPercept::edgelsinimage(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.LineGraphPercept.edgelsInImage)
  return edgelsinimage_.Get(index);
}
inline ::naothmessages::DoubleEdgel* LineGraphPercept::mutable_edgelsinimage(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.LineGraphPercept.edgelsInImage)
  return edgelsinimage_.Mutable(index);
}
inline ::naothmessages::DoubleEdgel* LineGraphPercept::add_edgelsinimage() {
  // @@protoc_insertion_point(field_add:naothmessages.LineGraphPercept.edgelsInImage)
  return edgelsinimage_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleEdgel >*
LineGraphPercept::mutable_edgelsinimage() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.LineGraphPercept.edgelsInImage)
  return &edgelsinimage_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleEdgel >&
LineGraphPercept::edgelsinimage() const {
  // @@protoc_insertion_point(field_list:naothmessages.LineGraphPercept.edgelsInImage)
  return edgelsinimage_;
}

// -------------------------------------------------------------------

// StepControlStatus

// required uint32 stepID = 1;
inline bool StepControlStatus::has_stepid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StepControlStatus::set_has_stepid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StepControlStatus::clear_has_stepid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StepControlStatus::clear_stepid() {
  stepid_ = 0u;
  clear_has_stepid();
}
inline ::google::protobuf::uint32 StepControlStatus::stepid() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlStatus.stepID)
  return stepid_;
}
inline void StepControlStatus::set_stepid(::google::protobuf::uint32 value) {
  set_has_stepid();
  stepid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlStatus.stepID)
}

// required uint32 moveableFoot = 2;
inline bool StepControlStatus::has_moveablefoot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StepControlStatus::set_has_moveablefoot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StepControlStatus::clear_has_moveablefoot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StepControlStatus::clear_moveablefoot() {
  moveablefoot_ = 0u;
  clear_has_moveablefoot();
}
inline ::google::protobuf::uint32 StepControlStatus::moveablefoot() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlStatus.moveableFoot)
  return moveablefoot_;
}
inline void StepControlStatus::set_moveablefoot(::google::protobuf::uint32 value) {
  set_has_moveablefoot();
  moveablefoot_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlStatus.moveableFoot)
}

// required uint32 stepRequestID = 3;
inline bool StepControlStatus::has_steprequestid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StepControlStatus::set_has_steprequestid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StepControlStatus::clear_has_steprequestid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StepControlStatus::clear_steprequestid() {
  steprequestid_ = 0u;
  clear_has_steprequestid();
}
inline ::google::protobuf::uint32 StepControlStatus::steprequestid() const {
  // @@protoc_insertion_point(field_get:naothmessages.StepControlStatus.stepRequestID)
  return steprequestid_;
}
inline void StepControlStatus::set_steprequestid(::google::protobuf::uint32 value) {
  set_has_steprequestid();
  steprequestid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.StepControlStatus.stepRequestID)
}

// -------------------------------------------------------------------

// MotionStatus

// required uint32 time = 1;
inline bool MotionStatus::has_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MotionStatus::set_has_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MotionStatus::clear_has_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MotionStatus::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 MotionStatus::time() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.time)
  return time_;
}
inline void MotionStatus::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionStatus.time)
}

// required uint32 lastMotion = 2;
inline bool MotionStatus::has_lastmotion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MotionStatus::set_has_lastmotion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MotionStatus::clear_has_lastmotion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MotionStatus::clear_lastmotion() {
  lastmotion_ = 0u;
  clear_has_lastmotion();
}
inline ::google::protobuf::uint32 MotionStatus::lastmotion() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.lastMotion)
  return lastmotion_;
}
inline void MotionStatus::set_lastmotion(::google::protobuf::uint32 value) {
  set_has_lastmotion();
  lastmotion_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionStatus.lastMotion)
}

// required uint32 currentMotion = 3;
inline bool MotionStatus::has_currentmotion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MotionStatus::set_has_currentmotion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MotionStatus::clear_has_currentmotion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MotionStatus::clear_currentmotion() {
  currentmotion_ = 0u;
  clear_has_currentmotion();
}
inline ::google::protobuf::uint32 MotionStatus::currentmotion() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.currentMotion)
  return currentmotion_;
}
inline void MotionStatus::set_currentmotion(::google::protobuf::uint32 value) {
  set_has_currentmotion();
  currentmotion_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionStatus.currentMotion)
}

// required uint32 headMotion = 4;
inline bool MotionStatus::has_headmotion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MotionStatus::set_has_headmotion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MotionStatus::clear_has_headmotion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MotionStatus::clear_headmotion() {
  headmotion_ = 0u;
  clear_has_headmotion();
}
inline ::google::protobuf::uint32 MotionStatus::headmotion() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.headMotion)
  return headmotion_;
}
inline void MotionStatus::set_headmotion(::google::protobuf::uint32 value) {
  set_has_headmotion();
  headmotion_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionStatus.headMotion)
}

// required uint32 currentMotionState = 5;
inline bool MotionStatus::has_currentmotionstate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MotionStatus::set_has_currentmotionstate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MotionStatus::clear_has_currentmotionstate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MotionStatus::clear_currentmotionstate() {
  currentmotionstate_ = 0u;
  clear_has_currentmotionstate();
}
inline ::google::protobuf::uint32 MotionStatus::currentmotionstate() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.currentMotionState)
  return currentmotionstate_;
}
inline void MotionStatus::set_currentmotionstate(::google::protobuf::uint32 value) {
  set_has_currentmotionstate();
  currentmotionstate_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionStatus.currentMotionState)
}

// required .naothmessages.Pose2D plannedMotionLeftFoot = 6;
inline bool MotionStatus::has_plannedmotionleftfoot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MotionStatus::set_has_plannedmotionleftfoot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MotionStatus::clear_has_plannedmotionleftfoot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MotionStatus::clear_plannedmotionleftfoot() {
  if (plannedmotionleftfoot_ != NULL) plannedmotionleftfoot_->::naothmessages::Pose2D::Clear();
  clear_has_plannedmotionleftfoot();
}
inline const ::naothmessages::Pose2D& MotionStatus::plannedmotionleftfoot() const {
  const ::naothmessages::Pose2D* p = plannedmotionleftfoot_;
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.plannedMotionLeftFoot)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose2D*>(
      &::naothmessages::_Pose2D_default_instance_);
}
inline ::naothmessages::Pose2D* MotionStatus::mutable_plannedmotionleftfoot() {
  set_has_plannedmotionleftfoot();
  if (plannedmotionleftfoot_ == NULL) {
    plannedmotionleftfoot_ = new ::naothmessages::Pose2D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MotionStatus.plannedMotionLeftFoot)
  return plannedmotionleftfoot_;
}
inline ::naothmessages::Pose2D* MotionStatus::release_plannedmotionleftfoot() {
  // @@protoc_insertion_point(field_release:naothmessages.MotionStatus.plannedMotionLeftFoot)
  clear_has_plannedmotionleftfoot();
  ::naothmessages::Pose2D* temp = plannedmotionleftfoot_;
  plannedmotionleftfoot_ = NULL;
  return temp;
}
inline void MotionStatus::set_allocated_plannedmotionleftfoot(::naothmessages::Pose2D* plannedmotionleftfoot) {
  delete plannedmotionleftfoot_;
  plannedmotionleftfoot_ = plannedmotionleftfoot;
  if (plannedmotionleftfoot) {
    set_has_plannedmotionleftfoot();
  } else {
    clear_has_plannedmotionleftfoot();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MotionStatus.plannedMotionLeftFoot)
}

// required .naothmessages.Pose2D plannedMotionRightFoot = 7;
inline bool MotionStatus::has_plannedmotionrightfoot() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MotionStatus::set_has_plannedmotionrightfoot() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MotionStatus::clear_has_plannedmotionrightfoot() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MotionStatus::clear_plannedmotionrightfoot() {
  if (plannedmotionrightfoot_ != NULL) plannedmotionrightfoot_->::naothmessages::Pose2D::Clear();
  clear_has_plannedmotionrightfoot();
}
inline const ::naothmessages::Pose2D& MotionStatus::plannedmotionrightfoot() const {
  const ::naothmessages::Pose2D* p = plannedmotionrightfoot_;
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.plannedMotionRightFoot)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose2D*>(
      &::naothmessages::_Pose2D_default_instance_);
}
inline ::naothmessages::Pose2D* MotionStatus::mutable_plannedmotionrightfoot() {
  set_has_plannedmotionrightfoot();
  if (plannedmotionrightfoot_ == NULL) {
    plannedmotionrightfoot_ = new ::naothmessages::Pose2D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MotionStatus.plannedMotionRightFoot)
  return plannedmotionrightfoot_;
}
inline ::naothmessages::Pose2D* MotionStatus::release_plannedmotionrightfoot() {
  // @@protoc_insertion_point(field_release:naothmessages.MotionStatus.plannedMotionRightFoot)
  clear_has_plannedmotionrightfoot();
  ::naothmessages::Pose2D* temp = plannedmotionrightfoot_;
  plannedmotionrightfoot_ = NULL;
  return temp;
}
inline void MotionStatus::set_allocated_plannedmotionrightfoot(::naothmessages::Pose2D* plannedmotionrightfoot) {
  delete plannedmotionrightfoot_;
  plannedmotionrightfoot_ = plannedmotionrightfoot;
  if (plannedmotionrightfoot) {
    set_has_plannedmotionrightfoot();
  } else {
    clear_has_plannedmotionrightfoot();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MotionStatus.plannedMotionRightFoot)
}

// required .naothmessages.Pose2D plannedMotionHip = 8;
inline bool MotionStatus::has_plannedmotionhip() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MotionStatus::set_has_plannedmotionhip() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MotionStatus::clear_has_plannedmotionhip() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MotionStatus::clear_plannedmotionhip() {
  if (plannedmotionhip_ != NULL) plannedmotionhip_->::naothmessages::Pose2D::Clear();
  clear_has_plannedmotionhip();
}
inline const ::naothmessages::Pose2D& MotionStatus::plannedmotionhip() const {
  const ::naothmessages::Pose2D* p = plannedmotionhip_;
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.plannedMotionHip)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose2D*>(
      &::naothmessages::_Pose2D_default_instance_);
}
inline ::naothmessages::Pose2D* MotionStatus::mutable_plannedmotionhip() {
  set_has_plannedmotionhip();
  if (plannedmotionhip_ == NULL) {
    plannedmotionhip_ = new ::naothmessages::Pose2D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MotionStatus.plannedMotionHip)
  return plannedmotionhip_;
}
inline ::naothmessages::Pose2D* MotionStatus::release_plannedmotionhip() {
  // @@protoc_insertion_point(field_release:naothmessages.MotionStatus.plannedMotionHip)
  clear_has_plannedmotionhip();
  ::naothmessages::Pose2D* temp = plannedmotionhip_;
  plannedmotionhip_ = NULL;
  return temp;
}
inline void MotionStatus::set_allocated_plannedmotionhip(::naothmessages::Pose2D* plannedmotionhip) {
  delete plannedmotionhip_;
  plannedmotionhip_ = plannedmotionhip;
  if (plannedmotionhip) {
    set_has_plannedmotionhip();
  } else {
    clear_has_plannedmotionhip();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MotionStatus.plannedMotionHip)
}

// optional .naothmessages.StepControlStatus stepControlStatus = 9;
inline bool MotionStatus::has_stepcontrolstatus() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MotionStatus::set_has_stepcontrolstatus() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MotionStatus::clear_has_stepcontrolstatus() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MotionStatus::clear_stepcontrolstatus() {
  if (stepcontrolstatus_ != NULL) stepcontrolstatus_->::naothmessages::StepControlStatus::Clear();
  clear_has_stepcontrolstatus();
}
inline const ::naothmessages::StepControlStatus& MotionStatus::stepcontrolstatus() const {
  const ::naothmessages::StepControlStatus* p = stepcontrolstatus_;
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.stepControlStatus)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::StepControlStatus*>(
      &::naothmessages::_StepControlStatus_default_instance_);
}
inline ::naothmessages::StepControlStatus* MotionStatus::mutable_stepcontrolstatus() {
  set_has_stepcontrolstatus();
  if (stepcontrolstatus_ == NULL) {
    stepcontrolstatus_ = new ::naothmessages::StepControlStatus;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.MotionStatus.stepControlStatus)
  return stepcontrolstatus_;
}
inline ::naothmessages::StepControlStatus* MotionStatus::release_stepcontrolstatus() {
  // @@protoc_insertion_point(field_release:naothmessages.MotionStatus.stepControlStatus)
  clear_has_stepcontrolstatus();
  ::naothmessages::StepControlStatus* temp = stepcontrolstatus_;
  stepcontrolstatus_ = NULL;
  return temp;
}
inline void MotionStatus::set_allocated_stepcontrolstatus(::naothmessages::StepControlStatus* stepcontrolstatus) {
  delete stepcontrolstatus_;
  stepcontrolstatus_ = stepcontrolstatus;
  if (stepcontrolstatus) {
    set_has_stepcontrolstatus();
  } else {
    clear_has_stepcontrolstatus();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.MotionStatus.stepControlStatus)
}

// optional bool target_reached = 10;
inline bool MotionStatus::has_target_reached() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MotionStatus::set_has_target_reached() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MotionStatus::clear_has_target_reached() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MotionStatus::clear_target_reached() {
  target_reached_ = false;
  clear_has_target_reached();
}
inline bool MotionStatus::target_reached() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.target_reached)
  return target_reached_;
}
inline void MotionStatus::set_target_reached(bool value) {
  set_has_target_reached();
  target_reached_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionStatus.target_reached)
}

// optional bool head_target_reached = 11;
inline bool MotionStatus::has_head_target_reached() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MotionStatus::set_has_head_target_reached() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MotionStatus::clear_has_head_target_reached() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MotionStatus::clear_head_target_reached() {
  head_target_reached_ = false;
  clear_has_head_target_reached();
}
inline bool MotionStatus::head_target_reached() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.head_target_reached)
  return head_target_reached_;
}
inline void MotionStatus::set_head_target_reached(bool value) {
  set_has_head_target_reached();
  head_target_reached_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionStatus.head_target_reached)
}

// optional bool head_got_stuck = 12;
inline bool MotionStatus::has_head_got_stuck() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MotionStatus::set_has_head_got_stuck() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MotionStatus::clear_has_head_got_stuck() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MotionStatus::clear_head_got_stuck() {
  head_got_stuck_ = false;
  clear_has_head_got_stuck();
}
inline bool MotionStatus::head_got_stuck() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.head_got_stuck)
  return head_got_stuck_;
}
inline void MotionStatus::set_head_got_stuck(bool value) {
  set_has_head_got_stuck();
  head_got_stuck_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionStatus.head_got_stuck)
}

// optional bool walk_emergency_stop = 13;
inline bool MotionStatus::has_walk_emergency_stop() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MotionStatus::set_has_walk_emergency_stop() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MotionStatus::clear_has_walk_emergency_stop() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MotionStatus::clear_walk_emergency_stop() {
  walk_emergency_stop_ = false;
  clear_has_walk_emergency_stop();
}
inline bool MotionStatus::walk_emergency_stop() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.walk_emergency_stop)
  return walk_emergency_stop_;
}
inline void MotionStatus::set_walk_emergency_stop(bool value) {
  set_has_walk_emergency_stop();
  walk_emergency_stop_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionStatus.walk_emergency_stop)
}

// optional bool head_at_rest = 14;
inline bool MotionStatus::has_head_at_rest() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MotionStatus::set_has_head_at_rest() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MotionStatus::clear_has_head_at_rest() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MotionStatus::clear_head_at_rest() {
  head_at_rest_ = false;
  clear_has_head_at_rest();
}
inline bool MotionStatus::head_at_rest() const {
  // @@protoc_insertion_point(field_get:naothmessages.MotionStatus.head_at_rest)
  return head_at_rest_;
}
inline void MotionStatus::set_head_at_rest(bool value) {
  set_has_head_at_rest();
  head_at_rest_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.MotionStatus.head_at_rest)
}

// -------------------------------------------------------------------

// OdometryData

// required .naothmessages.Pose2D pose = 1;
inline bool OdometryData::has_pose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OdometryData::set_has_pose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OdometryData::clear_has_pose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OdometryData::clear_pose() {
  if (pose_ != NULL) pose_->::naothmessages::Pose2D::Clear();
  clear_has_pose();
}
inline const ::naothmessages::Pose2D& OdometryData::pose() const {
  const ::naothmessages::Pose2D* p = pose_;
  // @@protoc_insertion_point(field_get:naothmessages.OdometryData.pose)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose2D*>(
      &::naothmessages::_Pose2D_default_instance_);
}
inline ::naothmessages::Pose2D* OdometryData::mutable_pose() {
  set_has_pose();
  if (pose_ == NULL) {
    pose_ = new ::naothmessages::Pose2D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.OdometryData.pose)
  return pose_;
}
inline ::naothmessages::Pose2D* OdometryData::release_pose() {
  // @@protoc_insertion_point(field_release:naothmessages.OdometryData.pose)
  clear_has_pose();
  ::naothmessages::Pose2D* temp = pose_;
  pose_ = NULL;
  return temp;
}
inline void OdometryData::set_allocated_pose(::naothmessages::Pose2D* pose) {
  delete pose_;
  pose_ = pose;
  if (pose) {
    set_has_pose();
  } else {
    clear_has_pose();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.OdometryData.pose)
}

// -------------------------------------------------------------------

// BodyState

// optional bool isLiftedUp = 1;
inline bool BodyState::has_isliftedup() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BodyState::set_has_isliftedup() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BodyState::clear_has_isliftedup() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BodyState::clear_isliftedup() {
  isliftedup_ = false;
  clear_has_isliftedup();
}
inline bool BodyState::isliftedup() const {
  // @@protoc_insertion_point(field_get:naothmessages.BodyState.isLiftedUp)
  return isliftedup_;
}
inline void BodyState::set_isliftedup(bool value) {
  set_has_isliftedup();
  isliftedup_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.BodyState.isLiftedUp)
}

// -------------------------------------------------------------------

// BodyStatus

// repeated double currentSum = 1;
inline int BodyStatus::currentsum_size() const {
  return currentsum_.size();
}
inline void BodyStatus::clear_currentsum() {
  currentsum_.Clear();
}
inline double BodyStatus::currentsum(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.BodyStatus.currentSum)
  return currentsum_.Get(index);
}
inline void BodyStatus::set_currentsum(int index, double value) {
  currentsum_.Set(index, value);
  // @@protoc_insertion_point(field_set:naothmessages.BodyStatus.currentSum)
}
inline void BodyStatus::add_currentsum(double value) {
  currentsum_.Add(value);
  // @@protoc_insertion_point(field_add:naothmessages.BodyStatus.currentSum)
}
inline const ::google::protobuf::RepeatedField< double >&
BodyStatus::currentsum() const {
  // @@protoc_insertion_point(field_list:naothmessages.BodyStatus.currentSum)
  return currentsum_;
}
inline ::google::protobuf::RepeatedField< double >*
BodyStatus::mutable_currentsum() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.BodyStatus.currentSum)
  return &currentsum_;
}

// required uint32 timestamp = 3;
inline bool BodyStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BodyStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BodyStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BodyStatus::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 BodyStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:naothmessages.BodyStatus.timestamp)
  return timestamp_;
}
inline void BodyStatus::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.BodyStatus.timestamp)
}

// -------------------------------------------------------------------

// CalibrationData

// optional .naothmessages.DoubleVector2 inertialSensorOffset = 1;
inline bool CalibrationData::has_inertialsensoroffset() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalibrationData::set_has_inertialsensoroffset() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalibrationData::clear_has_inertialsensoroffset() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalibrationData::clear_inertialsensoroffset() {
  if (inertialsensoroffset_ != NULL) inertialsensoroffset_->::naothmessages::DoubleVector2::Clear();
  clear_has_inertialsensoroffset();
}
inline const ::naothmessages::DoubleVector2& CalibrationData::inertialsensoroffset() const {
  const ::naothmessages::DoubleVector2* p = inertialsensoroffset_;
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationData.inertialSensorOffset)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* CalibrationData::mutable_inertialsensoroffset() {
  set_has_inertialsensoroffset();
  if (inertialsensoroffset_ == NULL) {
    inertialsensoroffset_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CalibrationData.inertialSensorOffset)
  return inertialsensoroffset_;
}
inline ::naothmessages::DoubleVector2* CalibrationData::release_inertialsensoroffset() {
  // @@protoc_insertion_point(field_release:naothmessages.CalibrationData.inertialSensorOffset)
  clear_has_inertialsensoroffset();
  ::naothmessages::DoubleVector2* temp = inertialsensoroffset_;
  inertialsensoroffset_ = NULL;
  return temp;
}
inline void CalibrationData::set_allocated_inertialsensoroffset(::naothmessages::DoubleVector2* inertialsensoroffset) {
  delete inertialsensoroffset_;
  inertialsensoroffset_ = inertialsensoroffset;
  if (inertialsensoroffset) {
    set_has_inertialsensoroffset();
  } else {
    clear_has_inertialsensoroffset();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CalibrationData.inertialSensorOffset)
}

// optional .naothmessages.DoubleVector3 gyroSensorOffset = 5;
inline bool CalibrationData::has_gyrosensoroffset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CalibrationData::set_has_gyrosensoroffset() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CalibrationData::clear_has_gyrosensoroffset() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CalibrationData::clear_gyrosensoroffset() {
  if (gyrosensoroffset_ != NULL) gyrosensoroffset_->::naothmessages::DoubleVector3::Clear();
  clear_has_gyrosensoroffset();
}
inline const ::naothmessages::DoubleVector3& CalibrationData::gyrosensoroffset() const {
  const ::naothmessages::DoubleVector3* p = gyrosensoroffset_;
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationData.gyroSensorOffset)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* CalibrationData::mutable_gyrosensoroffset() {
  set_has_gyrosensoroffset();
  if (gyrosensoroffset_ == NULL) {
    gyrosensoroffset_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CalibrationData.gyroSensorOffset)
  return gyrosensoroffset_;
}
inline ::naothmessages::DoubleVector3* CalibrationData::release_gyrosensoroffset() {
  // @@protoc_insertion_point(field_release:naothmessages.CalibrationData.gyroSensorOffset)
  clear_has_gyrosensoroffset();
  ::naothmessages::DoubleVector3* temp = gyrosensoroffset_;
  gyrosensoroffset_ = NULL;
  return temp;
}
inline void CalibrationData::set_allocated_gyrosensoroffset(::naothmessages::DoubleVector3* gyrosensoroffset) {
  delete gyrosensoroffset_;
  gyrosensoroffset_ = gyrosensoroffset;
  if (gyrosensoroffset) {
    set_has_gyrosensoroffset();
  } else {
    clear_has_gyrosensoroffset();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CalibrationData.gyroSensorOffset)
}

// optional .naothmessages.DoubleVector3 accSensorOffset = 3;
inline bool CalibrationData::has_accsensoroffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CalibrationData::set_has_accsensoroffset() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CalibrationData::clear_has_accsensoroffset() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CalibrationData::clear_accsensoroffset() {
  if (accsensoroffset_ != NULL) accsensoroffset_->::naothmessages::DoubleVector3::Clear();
  clear_has_accsensoroffset();
}
inline const ::naothmessages::DoubleVector3& CalibrationData::accsensoroffset() const {
  const ::naothmessages::DoubleVector3* p = accsensoroffset_;
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationData.accSensorOffset)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* CalibrationData::mutable_accsensoroffset() {
  set_has_accsensoroffset();
  if (accsensoroffset_ == NULL) {
    accsensoroffset_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CalibrationData.accSensorOffset)
  return accsensoroffset_;
}
inline ::naothmessages::DoubleVector3* CalibrationData::release_accsensoroffset() {
  // @@protoc_insertion_point(field_release:naothmessages.CalibrationData.accSensorOffset)
  clear_has_accsensoroffset();
  ::naothmessages::DoubleVector3* temp = accsensoroffset_;
  accsensoroffset_ = NULL;
  return temp;
}
inline void CalibrationData::set_allocated_accsensoroffset(::naothmessages::DoubleVector3* accsensoroffset) {
  delete accsensoroffset_;
  accsensoroffset_ = accsensoroffset;
  if (accsensoroffset) {
    set_has_accsensoroffset();
  } else {
    clear_has_accsensoroffset();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CalibrationData.accSensorOffset)
}

// required bool calibrated = 4;
inline bool CalibrationData::has_calibrated() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CalibrationData::set_has_calibrated() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CalibrationData::clear_has_calibrated() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CalibrationData::clear_calibrated() {
  calibrated_ = false;
  clear_has_calibrated();
}
inline bool CalibrationData::calibrated() const {
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationData.calibrated)
  return calibrated_;
}
inline void CalibrationData::set_calibrated(bool value) {
  set_has_calibrated();
  calibrated_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CalibrationData.calibrated)
}

// -------------------------------------------------------------------

// InertialModel

// optional .naothmessages.DoubleVector2 orientation = 1;
inline bool InertialModel::has_orientation() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InertialModel::set_has_orientation() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InertialModel::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InertialModel::clear_orientation() {
  if (orientation_ != NULL) orientation_->::naothmessages::DoubleVector2::Clear();
  clear_has_orientation();
}
inline const ::naothmessages::DoubleVector2& InertialModel::orientation() const {
  const ::naothmessages::DoubleVector2* p = orientation_;
  // @@protoc_insertion_point(field_get:naothmessages.InertialModel.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* InertialModel::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.InertialModel.orientation)
  return orientation_;
}
inline ::naothmessages::DoubleVector2* InertialModel::release_orientation() {
  // @@protoc_insertion_point(field_release:naothmessages.InertialModel.orientation)
  clear_has_orientation();
  ::naothmessages::DoubleVector2* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void InertialModel::set_allocated_orientation(::naothmessages::DoubleVector2* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.InertialModel.orientation)
}

// -------------------------------------------------------------------

// CameraMatrixCalibration

// repeated .naothmessages.DoubleVector2 correctionOffset = 1 [deprecated = true];
inline int CameraMatrixCalibration::correctionoffset_size() const {
  return correctionoffset_.size();
}
inline void CameraMatrixCalibration::clear_correctionoffset() {
  correctionoffset_.Clear();
}
inline const ::naothmessages::DoubleVector2& CameraMatrixCalibration::correctionoffset(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.CameraMatrixCalibration.correctionOffset)
  return correctionoffset_.Get(index);
}
inline ::naothmessages::DoubleVector2* CameraMatrixCalibration::mutable_correctionoffset(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.CameraMatrixCalibration.correctionOffset)
  return correctionoffset_.Mutable(index);
}
inline ::naothmessages::DoubleVector2* CameraMatrixCalibration::add_correctionoffset() {
  // @@protoc_insertion_point(field_add:naothmessages.CameraMatrixCalibration.correctionOffset)
  return correctionoffset_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
CameraMatrixCalibration::mutable_correctionoffset() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.CameraMatrixCalibration.correctionOffset)
  return &correctionoffset_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
CameraMatrixCalibration::correctionoffset() const {
  // @@protoc_insertion_point(field_list:naothmessages.CameraMatrixCalibration.correctionOffset)
  return correctionoffset_;
}

// optional .naothmessages.DoubleVector2 correctionOffsetBody = 2;
inline bool CameraMatrixCalibration::has_correctionoffsetbody() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CameraMatrixCalibration::set_has_correctionoffsetbody() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CameraMatrixCalibration::clear_has_correctionoffsetbody() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CameraMatrixCalibration::clear_correctionoffsetbody() {
  if (correctionoffsetbody_ != NULL) correctionoffsetbody_->::naothmessages::DoubleVector2::Clear();
  clear_has_correctionoffsetbody();
}
inline const ::naothmessages::DoubleVector2& CameraMatrixCalibration::correctionoffsetbody() const {
  const ::naothmessages::DoubleVector2* p = correctionoffsetbody_;
  // @@protoc_insertion_point(field_get:naothmessages.CameraMatrixCalibration.correctionOffsetBody)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* CameraMatrixCalibration::mutable_correctionoffsetbody() {
  set_has_correctionoffsetbody();
  if (correctionoffsetbody_ == NULL) {
    correctionoffsetbody_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CameraMatrixCalibration.correctionOffsetBody)
  return correctionoffsetbody_;
}
inline ::naothmessages::DoubleVector2* CameraMatrixCalibration::release_correctionoffsetbody() {
  // @@protoc_insertion_point(field_release:naothmessages.CameraMatrixCalibration.correctionOffsetBody)
  clear_has_correctionoffsetbody();
  ::naothmessages::DoubleVector2* temp = correctionoffsetbody_;
  correctionoffsetbody_ = NULL;
  return temp;
}
inline void CameraMatrixCalibration::set_allocated_correctionoffsetbody(::naothmessages::DoubleVector2* correctionoffsetbody) {
  delete correctionoffsetbody_;
  correctionoffsetbody_ = correctionoffsetbody;
  if (correctionoffsetbody) {
    set_has_correctionoffsetbody();
  } else {
    clear_has_correctionoffsetbody();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CameraMatrixCalibration.correctionOffsetBody)
}

// optional .naothmessages.DoubleVector3 correctionOffsetHead = 3;
inline bool CameraMatrixCalibration::has_correctionoffsethead() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CameraMatrixCalibration::set_has_correctionoffsethead() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CameraMatrixCalibration::clear_has_correctionoffsethead() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CameraMatrixCalibration::clear_correctionoffsethead() {
  if (correctionoffsethead_ != NULL) correctionoffsethead_->::naothmessages::DoubleVector3::Clear();
  clear_has_correctionoffsethead();
}
inline const ::naothmessages::DoubleVector3& CameraMatrixCalibration::correctionoffsethead() const {
  const ::naothmessages::DoubleVector3* p = correctionoffsethead_;
  // @@protoc_insertion_point(field_get:naothmessages.CameraMatrixCalibration.correctionOffsetHead)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* CameraMatrixCalibration::mutable_correctionoffsethead() {
  set_has_correctionoffsethead();
  if (correctionoffsethead_ == NULL) {
    correctionoffsethead_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CameraMatrixCalibration.correctionOffsetHead)
  return correctionoffsethead_;
}
inline ::naothmessages::DoubleVector3* CameraMatrixCalibration::release_correctionoffsethead() {
  // @@protoc_insertion_point(field_release:naothmessages.CameraMatrixCalibration.correctionOffsetHead)
  clear_has_correctionoffsethead();
  ::naothmessages::DoubleVector3* temp = correctionoffsethead_;
  correctionoffsethead_ = NULL;
  return temp;
}
inline void CameraMatrixCalibration::set_allocated_correctionoffsethead(::naothmessages::DoubleVector3* correctionoffsethead) {
  delete correctionoffsethead_;
  correctionoffsethead_ = correctionoffsethead;
  if (correctionoffsethead) {
    set_has_correctionoffsethead();
  } else {
    clear_has_correctionoffsethead();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CameraMatrixCalibration.correctionOffsetHead)
}

// repeated .naothmessages.DoubleVector3 correctionOffsetCam = 4;
inline int CameraMatrixCalibration::correctionoffsetcam_size() const {
  return correctionoffsetcam_.size();
}
inline void CameraMatrixCalibration::clear_correctionoffsetcam() {
  correctionoffsetcam_.Clear();
}
inline const ::naothmessages::DoubleVector3& CameraMatrixCalibration::correctionoffsetcam(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.CameraMatrixCalibration.correctionOffsetCam)
  return correctionoffsetcam_.Get(index);
}
inline ::naothmessages::DoubleVector3* CameraMatrixCalibration::mutable_correctionoffsetcam(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.CameraMatrixCalibration.correctionOffsetCam)
  return correctionoffsetcam_.Mutable(index);
}
inline ::naothmessages::DoubleVector3* CameraMatrixCalibration::add_correctionoffsetcam() {
  // @@protoc_insertion_point(field_add:naothmessages.CameraMatrixCalibration.correctionOffsetCam)
  return correctionoffsetcam_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector3 >*
CameraMatrixCalibration::mutable_correctionoffsetcam() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.CameraMatrixCalibration.correctionOffsetCam)
  return &correctionoffsetcam_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector3 >&
CameraMatrixCalibration::correctionoffsetcam() const {
  // @@protoc_insertion_point(field_list:naothmessages.CameraMatrixCalibration.correctionOffsetCam)
  return correctionoffsetcam_;
}

// -------------------------------------------------------------------

// BallCandidates_Patch

// required .naothmessages.IntVector2 min = 1;
inline bool BallCandidates_Patch::has_min() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BallCandidates_Patch::set_has_min() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BallCandidates_Patch::clear_has_min() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BallCandidates_Patch::clear_min() {
  if (min_ != NULL) min_->::naothmessages::IntVector2::Clear();
  clear_has_min();
}
inline const ::naothmessages::IntVector2& BallCandidates_Patch::min() const {
  const ::naothmessages::IntVector2* p = min_;
  // @@protoc_insertion_point(field_get:naothmessages.BallCandidates.Patch.min)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::IntVector2*>(
      &::naothmessages::_IntVector2_default_instance_);
}
inline ::naothmessages::IntVector2* BallCandidates_Patch::mutable_min() {
  set_has_min();
  if (min_ == NULL) {
    min_ = new ::naothmessages::IntVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.BallCandidates.Patch.min)
  return min_;
}
inline ::naothmessages::IntVector2* BallCandidates_Patch::release_min() {
  // @@protoc_insertion_point(field_release:naothmessages.BallCandidates.Patch.min)
  clear_has_min();
  ::naothmessages::IntVector2* temp = min_;
  min_ = NULL;
  return temp;
}
inline void BallCandidates_Patch::set_allocated_min(::naothmessages::IntVector2* min) {
  delete min_;
  min_ = min;
  if (min) {
    set_has_min();
  } else {
    clear_has_min();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallCandidates.Patch.min)
}

// required .naothmessages.IntVector2 max = 2;
inline bool BallCandidates_Patch::has_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BallCandidates_Patch::set_has_max() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BallCandidates_Patch::clear_has_max() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BallCandidates_Patch::clear_max() {
  if (max_ != NULL) max_->::naothmessages::IntVector2::Clear();
  clear_has_max();
}
inline const ::naothmessages::IntVector2& BallCandidates_Patch::max() const {
  const ::naothmessages::IntVector2* p = max_;
  // @@protoc_insertion_point(field_get:naothmessages.BallCandidates.Patch.max)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::IntVector2*>(
      &::naothmessages::_IntVector2_default_instance_);
}
inline ::naothmessages::IntVector2* BallCandidates_Patch::mutable_max() {
  set_has_max();
  if (max_ == NULL) {
    max_ = new ::naothmessages::IntVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.BallCandidates.Patch.max)
  return max_;
}
inline ::naothmessages::IntVector2* BallCandidates_Patch::release_max() {
  // @@protoc_insertion_point(field_release:naothmessages.BallCandidates.Patch.max)
  clear_has_max();
  ::naothmessages::IntVector2* temp = max_;
  max_ = NULL;
  return temp;
}
inline void BallCandidates_Patch::set_allocated_max(::naothmessages::IntVector2* max) {
  delete max_;
  max_ = max;
  if (max) {
    set_has_max();
  } else {
    clear_has_max();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallCandidates.Patch.max)
}

// optional .naothmessages.BallCandidates.Patch.Type type = 3 [default = Y];
inline bool BallCandidates_Patch::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BallCandidates_Patch::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BallCandidates_Patch::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BallCandidates_Patch::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::naothmessages::BallCandidates_Patch_Type BallCandidates_Patch::type() const {
  // @@protoc_insertion_point(field_get:naothmessages.BallCandidates.Patch.type)
  return static_cast< ::naothmessages::BallCandidates_Patch_Type >(type_);
}
inline void BallCandidates_Patch::set_type(::naothmessages::BallCandidates_Patch_Type value) {
  assert(::naothmessages::BallCandidates_Patch_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.BallCandidates.Patch.type)
}

// required bytes data = 5;
inline bool BallCandidates_Patch::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BallCandidates_Patch::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BallCandidates_Patch::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BallCandidates_Patch::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
inline const ::std::string& BallCandidates_Patch::data() const {
  // @@protoc_insertion_point(field_get:naothmessages.BallCandidates.Patch.data)
  return data_.GetNoArena();
}
inline void BallCandidates_Patch::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:naothmessages.BallCandidates.Patch.data)
}
#if LANG_CXX11
inline void BallCandidates_Patch::set_data(::std::string&& value) {
  set_has_data();
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:naothmessages.BallCandidates.Patch.data)
}
#endif
inline void BallCandidates_Patch::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:naothmessages.BallCandidates.Patch.data)
}
inline void BallCandidates_Patch::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:naothmessages.BallCandidates.Patch.data)
}
inline ::std::string* BallCandidates_Patch::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:naothmessages.BallCandidates.Patch.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BallCandidates_Patch::release_data() {
  // @@protoc_insertion_point(field_release:naothmessages.BallCandidates.Patch.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BallCandidates_Patch::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:naothmessages.BallCandidates.Patch.data)
}

// -------------------------------------------------------------------

// BallCandidates

// repeated .naothmessages.BallCandidates.Patch patches = 1;
inline int BallCandidates::patches_size() const {
  return patches_.size();
}
inline void BallCandidates::clear_patches() {
  patches_.Clear();
}
inline const ::naothmessages::BallCandidates_Patch& BallCandidates::patches(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.BallCandidates.patches)
  return patches_.Get(index);
}
inline ::naothmessages::BallCandidates_Patch* BallCandidates::mutable_patches(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.BallCandidates.patches)
  return patches_.Mutable(index);
}
inline ::naothmessages::BallCandidates_Patch* BallCandidates::add_patches() {
  // @@protoc_insertion_point(field_add:naothmessages.BallCandidates.patches)
  return patches_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::BallCandidates_Patch >*
BallCandidates::mutable_patches() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.BallCandidates.patches)
  return &patches_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::BallCandidates_Patch >&
BallCandidates::patches() const {
  // @@protoc_insertion_point(field_list:naothmessages.BallCandidates.patches)
  return patches_;
}

// -------------------------------------------------------------------

// RemoteControlCommand

// optional .naothmessages.RemoteControlCommand.ControlMode controlMode = 1;
inline bool RemoteControlCommand::has_controlmode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RemoteControlCommand::set_has_controlmode() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RemoteControlCommand::clear_has_controlmode() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RemoteControlCommand::clear_controlmode() {
  controlmode_ = 0;
  clear_has_controlmode();
}
inline ::naothmessages::RemoteControlCommand_ControlMode RemoteControlCommand::controlmode() const {
  // @@protoc_insertion_point(field_get:naothmessages.RemoteControlCommand.controlMode)
  return static_cast< ::naothmessages::RemoteControlCommand_ControlMode >(controlmode_);
}
inline void RemoteControlCommand::set_controlmode(::naothmessages::RemoteControlCommand_ControlMode value) {
  assert(::naothmessages::RemoteControlCommand_ControlMode_IsValid(value));
  set_has_controlmode();
  controlmode_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.RemoteControlCommand.controlMode)
}

// optional .naothmessages.RemoteControlCommand.ActionType action = 2;
inline bool RemoteControlCommand::has_action() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RemoteControlCommand::set_has_action() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RemoteControlCommand::clear_has_action() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RemoteControlCommand::clear_action() {
  action_ = 0;
  clear_has_action();
}
inline ::naothmessages::RemoteControlCommand_ActionType RemoteControlCommand::action() const {
  // @@protoc_insertion_point(field_get:naothmessages.RemoteControlCommand.action)
  return static_cast< ::naothmessages::RemoteControlCommand_ActionType >(action_);
}
inline void RemoteControlCommand::set_action(::naothmessages::RemoteControlCommand_ActionType value) {
  assert(::naothmessages::RemoteControlCommand_ActionType_IsValid(value));
  set_has_action();
  action_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.RemoteControlCommand.action)
}

// optional .naothmessages.RemoteControlCommand.SecondActionType second_action = 3;
inline bool RemoteControlCommand::has_second_action() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RemoteControlCommand::set_has_second_action() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RemoteControlCommand::clear_has_second_action() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RemoteControlCommand::clear_second_action() {
  second_action_ = 0;
  clear_has_second_action();
}
inline ::naothmessages::RemoteControlCommand_SecondActionType RemoteControlCommand::second_action() const {
  // @@protoc_insertion_point(field_get:naothmessages.RemoteControlCommand.second_action)
  return static_cast< ::naothmessages::RemoteControlCommand_SecondActionType >(second_action_);
}
inline void RemoteControlCommand::set_second_action(::naothmessages::RemoteControlCommand_SecondActionType value) {
  assert(::naothmessages::RemoteControlCommand_SecondActionType_IsValid(value));
  set_has_second_action();
  second_action_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.RemoteControlCommand.second_action)
}

// optional .naothmessages.Pose2D target = 4;
inline bool RemoteControlCommand::has_target() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RemoteControlCommand::set_has_target() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RemoteControlCommand::clear_has_target() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RemoteControlCommand::clear_target() {
  if (target_ != NULL) target_->::naothmessages::Pose2D::Clear();
  clear_has_target();
}
inline const ::naothmessages::Pose2D& RemoteControlCommand::target() const {
  const ::naothmessages::Pose2D* p = target_;
  // @@protoc_insertion_point(field_get:naothmessages.RemoteControlCommand.target)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose2D*>(
      &::naothmessages::_Pose2D_default_instance_);
}
inline ::naothmessages::Pose2D* RemoteControlCommand::mutable_target() {
  set_has_target();
  if (target_ == NULL) {
    target_ = new ::naothmessages::Pose2D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.RemoteControlCommand.target)
  return target_;
}
inline ::naothmessages::Pose2D* RemoteControlCommand::release_target() {
  // @@protoc_insertion_point(field_release:naothmessages.RemoteControlCommand.target)
  clear_has_target();
  ::naothmessages::Pose2D* temp = target_;
  target_ = NULL;
  return temp;
}
inline void RemoteControlCommand::set_allocated_target(::naothmessages::Pose2D* target) {
  delete target_;
  target_ = target;
  if (target) {
    set_has_target();
  } else {
    clear_has_target();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.RemoteControlCommand.target)
}

// -------------------------------------------------------------------

// GroundContactModel

// required bool leftGroundContact = 1;
inline bool GroundContactModel::has_leftgroundcontact() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroundContactModel::set_has_leftgroundcontact() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroundContactModel::clear_has_leftgroundcontact() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroundContactModel::clear_leftgroundcontact() {
  leftgroundcontact_ = false;
  clear_has_leftgroundcontact();
}
inline bool GroundContactModel::leftgroundcontact() const {
  // @@protoc_insertion_point(field_get:naothmessages.GroundContactModel.leftGroundContact)
  return leftgroundcontact_;
}
inline void GroundContactModel::set_leftgroundcontact(bool value) {
  set_has_leftgroundcontact();
  leftgroundcontact_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GroundContactModel.leftGroundContact)
}

// required bool rightGroundContact = 2;
inline bool GroundContactModel::has_rightgroundcontact() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroundContactModel::set_has_rightgroundcontact() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroundContactModel::clear_has_rightgroundcontact() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroundContactModel::clear_rightgroundcontact() {
  rightgroundcontact_ = false;
  clear_has_rightgroundcontact();
}
inline bool GroundContactModel::rightgroundcontact() const {
  // @@protoc_insertion_point(field_get:naothmessages.GroundContactModel.rightGroundContact)
  return rightgroundcontact_;
}
inline void GroundContactModel::set_rightgroundcontact(bool value) {
  set_has_rightgroundcontact();
  rightgroundcontact_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GroundContactModel.rightGroundContact)
}

// required .naothmessages.GroundContactModel.Foot supportFoot = 3;
inline bool GroundContactModel::has_supportfoot() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroundContactModel::set_has_supportfoot() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroundContactModel::clear_has_supportfoot() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroundContactModel::clear_supportfoot() {
  supportfoot_ = 0;
  clear_has_supportfoot();
}
inline ::naothmessages::GroundContactModel_Foot GroundContactModel::supportfoot() const {
  // @@protoc_insertion_point(field_get:naothmessages.GroundContactModel.supportFoot)
  return static_cast< ::naothmessages::GroundContactModel_Foot >(supportfoot_);
}
inline void GroundContactModel::set_supportfoot(::naothmessages::GroundContactModel_Foot value) {
  assert(::naothmessages::GroundContactModel_Foot_IsValid(value));
  set_has_supportfoot();
  supportfoot_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.GroundContactModel.supportFoot)
}

// -------------------------------------------------------------------

// CollisionPercept

// required uint32 timeCollisionArmLeft = 1;
inline bool CollisionPercept::has_timecollisionarmleft() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CollisionPercept::set_has_timecollisionarmleft() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CollisionPercept::clear_has_timecollisionarmleft() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CollisionPercept::clear_timecollisionarmleft() {
  timecollisionarmleft_ = 0u;
  clear_has_timecollisionarmleft();
}
inline ::google::protobuf::uint32 CollisionPercept::timecollisionarmleft() const {
  // @@protoc_insertion_point(field_get:naothmessages.CollisionPercept.timeCollisionArmLeft)
  return timecollisionarmleft_;
}
inline void CollisionPercept::set_timecollisionarmleft(::google::protobuf::uint32 value) {
  set_has_timecollisionarmleft();
  timecollisionarmleft_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CollisionPercept.timeCollisionArmLeft)
}

// required uint32 timeCollisionArmRight = 2;
inline bool CollisionPercept::has_timecollisionarmright() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CollisionPercept::set_has_timecollisionarmright() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CollisionPercept::clear_has_timecollisionarmright() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CollisionPercept::clear_timecollisionarmright() {
  timecollisionarmright_ = 0u;
  clear_has_timecollisionarmright();
}
inline ::google::protobuf::uint32 CollisionPercept::timecollisionarmright() const {
  // @@protoc_insertion_point(field_get:naothmessages.CollisionPercept.timeCollisionArmRight)
  return timecollisionarmright_;
}
inline void CollisionPercept::set_timecollisionarmright(::google::protobuf::uint32 value) {
  set_has_timecollisionarmright();
  timecollisionarmright_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CollisionPercept.timeCollisionArmRight)
}

// required bool isCollisionLeftBumper = 3;
inline bool CollisionPercept::has_iscollisionleftbumper() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CollisionPercept::set_has_iscollisionleftbumper() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CollisionPercept::clear_has_iscollisionleftbumper() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CollisionPercept::clear_iscollisionleftbumper() {
  iscollisionleftbumper_ = false;
  clear_has_iscollisionleftbumper();
}
inline bool CollisionPercept::iscollisionleftbumper() const {
  // @@protoc_insertion_point(field_get:naothmessages.CollisionPercept.isCollisionLeftBumper)
  return iscollisionleftbumper_;
}
inline void CollisionPercept::set_iscollisionleftbumper(bool value) {
  set_has_iscollisionleftbumper();
  iscollisionleftbumper_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CollisionPercept.isCollisionLeftBumper)
}

// required bool isCollisionRightBumper = 4;
inline bool CollisionPercept::has_iscollisionrightbumper() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CollisionPercept::set_has_iscollisionrightbumper() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CollisionPercept::clear_has_iscollisionrightbumper() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CollisionPercept::clear_iscollisionrightbumper() {
  iscollisionrightbumper_ = false;
  clear_has_iscollisionrightbumper();
}
inline bool CollisionPercept::iscollisionrightbumper() const {
  // @@protoc_insertion_point(field_get:naothmessages.CollisionPercept.isCollisionRightBumper)
  return iscollisionrightbumper_;
}
inline void CollisionPercept::set_iscollisionrightbumper(bool value) {
  set_has_iscollisionrightbumper();
  iscollisionrightbumper_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CollisionPercept.isCollisionRightBumper)
}

// required double lastComputedCollisionLeft = 5;
inline bool CollisionPercept::has_lastcomputedcollisionleft() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CollisionPercept::set_has_lastcomputedcollisionleft() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CollisionPercept::clear_has_lastcomputedcollisionleft() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CollisionPercept::clear_lastcomputedcollisionleft() {
  lastcomputedcollisionleft_ = 0;
  clear_has_lastcomputedcollisionleft();
}
inline double CollisionPercept::lastcomputedcollisionleft() const {
  // @@protoc_insertion_point(field_get:naothmessages.CollisionPercept.lastComputedCollisionLeft)
  return lastcomputedcollisionleft_;
}
inline void CollisionPercept::set_lastcomputedcollisionleft(double value) {
  set_has_lastcomputedcollisionleft();
  lastcomputedcollisionleft_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CollisionPercept.lastComputedCollisionLeft)
}

// required double lastComputedCollisionRight = 6;
inline bool CollisionPercept::has_lastcomputedcollisionright() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CollisionPercept::set_has_lastcomputedcollisionright() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CollisionPercept::clear_has_lastcomputedcollisionright() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CollisionPercept::clear_lastcomputedcollisionright() {
  lastcomputedcollisionright_ = 0;
  clear_has_lastcomputedcollisionright();
}
inline double CollisionPercept::lastcomputedcollisionright() const {
  // @@protoc_insertion_point(field_get:naothmessages.CollisionPercept.lastComputedCollisionRight)
  return lastcomputedcollisionright_;
}
inline void CollisionPercept::set_lastcomputedcollisionright(double value) {
  set_has_lastcomputedcollisionright();
  lastcomputedcollisionright_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CollisionPercept.lastComputedCollisionRight)
}

// -------------------------------------------------------------------

// IMUData

// required .naothmessages.DoubleVector3 location = 1;
inline bool IMUData::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IMUData::set_has_location() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IMUData::clear_has_location() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IMUData::clear_location() {
  if (location_ != NULL) location_->::naothmessages::DoubleVector3::Clear();
  clear_has_location();
}
inline const ::naothmessages::DoubleVector3& IMUData::location() const {
  const ::naothmessages::DoubleVector3* p = location_;
  // @@protoc_insertion_point(field_get:naothmessages.IMUData.location)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* IMUData::mutable_location() {
  set_has_location();
  if (location_ == NULL) {
    location_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.IMUData.location)
  return location_;
}
inline ::naothmessages::DoubleVector3* IMUData::release_location() {
  // @@protoc_insertion_point(field_release:naothmessages.IMUData.location)
  clear_has_location();
  ::naothmessages::DoubleVector3* temp = location_;
  location_ = NULL;
  return temp;
}
inline void IMUData::set_allocated_location(::naothmessages::DoubleVector3* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.IMUData.location)
}

// required .naothmessages.DoubleVector3 velocity = 2;
inline bool IMUData::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IMUData::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IMUData::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IMUData::clear_velocity() {
  if (velocity_ != NULL) velocity_->::naothmessages::DoubleVector3::Clear();
  clear_has_velocity();
}
inline const ::naothmessages::DoubleVector3& IMUData::velocity() const {
  const ::naothmessages::DoubleVector3* p = velocity_;
  // @@protoc_insertion_point(field_get:naothmessages.IMUData.velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* IMUData::mutable_velocity() {
  set_has_velocity();
  if (velocity_ == NULL) {
    velocity_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.IMUData.velocity)
  return velocity_;
}
inline ::naothmessages::DoubleVector3* IMUData::release_velocity() {
  // @@protoc_insertion_point(field_release:naothmessages.IMUData.velocity)
  clear_has_velocity();
  ::naothmessages::DoubleVector3* temp = velocity_;
  velocity_ = NULL;
  return temp;
}
inline void IMUData::set_allocated_velocity(::naothmessages::DoubleVector3* velocity) {
  delete velocity_;
  velocity_ = velocity;
  if (velocity) {
    set_has_velocity();
  } else {
    clear_has_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.IMUData.velocity)
}

// required .naothmessages.DoubleVector3 acceleration = 3;
inline bool IMUData::has_acceleration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IMUData::set_has_acceleration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IMUData::clear_has_acceleration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IMUData::clear_acceleration() {
  if (acceleration_ != NULL) acceleration_->::naothmessages::DoubleVector3::Clear();
  clear_has_acceleration();
}
inline const ::naothmessages::DoubleVector3& IMUData::acceleration() const {
  const ::naothmessages::DoubleVector3* p = acceleration_;
  // @@protoc_insertion_point(field_get:naothmessages.IMUData.acceleration)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* IMUData::mutable_acceleration() {
  set_has_acceleration();
  if (acceleration_ == NULL) {
    acceleration_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.IMUData.acceleration)
  return acceleration_;
}
inline ::naothmessages::DoubleVector3* IMUData::release_acceleration() {
  // @@protoc_insertion_point(field_release:naothmessages.IMUData.acceleration)
  clear_has_acceleration();
  ::naothmessages::DoubleVector3* temp = acceleration_;
  acceleration_ = NULL;
  return temp;
}
inline void IMUData::set_allocated_acceleration(::naothmessages::DoubleVector3* acceleration) {
  delete acceleration_;
  acceleration_ = acceleration;
  if (acceleration) {
    set_has_acceleration();
  } else {
    clear_has_acceleration();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.IMUData.acceleration)
}

// optional .naothmessages.DoubleVector3 acceleration_sensor = 4;
inline bool IMUData::has_acceleration_sensor() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IMUData::set_has_acceleration_sensor() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IMUData::clear_has_acceleration_sensor() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IMUData::clear_acceleration_sensor() {
  if (acceleration_sensor_ != NULL) acceleration_sensor_->::naothmessages::DoubleVector3::Clear();
  clear_has_acceleration_sensor();
}
inline const ::naothmessages::DoubleVector3& IMUData::acceleration_sensor() const {
  const ::naothmessages::DoubleVector3* p = acceleration_sensor_;
  // @@protoc_insertion_point(field_get:naothmessages.IMUData.acceleration_sensor)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* IMUData::mutable_acceleration_sensor() {
  set_has_acceleration_sensor();
  if (acceleration_sensor_ == NULL) {
    acceleration_sensor_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.IMUData.acceleration_sensor)
  return acceleration_sensor_;
}
inline ::naothmessages::DoubleVector3* IMUData::release_acceleration_sensor() {
  // @@protoc_insertion_point(field_release:naothmessages.IMUData.acceleration_sensor)
  clear_has_acceleration_sensor();
  ::naothmessages::DoubleVector3* temp = acceleration_sensor_;
  acceleration_sensor_ = NULL;
  return temp;
}
inline void IMUData::set_allocated_acceleration_sensor(::naothmessages::DoubleVector3* acceleration_sensor) {
  delete acceleration_sensor_;
  acceleration_sensor_ = acceleration_sensor;
  if (acceleration_sensor) {
    set_has_acceleration_sensor();
  } else {
    clear_has_acceleration_sensor();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.IMUData.acceleration_sensor)
}

// required .naothmessages.DoubleVector3 rotation = 5;
inline bool IMUData::has_rotation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IMUData::set_has_rotation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IMUData::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IMUData::clear_rotation() {
  if (rotation_ != NULL) rotation_->::naothmessages::DoubleVector3::Clear();
  clear_has_rotation();
}
inline const ::naothmessages::DoubleVector3& IMUData::rotation() const {
  const ::naothmessages::DoubleVector3* p = rotation_;
  // @@protoc_insertion_point(field_get:naothmessages.IMUData.rotation)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* IMUData::mutable_rotation() {
  set_has_rotation();
  if (rotation_ == NULL) {
    rotation_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.IMUData.rotation)
  return rotation_;
}
inline ::naothmessages::DoubleVector3* IMUData::release_rotation() {
  // @@protoc_insertion_point(field_release:naothmessages.IMUData.rotation)
  clear_has_rotation();
  ::naothmessages::DoubleVector3* temp = rotation_;
  rotation_ = NULL;
  return temp;
}
inline void IMUData::set_allocated_rotation(::naothmessages::DoubleVector3* rotation) {
  delete rotation_;
  rotation_ = rotation;
  if (rotation) {
    set_has_rotation();
  } else {
    clear_has_rotation();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.IMUData.rotation)
}

// required .naothmessages.DoubleVector3 rotational_velocity = 6;
inline bool IMUData::has_rotational_velocity() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IMUData::set_has_rotational_velocity() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IMUData::clear_has_rotational_velocity() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IMUData::clear_rotational_velocity() {
  if (rotational_velocity_ != NULL) rotational_velocity_->::naothmessages::DoubleVector3::Clear();
  clear_has_rotational_velocity();
}
inline const ::naothmessages::DoubleVector3& IMUData::rotational_velocity() const {
  const ::naothmessages::DoubleVector3* p = rotational_velocity_;
  // @@protoc_insertion_point(field_get:naothmessages.IMUData.rotational_velocity)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* IMUData::mutable_rotational_velocity() {
  set_has_rotational_velocity();
  if (rotational_velocity_ == NULL) {
    rotational_velocity_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.IMUData.rotational_velocity)
  return rotational_velocity_;
}
inline ::naothmessages::DoubleVector3* IMUData::release_rotational_velocity() {
  // @@protoc_insertion_point(field_release:naothmessages.IMUData.rotational_velocity)
  clear_has_rotational_velocity();
  ::naothmessages::DoubleVector3* temp = rotational_velocity_;
  rotational_velocity_ = NULL;
  return temp;
}
inline void IMUData::set_allocated_rotational_velocity(::naothmessages::DoubleVector3* rotational_velocity) {
  delete rotational_velocity_;
  rotational_velocity_ = rotational_velocity;
  if (rotational_velocity) {
    set_has_rotational_velocity();
  } else {
    clear_has_rotational_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.IMUData.rotational_velocity)
}

// optional .naothmessages.DoubleVector3 rotational_velocity_sensor = 7;
inline bool IMUData::has_rotational_velocity_sensor() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IMUData::set_has_rotational_velocity_sensor() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IMUData::clear_has_rotational_velocity_sensor() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IMUData::clear_rotational_velocity_sensor() {
  if (rotational_velocity_sensor_ != NULL) rotational_velocity_sensor_->::naothmessages::DoubleVector3::Clear();
  clear_has_rotational_velocity_sensor();
}
inline const ::naothmessages::DoubleVector3& IMUData::rotational_velocity_sensor() const {
  const ::naothmessages::DoubleVector3* p = rotational_velocity_sensor_;
  // @@protoc_insertion_point(field_get:naothmessages.IMUData.rotational_velocity_sensor)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* IMUData::mutable_rotational_velocity_sensor() {
  set_has_rotational_velocity_sensor();
  if (rotational_velocity_sensor_ == NULL) {
    rotational_velocity_sensor_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.IMUData.rotational_velocity_sensor)
  return rotational_velocity_sensor_;
}
inline ::naothmessages::DoubleVector3* IMUData::release_rotational_velocity_sensor() {
  // @@protoc_insertion_point(field_release:naothmessages.IMUData.rotational_velocity_sensor)
  clear_has_rotational_velocity_sensor();
  ::naothmessages::DoubleVector3* temp = rotational_velocity_sensor_;
  rotational_velocity_sensor_ = NULL;
  return temp;
}
inline void IMUData::set_allocated_rotational_velocity_sensor(::naothmessages::DoubleVector3* rotational_velocity_sensor) {
  delete rotational_velocity_sensor_;
  rotational_velocity_sensor_ = rotational_velocity_sensor;
  if (rotational_velocity_sensor) {
    set_has_rotational_velocity_sensor();
  } else {
    clear_has_rotational_velocity_sensor();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.IMUData.rotational_velocity_sensor)
}

// required .naothmessages.DoubleVector2 orientation = 8;
inline bool IMUData::has_orientation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IMUData::set_has_orientation() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IMUData::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IMUData::clear_orientation() {
  if (orientation_ != NULL) orientation_->::naothmessages::DoubleVector2::Clear();
  clear_has_orientation();
}
inline const ::naothmessages::DoubleVector2& IMUData::orientation() const {
  const ::naothmessages::DoubleVector2* p = orientation_;
  // @@protoc_insertion_point(field_get:naothmessages.IMUData.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* IMUData::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.IMUData.orientation)
  return orientation_;
}
inline ::naothmessages::DoubleVector2* IMUData::release_orientation() {
  // @@protoc_insertion_point(field_release:naothmessages.IMUData.orientation)
  clear_has_orientation();
  ::naothmessages::DoubleVector2* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void IMUData::set_allocated_orientation(::naothmessages::DoubleVector2* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.IMUData.orientation)
}

// required .naothmessages.DoubleVector3 orientation_rotvec = 9;
inline bool IMUData::has_orientation_rotvec() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IMUData::set_has_orientation_rotvec() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IMUData::clear_has_orientation_rotvec() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IMUData::clear_orientation_rotvec() {
  if (orientation_rotvec_ != NULL) orientation_rotvec_->::naothmessages::DoubleVector3::Clear();
  clear_has_orientation_rotvec();
}
inline const ::naothmessages::DoubleVector3& IMUData::orientation_rotvec() const {
  const ::naothmessages::DoubleVector3* p = orientation_rotvec_;
  // @@protoc_insertion_point(field_get:naothmessages.IMUData.orientation_rotvec)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* IMUData::mutable_orientation_rotvec() {
  set_has_orientation_rotvec();
  if (orientation_rotvec_ == NULL) {
    orientation_rotvec_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.IMUData.orientation_rotvec)
  return orientation_rotvec_;
}
inline ::naothmessages::DoubleVector3* IMUData::release_orientation_rotvec() {
  // @@protoc_insertion_point(field_release:naothmessages.IMUData.orientation_rotvec)
  clear_has_orientation_rotvec();
  ::naothmessages::DoubleVector3* temp = orientation_rotvec_;
  orientation_rotvec_ = NULL;
  return temp;
}
inline void IMUData::set_allocated_orientation_rotvec(::naothmessages::DoubleVector3* orientation_rotvec) {
  delete orientation_rotvec_;
  orientation_rotvec_ = orientation_rotvec;
  if (orientation_rotvec) {
    set_has_orientation_rotvec();
  } else {
    clear_has_orientation_rotvec();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.IMUData.orientation_rotvec)
}

// -------------------------------------------------------------------

// CentreOfPressure

// required .naothmessages.DoubleVector3 in_and_only_left_foot_cop = 1;
inline bool CentreOfPressure::has_in_and_only_left_foot_cop() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CentreOfPressure::set_has_in_and_only_left_foot_cop() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CentreOfPressure::clear_has_in_and_only_left_foot_cop() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CentreOfPressure::clear_in_and_only_left_foot_cop() {
  if (in_and_only_left_foot_cop_ != NULL) in_and_only_left_foot_cop_->::naothmessages::DoubleVector3::Clear();
  clear_has_in_and_only_left_foot_cop();
}
inline const ::naothmessages::DoubleVector3& CentreOfPressure::in_and_only_left_foot_cop() const {
  const ::naothmessages::DoubleVector3* p = in_and_only_left_foot_cop_;
  // @@protoc_insertion_point(field_get:naothmessages.CentreOfPressure.in_and_only_left_foot_cop)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* CentreOfPressure::mutable_in_and_only_left_foot_cop() {
  set_has_in_and_only_left_foot_cop();
  if (in_and_only_left_foot_cop_ == NULL) {
    in_and_only_left_foot_cop_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CentreOfPressure.in_and_only_left_foot_cop)
  return in_and_only_left_foot_cop_;
}
inline ::naothmessages::DoubleVector3* CentreOfPressure::release_in_and_only_left_foot_cop() {
  // @@protoc_insertion_point(field_release:naothmessages.CentreOfPressure.in_and_only_left_foot_cop)
  clear_has_in_and_only_left_foot_cop();
  ::naothmessages::DoubleVector3* temp = in_and_only_left_foot_cop_;
  in_and_only_left_foot_cop_ = NULL;
  return temp;
}
inline void CentreOfPressure::set_allocated_in_and_only_left_foot_cop(::naothmessages::DoubleVector3* in_and_only_left_foot_cop) {
  delete in_and_only_left_foot_cop_;
  in_and_only_left_foot_cop_ = in_and_only_left_foot_cop;
  if (in_and_only_left_foot_cop) {
    set_has_in_and_only_left_foot_cop();
  } else {
    clear_has_in_and_only_left_foot_cop();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CentreOfPressure.in_and_only_left_foot_cop)
}

// required double in_and_only_left_foot_magnitude = 2;
inline bool CentreOfPressure::has_in_and_only_left_foot_magnitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CentreOfPressure::set_has_in_and_only_left_foot_magnitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CentreOfPressure::clear_has_in_and_only_left_foot_magnitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CentreOfPressure::clear_in_and_only_left_foot_magnitude() {
  in_and_only_left_foot_magnitude_ = 0;
  clear_has_in_and_only_left_foot_magnitude();
}
inline double CentreOfPressure::in_and_only_left_foot_magnitude() const {
  // @@protoc_insertion_point(field_get:naothmessages.CentreOfPressure.in_and_only_left_foot_magnitude)
  return in_and_only_left_foot_magnitude_;
}
inline void CentreOfPressure::set_in_and_only_left_foot_magnitude(double value) {
  set_has_in_and_only_left_foot_magnitude();
  in_and_only_left_foot_magnitude_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CentreOfPressure.in_and_only_left_foot_magnitude)
}

// required bool in_and_only_left_foot_valid = 3;
inline bool CentreOfPressure::has_in_and_only_left_foot_valid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CentreOfPressure::set_has_in_and_only_left_foot_valid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CentreOfPressure::clear_has_in_and_only_left_foot_valid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CentreOfPressure::clear_in_and_only_left_foot_valid() {
  in_and_only_left_foot_valid_ = false;
  clear_has_in_and_only_left_foot_valid();
}
inline bool CentreOfPressure::in_and_only_left_foot_valid() const {
  // @@protoc_insertion_point(field_get:naothmessages.CentreOfPressure.in_and_only_left_foot_valid)
  return in_and_only_left_foot_valid_;
}
inline void CentreOfPressure::set_in_and_only_left_foot_valid(bool value) {
  set_has_in_and_only_left_foot_valid();
  in_and_only_left_foot_valid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CentreOfPressure.in_and_only_left_foot_valid)
}

// required .naothmessages.DoubleVector3 in_and_only_right_foot_cop = 4;
inline bool CentreOfPressure::has_in_and_only_right_foot_cop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CentreOfPressure::set_has_in_and_only_right_foot_cop() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CentreOfPressure::clear_has_in_and_only_right_foot_cop() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CentreOfPressure::clear_in_and_only_right_foot_cop() {
  if (in_and_only_right_foot_cop_ != NULL) in_and_only_right_foot_cop_->::naothmessages::DoubleVector3::Clear();
  clear_has_in_and_only_right_foot_cop();
}
inline const ::naothmessages::DoubleVector3& CentreOfPressure::in_and_only_right_foot_cop() const {
  const ::naothmessages::DoubleVector3* p = in_and_only_right_foot_cop_;
  // @@protoc_insertion_point(field_get:naothmessages.CentreOfPressure.in_and_only_right_foot_cop)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* CentreOfPressure::mutable_in_and_only_right_foot_cop() {
  set_has_in_and_only_right_foot_cop();
  if (in_and_only_right_foot_cop_ == NULL) {
    in_and_only_right_foot_cop_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CentreOfPressure.in_and_only_right_foot_cop)
  return in_and_only_right_foot_cop_;
}
inline ::naothmessages::DoubleVector3* CentreOfPressure::release_in_and_only_right_foot_cop() {
  // @@protoc_insertion_point(field_release:naothmessages.CentreOfPressure.in_and_only_right_foot_cop)
  clear_has_in_and_only_right_foot_cop();
  ::naothmessages::DoubleVector3* temp = in_and_only_right_foot_cop_;
  in_and_only_right_foot_cop_ = NULL;
  return temp;
}
inline void CentreOfPressure::set_allocated_in_and_only_right_foot_cop(::naothmessages::DoubleVector3* in_and_only_right_foot_cop) {
  delete in_and_only_right_foot_cop_;
  in_and_only_right_foot_cop_ = in_and_only_right_foot_cop;
  if (in_and_only_right_foot_cop) {
    set_has_in_and_only_right_foot_cop();
  } else {
    clear_has_in_and_only_right_foot_cop();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CentreOfPressure.in_and_only_right_foot_cop)
}

// required double in_and_only_right_foot_magnitude = 5;
inline bool CentreOfPressure::has_in_and_only_right_foot_magnitude() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CentreOfPressure::set_has_in_and_only_right_foot_magnitude() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CentreOfPressure::clear_has_in_and_only_right_foot_magnitude() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CentreOfPressure::clear_in_and_only_right_foot_magnitude() {
  in_and_only_right_foot_magnitude_ = 0;
  clear_has_in_and_only_right_foot_magnitude();
}
inline double CentreOfPressure::in_and_only_right_foot_magnitude() const {
  // @@protoc_insertion_point(field_get:naothmessages.CentreOfPressure.in_and_only_right_foot_magnitude)
  return in_and_only_right_foot_magnitude_;
}
inline void CentreOfPressure::set_in_and_only_right_foot_magnitude(double value) {
  set_has_in_and_only_right_foot_magnitude();
  in_and_only_right_foot_magnitude_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CentreOfPressure.in_and_only_right_foot_magnitude)
}

// required bool in_and_only_right_foot_valid = 6;
inline bool CentreOfPressure::has_in_and_only_right_foot_valid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CentreOfPressure::set_has_in_and_only_right_foot_valid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CentreOfPressure::clear_has_in_and_only_right_foot_valid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CentreOfPressure::clear_in_and_only_right_foot_valid() {
  in_and_only_right_foot_valid_ = false;
  clear_has_in_and_only_right_foot_valid();
}
inline bool CentreOfPressure::in_and_only_right_foot_valid() const {
  // @@protoc_insertion_point(field_get:naothmessages.CentreOfPressure.in_and_only_right_foot_valid)
  return in_and_only_right_foot_valid_;
}
inline void CentreOfPressure::set_in_and_only_right_foot_valid(bool value) {
  set_has_in_and_only_right_foot_valid();
  in_and_only_right_foot_valid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CentreOfPressure.in_and_only_right_foot_valid)
}

// required .naothmessages.DoubleVector3 in_kinematic_chain_origin_cop = 7;
inline bool CentreOfPressure::has_in_kinematic_chain_origin_cop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CentreOfPressure::set_has_in_kinematic_chain_origin_cop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CentreOfPressure::clear_has_in_kinematic_chain_origin_cop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CentreOfPressure::clear_in_kinematic_chain_origin_cop() {
  if (in_kinematic_chain_origin_cop_ != NULL) in_kinematic_chain_origin_cop_->::naothmessages::DoubleVector3::Clear();
  clear_has_in_kinematic_chain_origin_cop();
}
inline const ::naothmessages::DoubleVector3& CentreOfPressure::in_kinematic_chain_origin_cop() const {
  const ::naothmessages::DoubleVector3* p = in_kinematic_chain_origin_cop_;
  // @@protoc_insertion_point(field_get:naothmessages.CentreOfPressure.in_kinematic_chain_origin_cop)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* CentreOfPressure::mutable_in_kinematic_chain_origin_cop() {
  set_has_in_kinematic_chain_origin_cop();
  if (in_kinematic_chain_origin_cop_ == NULL) {
    in_kinematic_chain_origin_cop_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CentreOfPressure.in_kinematic_chain_origin_cop)
  return in_kinematic_chain_origin_cop_;
}
inline ::naothmessages::DoubleVector3* CentreOfPressure::release_in_kinematic_chain_origin_cop() {
  // @@protoc_insertion_point(field_release:naothmessages.CentreOfPressure.in_kinematic_chain_origin_cop)
  clear_has_in_kinematic_chain_origin_cop();
  ::naothmessages::DoubleVector3* temp = in_kinematic_chain_origin_cop_;
  in_kinematic_chain_origin_cop_ = NULL;
  return temp;
}
inline void CentreOfPressure::set_allocated_in_kinematic_chain_origin_cop(::naothmessages::DoubleVector3* in_kinematic_chain_origin_cop) {
  delete in_kinematic_chain_origin_cop_;
  in_kinematic_chain_origin_cop_ = in_kinematic_chain_origin_cop;
  if (in_kinematic_chain_origin_cop) {
    set_has_in_kinematic_chain_origin_cop();
  } else {
    clear_has_in_kinematic_chain_origin_cop();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CentreOfPressure.in_kinematic_chain_origin_cop)
}

// required double in_kinematic_chain_origin_magnitude = 8;
inline bool CentreOfPressure::has_in_kinematic_chain_origin_magnitude() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CentreOfPressure::set_has_in_kinematic_chain_origin_magnitude() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CentreOfPressure::clear_has_in_kinematic_chain_origin_magnitude() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CentreOfPressure::clear_in_kinematic_chain_origin_magnitude() {
  in_kinematic_chain_origin_magnitude_ = 0;
  clear_has_in_kinematic_chain_origin_magnitude();
}
inline double CentreOfPressure::in_kinematic_chain_origin_magnitude() const {
  // @@protoc_insertion_point(field_get:naothmessages.CentreOfPressure.in_kinematic_chain_origin_magnitude)
  return in_kinematic_chain_origin_magnitude_;
}
inline void CentreOfPressure::set_in_kinematic_chain_origin_magnitude(double value) {
  set_has_in_kinematic_chain_origin_magnitude();
  in_kinematic_chain_origin_magnitude_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CentreOfPressure.in_kinematic_chain_origin_magnitude)
}

// required bool in_kinematic_chain_origin_valid = 9;
inline bool CentreOfPressure::has_in_kinematic_chain_origin_valid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CentreOfPressure::set_has_in_kinematic_chain_origin_valid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CentreOfPressure::clear_has_in_kinematic_chain_origin_valid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CentreOfPressure::clear_in_kinematic_chain_origin_valid() {
  in_kinematic_chain_origin_valid_ = false;
  clear_has_in_kinematic_chain_origin_valid();
}
inline bool CentreOfPressure::in_kinematic_chain_origin_valid() const {
  // @@protoc_insertion_point(field_get:naothmessages.CentreOfPressure.in_kinematic_chain_origin_valid)
  return in_kinematic_chain_origin_valid_;
}
inline void CentreOfPressure::set_in_kinematic_chain_origin_valid(bool value) {
  set_has_in_kinematic_chain_origin_valid();
  in_kinematic_chain_origin_valid_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CentreOfPressure.in_kinematic_chain_origin_valid)
}

// -------------------------------------------------------------------

// CalibrationDataCMC_CalibrationDataSampleV3

// optional .naothmessages.Pose3D chestPose = 1;
inline bool CalibrationDataCMC_CalibrationDataSampleV3::has_chestpose() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::set_has_chestpose() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::clear_has_chestpose() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::clear_chestpose() {
  if (chestpose_ != NULL) chestpose_->::naothmessages::Pose3D::Clear();
  clear_has_chestpose();
}
inline const ::naothmessages::Pose3D& CalibrationDataCMC_CalibrationDataSampleV3::chestpose() const {
  const ::naothmessages::Pose3D* p = chestpose_;
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.chestPose)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose3D*>(
      &::naothmessages::_Pose3D_default_instance_);
}
inline ::naothmessages::Pose3D* CalibrationDataCMC_CalibrationDataSampleV3::mutable_chestpose() {
  set_has_chestpose();
  if (chestpose_ == NULL) {
    chestpose_ = new ::naothmessages::Pose3D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.chestPose)
  return chestpose_;
}
inline ::naothmessages::Pose3D* CalibrationDataCMC_CalibrationDataSampleV3::release_chestpose() {
  // @@protoc_insertion_point(field_release:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.chestPose)
  clear_has_chestpose();
  ::naothmessages::Pose3D* temp = chestpose_;
  chestpose_ = NULL;
  return temp;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::set_allocated_chestpose(::naothmessages::Pose3D* chestpose) {
  delete chestpose_;
  chestpose_ = chestpose;
  if (chestpose) {
    set_has_chestpose();
  } else {
    clear_has_chestpose();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.chestPose)
}

// repeated .naothmessages.DoubleVector2 edgelsInImage = 2;
inline int CalibrationDataCMC_CalibrationDataSampleV3::edgelsinimage_size() const {
  return edgelsinimage_.size();
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::clear_edgelsinimage() {
  edgelsinimage_.Clear();
}
inline const ::naothmessages::DoubleVector2& CalibrationDataCMC_CalibrationDataSampleV3::edgelsinimage(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.edgelsInImage)
  return edgelsinimage_.Get(index);
}
inline ::naothmessages::DoubleVector2* CalibrationDataCMC_CalibrationDataSampleV3::mutable_edgelsinimage(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.edgelsInImage)
  return edgelsinimage_.Mutable(index);
}
inline ::naothmessages::DoubleVector2* CalibrationDataCMC_CalibrationDataSampleV3::add_edgelsinimage() {
  // @@protoc_insertion_point(field_add:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.edgelsInImage)
  return edgelsinimage_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
CalibrationDataCMC_CalibrationDataSampleV3::mutable_edgelsinimage() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.edgelsInImage)
  return &edgelsinimage_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
CalibrationDataCMC_CalibrationDataSampleV3::edgelsinimage() const {
  // @@protoc_insertion_point(field_list:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.edgelsInImage)
  return edgelsinimage_;
}

// repeated .naothmessages.DoubleVector2 edgelsInImageTop = 3;
inline int CalibrationDataCMC_CalibrationDataSampleV3::edgelsinimagetop_size() const {
  return edgelsinimagetop_.size();
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::clear_edgelsinimagetop() {
  edgelsinimagetop_.Clear();
}
inline const ::naothmessages::DoubleVector2& CalibrationDataCMC_CalibrationDataSampleV3::edgelsinimagetop(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.edgelsInImageTop)
  return edgelsinimagetop_.Get(index);
}
inline ::naothmessages::DoubleVector2* CalibrationDataCMC_CalibrationDataSampleV3::mutable_edgelsinimagetop(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.edgelsInImageTop)
  return edgelsinimagetop_.Mutable(index);
}
inline ::naothmessages::DoubleVector2* CalibrationDataCMC_CalibrationDataSampleV3::add_edgelsinimagetop() {
  // @@protoc_insertion_point(field_add:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.edgelsInImageTop)
  return edgelsinimagetop_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >*
CalibrationDataCMC_CalibrationDataSampleV3::mutable_edgelsinimagetop() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.edgelsInImageTop)
  return &edgelsinimagetop_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DoubleVector2 >&
CalibrationDataCMC_CalibrationDataSampleV3::edgelsinimagetop() const {
  // @@protoc_insertion_point(field_list:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.edgelsInImageTop)
  return edgelsinimagetop_;
}

// optional .naothmessages.DoubleVector2 orientation = 4;
inline bool CalibrationDataCMC_CalibrationDataSampleV3::has_orientation() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::set_has_orientation() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::clear_has_orientation() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::clear_orientation() {
  if (orientation_ != NULL) orientation_->::naothmessages::DoubleVector2::Clear();
  clear_has_orientation();
}
inline const ::naothmessages::DoubleVector2& CalibrationDataCMC_CalibrationDataSampleV3::orientation() const {
  const ::naothmessages::DoubleVector2* p = orientation_;
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.orientation)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector2*>(
      &::naothmessages::_DoubleVector2_default_instance_);
}
inline ::naothmessages::DoubleVector2* CalibrationDataCMC_CalibrationDataSampleV3::mutable_orientation() {
  set_has_orientation();
  if (orientation_ == NULL) {
    orientation_ = new ::naothmessages::DoubleVector2;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.orientation)
  return orientation_;
}
inline ::naothmessages::DoubleVector2* CalibrationDataCMC_CalibrationDataSampleV3::release_orientation() {
  // @@protoc_insertion_point(field_release:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.orientation)
  clear_has_orientation();
  ::naothmessages::DoubleVector2* temp = orientation_;
  orientation_ = NULL;
  return temp;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::set_allocated_orientation(::naothmessages::DoubleVector2* orientation) {
  delete orientation_;
  orientation_ = orientation;
  if (orientation) {
    set_has_orientation();
  } else {
    clear_has_orientation();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.orientation)
}

// optional double headYaw = 5;
inline bool CalibrationDataCMC_CalibrationDataSampleV3::has_headyaw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::set_has_headyaw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::clear_has_headyaw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::clear_headyaw() {
  headyaw_ = 0;
  clear_has_headyaw();
}
inline double CalibrationDataCMC_CalibrationDataSampleV3::headyaw() const {
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.headYaw)
  return headyaw_;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::set_headyaw(double value) {
  set_has_headyaw();
  headyaw_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.headYaw)
}

// optional double headPitch = 6;
inline bool CalibrationDataCMC_CalibrationDataSampleV3::has_headpitch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::set_has_headpitch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::clear_has_headpitch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::clear_headpitch() {
  headpitch_ = 0;
  clear_has_headpitch();
}
inline double CalibrationDataCMC_CalibrationDataSampleV3::headpitch() const {
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.headPitch)
  return headpitch_;
}
inline void CalibrationDataCMC_CalibrationDataSampleV3::set_headpitch(double value) {
  set_has_headpitch();
  headpitch_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CalibrationDataCMC.CalibrationDataSampleV3.headPitch)
}

// -------------------------------------------------------------------

// CalibrationDataCMC

// repeated .naothmessages.CalibrationDataCMC.CalibrationDataSampleV3 calibrationData = 1;
inline int CalibrationDataCMC::calibrationdata_size() const {
  return calibrationdata_.size();
}
inline void CalibrationDataCMC::clear_calibrationdata() {
  calibrationdata_.Clear();
}
inline const ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3& CalibrationDataCMC::calibrationdata(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationDataCMC.calibrationData)
  return calibrationdata_.Get(index);
}
inline ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3* CalibrationDataCMC::mutable_calibrationdata(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.CalibrationDataCMC.calibrationData)
  return calibrationdata_.Mutable(index);
}
inline ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3* CalibrationDataCMC::add_calibrationdata() {
  // @@protoc_insertion_point(field_add:naothmessages.CalibrationDataCMC.calibrationData)
  return calibrationdata_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3 >*
CalibrationDataCMC::mutable_calibrationdata() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.CalibrationDataCMC.calibrationData)
  return &calibrationdata_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::CalibrationDataCMC_CalibrationDataSampleV3 >&
CalibrationDataCMC::calibrationdata() const {
  // @@protoc_insertion_point(field_list:naothmessages.CalibrationDataCMC.calibrationData)
  return calibrationdata_;
}

// optional uint32 numberOfResudials = 2;
inline bool CalibrationDataCMC::has_numberofresudials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CalibrationDataCMC::set_has_numberofresudials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CalibrationDataCMC::clear_has_numberofresudials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CalibrationDataCMC::clear_numberofresudials() {
  numberofresudials_ = 0u;
  clear_has_numberofresudials();
}
inline ::google::protobuf::uint32 CalibrationDataCMC::numberofresudials() const {
  // @@protoc_insertion_point(field_get:naothmessages.CalibrationDataCMC.numberOfResudials)
  return numberofresudials_;
}
inline void CalibrationDataCMC::set_numberofresudials(::google::protobuf::uint32 value) {
  set_has_numberofresudials();
  numberofresudials_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.CalibrationDataCMC.numberOfResudials)
}

// -------------------------------------------------------------------

// WhistlePercept_Whistle

// required string name = 1;
inline bool WhistlePercept_Whistle::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WhistlePercept_Whistle::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WhistlePercept_Whistle::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WhistlePercept_Whistle::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& WhistlePercept_Whistle::name() const {
  // @@protoc_insertion_point(field_get:naothmessages.WhistlePercept.Whistle.name)
  return name_.GetNoArena();
}
inline void WhistlePercept_Whistle::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:naothmessages.WhistlePercept.Whistle.name)
}
#if LANG_CXX11
inline void WhistlePercept_Whistle::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:naothmessages.WhistlePercept.Whistle.name)
}
#endif
inline void WhistlePercept_Whistle::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:naothmessages.WhistlePercept.Whistle.name)
}
inline void WhistlePercept_Whistle::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:naothmessages.WhistlePercept.Whistle.name)
}
inline ::std::string* WhistlePercept_Whistle::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:naothmessages.WhistlePercept.Whistle.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WhistlePercept_Whistle::release_name() {
  // @@protoc_insertion_point(field_release:naothmessages.WhistlePercept.Whistle.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WhistlePercept_Whistle::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:naothmessages.WhistlePercept.Whistle.name)
}

// required int64 positionInCapture = 2;
inline bool WhistlePercept_Whistle::has_positionincapture() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WhistlePercept_Whistle::set_has_positionincapture() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WhistlePercept_Whistle::clear_has_positionincapture() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WhistlePercept_Whistle::clear_positionincapture() {
  positionincapture_ = GOOGLE_LONGLONG(0);
  clear_has_positionincapture();
}
inline ::google::protobuf::int64 WhistlePercept_Whistle::positionincapture() const {
  // @@protoc_insertion_point(field_get:naothmessages.WhistlePercept.Whistle.positionInCapture)
  return positionincapture_;
}
inline void WhistlePercept_Whistle::set_positionincapture(::google::protobuf::int64 value) {
  set_has_positionincapture();
  positionincapture_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.WhistlePercept.Whistle.positionInCapture)
}

// required double responseValue = 3;
inline bool WhistlePercept_Whistle::has_responsevalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WhistlePercept_Whistle::set_has_responsevalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WhistlePercept_Whistle::clear_has_responsevalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WhistlePercept_Whistle::clear_responsevalue() {
  responsevalue_ = 0;
  clear_has_responsevalue();
}
inline double WhistlePercept_Whistle::responsevalue() const {
  // @@protoc_insertion_point(field_get:naothmessages.WhistlePercept.Whistle.responseValue)
  return responsevalue_;
}
inline void WhistlePercept_Whistle::set_responsevalue(double value) {
  set_has_responsevalue();
  responsevalue_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.WhistlePercept.Whistle.responseValue)
}

// -------------------------------------------------------------------

// WhistlePercept

// optional uint32 frameWhenWhistleDetected = 1;
inline bool WhistlePercept::has_framewhenwhistledetected() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WhistlePercept::set_has_framewhenwhistledetected() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WhistlePercept::clear_has_framewhenwhistledetected() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WhistlePercept::clear_framewhenwhistledetected() {
  framewhenwhistledetected_ = 0u;
  clear_has_framewhenwhistledetected();
}
inline ::google::protobuf::uint32 WhistlePercept::framewhenwhistledetected() const {
  // @@protoc_insertion_point(field_get:naothmessages.WhistlePercept.frameWhenWhistleDetected)
  return framewhenwhistledetected_;
}
inline void WhistlePercept::set_framewhenwhistledetected(::google::protobuf::uint32 value) {
  set_has_framewhenwhistledetected();
  framewhenwhistledetected_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.WhistlePercept.frameWhenWhistleDetected)
}

// optional string captureFile = 2;
inline bool WhistlePercept::has_capturefile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WhistlePercept::set_has_capturefile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WhistlePercept::clear_has_capturefile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WhistlePercept::clear_capturefile() {
  capturefile_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_capturefile();
}
inline const ::std::string& WhistlePercept::capturefile() const {
  // @@protoc_insertion_point(field_get:naothmessages.WhistlePercept.captureFile)
  return capturefile_.GetNoArena();
}
inline void WhistlePercept::set_capturefile(const ::std::string& value) {
  set_has_capturefile();
  capturefile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:naothmessages.WhistlePercept.captureFile)
}
#if LANG_CXX11
inline void WhistlePercept::set_capturefile(::std::string&& value) {
  set_has_capturefile();
  capturefile_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:naothmessages.WhistlePercept.captureFile)
}
#endif
inline void WhistlePercept::set_capturefile(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_capturefile();
  capturefile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:naothmessages.WhistlePercept.captureFile)
}
inline void WhistlePercept::set_capturefile(const char* value, size_t size) {
  set_has_capturefile();
  capturefile_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:naothmessages.WhistlePercept.captureFile)
}
inline ::std::string* WhistlePercept::mutable_capturefile() {
  set_has_capturefile();
  // @@protoc_insertion_point(field_mutable:naothmessages.WhistlePercept.captureFile)
  return capturefile_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WhistlePercept::release_capturefile() {
  // @@protoc_insertion_point(field_release:naothmessages.WhistlePercept.captureFile)
  clear_has_capturefile();
  return capturefile_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WhistlePercept::set_allocated_capturefile(::std::string* capturefile) {
  if (capturefile != NULL) {
    set_has_capturefile();
  } else {
    clear_has_capturefile();
  }
  capturefile_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), capturefile);
  // @@protoc_insertion_point(field_set_allocated:naothmessages.WhistlePercept.captureFile)
}

// repeated .naothmessages.WhistlePercept.Whistle recognizedWhistles = 3;
inline int WhistlePercept::recognizedwhistles_size() const {
  return recognizedwhistles_.size();
}
inline void WhistlePercept::clear_recognizedwhistles() {
  recognizedwhistles_.Clear();
}
inline const ::naothmessages::WhistlePercept_Whistle& WhistlePercept::recognizedwhistles(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.WhistlePercept.recognizedWhistles)
  return recognizedwhistles_.Get(index);
}
inline ::naothmessages::WhistlePercept_Whistle* WhistlePercept::mutable_recognizedwhistles(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.WhistlePercept.recognizedWhistles)
  return recognizedwhistles_.Mutable(index);
}
inline ::naothmessages::WhistlePercept_Whistle* WhistlePercept::add_recognizedwhistles() {
  // @@protoc_insertion_point(field_add:naothmessages.WhistlePercept.recognizedWhistles)
  return recognizedwhistles_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::WhistlePercept_Whistle >*
WhistlePercept::mutable_recognizedwhistles() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.WhistlePercept.recognizedWhistles)
  return &recognizedwhistles_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::WhistlePercept_Whistle >&
WhistlePercept::recognizedwhistles() const {
  // @@protoc_insertion_point(field_list:naothmessages.WhistlePercept.recognizedWhistles)
  return recognizedwhistles_;
}

// optional bool whistleDetected = 4;
inline bool WhistlePercept::has_whistledetected() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WhistlePercept::set_has_whistledetected() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WhistlePercept::clear_has_whistledetected() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WhistlePercept::clear_whistledetected() {
  whistledetected_ = false;
  clear_has_whistledetected();
}
inline bool WhistlePercept::whistledetected() const {
  // @@protoc_insertion_point(field_get:naothmessages.WhistlePercept.whistleDetected)
  return whistledetected_;
}
inline void WhistlePercept::set_whistledetected(bool value) {
  set_has_whistledetected();
  whistledetected_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.WhistlePercept.whistleDetected)
}

// -------------------------------------------------------------------

// DebugModify_ModifyValue

// required string name = 1;
inline bool DebugModify_ModifyValue::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DebugModify_ModifyValue::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DebugModify_ModifyValue::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DebugModify_ModifyValue::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& DebugModify_ModifyValue::name() const {
  // @@protoc_insertion_point(field_get:naothmessages.DebugModify.ModifyValue.name)
  return name_.GetNoArena();
}
inline void DebugModify_ModifyValue::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:naothmessages.DebugModify.ModifyValue.name)
}
#if LANG_CXX11
inline void DebugModify_ModifyValue::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:naothmessages.DebugModify.ModifyValue.name)
}
#endif
inline void DebugModify_ModifyValue::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:naothmessages.DebugModify.ModifyValue.name)
}
inline void DebugModify_ModifyValue::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:naothmessages.DebugModify.ModifyValue.name)
}
inline ::std::string* DebugModify_ModifyValue::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:naothmessages.DebugModify.ModifyValue.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DebugModify_ModifyValue::release_name() {
  // @@protoc_insertion_point(field_release:naothmessages.DebugModify.ModifyValue.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DebugModify_ModifyValue::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:naothmessages.DebugModify.ModifyValue.name)
}

// optional bool modify = 2;
inline bool DebugModify_ModifyValue::has_modify() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DebugModify_ModifyValue::set_has_modify() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DebugModify_ModifyValue::clear_has_modify() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DebugModify_ModifyValue::clear_modify() {
  modify_ = false;
  clear_has_modify();
}
inline bool DebugModify_ModifyValue::modify() const {
  // @@protoc_insertion_point(field_get:naothmessages.DebugModify.ModifyValue.modify)
  return modify_;
}
inline void DebugModify_ModifyValue::set_modify(bool value) {
  set_has_modify();
  modify_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.DebugModify.ModifyValue.modify)
}

// optional double value = 3;
inline bool DebugModify_ModifyValue::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DebugModify_ModifyValue::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DebugModify_ModifyValue::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DebugModify_ModifyValue::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline double DebugModify_ModifyValue::value() const {
  // @@protoc_insertion_point(field_get:naothmessages.DebugModify.ModifyValue.value)
  return value_;
}
inline void DebugModify_ModifyValue::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.DebugModify.ModifyValue.value)
}

// -------------------------------------------------------------------

// DebugModify

// repeated .naothmessages.DebugModify.ModifyValue valueMap = 1;
inline int DebugModify::valuemap_size() const {
  return valuemap_.size();
}
inline void DebugModify::clear_valuemap() {
  valuemap_.Clear();
}
inline const ::naothmessages::DebugModify_ModifyValue& DebugModify::valuemap(int index) const {
  // @@protoc_insertion_point(field_get:naothmessages.DebugModify.valueMap)
  return valuemap_.Get(index);
}
inline ::naothmessages::DebugModify_ModifyValue* DebugModify::mutable_valuemap(int index) {
  // @@protoc_insertion_point(field_mutable:naothmessages.DebugModify.valueMap)
  return valuemap_.Mutable(index);
}
inline ::naothmessages::DebugModify_ModifyValue* DebugModify::add_valuemap() {
  // @@protoc_insertion_point(field_add:naothmessages.DebugModify.valueMap)
  return valuemap_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::naothmessages::DebugModify_ModifyValue >*
DebugModify::mutable_valuemap() {
  // @@protoc_insertion_point(field_mutable_list:naothmessages.DebugModify.valueMap)
  return &valuemap_;
}
inline const ::google::protobuf::RepeatedPtrField< ::naothmessages::DebugModify_ModifyValue >&
DebugModify::valuemap() const {
  // @@protoc_insertion_point(field_list:naothmessages.DebugModify.valueMap)
  return valuemap_;
}

// -------------------------------------------------------------------

// StepBuffer

// optional .naothmessages.Pose3D support_foot = 1;
inline bool StepBuffer::has_support_foot() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StepBuffer::set_has_support_foot() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StepBuffer::clear_has_support_foot() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StepBuffer::clear_support_foot() {
  if (support_foot_ != NULL) support_foot_->::naothmessages::Pose3D::Clear();
  clear_has_support_foot();
}
inline const ::naothmessages::Pose3D& StepBuffer::support_foot() const {
  const ::naothmessages::Pose3D* p = support_foot_;
  // @@protoc_insertion_point(field_get:naothmessages.StepBuffer.support_foot)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::Pose3D*>(
      &::naothmessages::_Pose3D_default_instance_);
}
inline ::naothmessages::Pose3D* StepBuffer::mutable_support_foot() {
  set_has_support_foot();
  if (support_foot_ == NULL) {
    support_foot_ = new ::naothmessages::Pose3D;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.StepBuffer.support_foot)
  return support_foot_;
}
inline ::naothmessages::Pose3D* StepBuffer::release_support_foot() {
  // @@protoc_insertion_point(field_release:naothmessages.StepBuffer.support_foot)
  clear_has_support_foot();
  ::naothmessages::Pose3D* temp = support_foot_;
  support_foot_ = NULL;
  return temp;
}
inline void StepBuffer::set_allocated_support_foot(::naothmessages::Pose3D* support_foot) {
  delete support_foot_;
  support_foot_ = support_foot;
  if (support_foot) {
    set_has_support_foot();
  } else {
    clear_has_support_foot();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.StepBuffer.support_foot)
}

// -------------------------------------------------------------------

// bodyAwareness

// optional bool isLifted = 1;
inline bool bodyAwareness::has_islifted() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void bodyAwareness::set_has_islifted() {
  _has_bits_[0] |= 0x00000004u;
}
inline void bodyAwareness::clear_has_islifted() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void bodyAwareness::clear_islifted() {
  islifted_ = false;
  clear_has_islifted();
}
inline bool bodyAwareness::islifted() const {
  // @@protoc_insertion_point(field_get:naothmessages.bodyAwareness.isLifted)
  return islifted_;
}
inline void bodyAwareness::set_islifted(bool value) {
  set_has_islifted();
  islifted_ = value;
  // @@protoc_insertion_point(field_set:naothmessages.bodyAwareness.isLifted)
}

// optional .naothmessages.DoubleVector3 calculatedCoM = 2;
inline bool bodyAwareness::has_calculatedcom() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bodyAwareness::set_has_calculatedcom() {
  _has_bits_[0] |= 0x00000001u;
}
inline void bodyAwareness::clear_has_calculatedcom() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void bodyAwareness::clear_calculatedcom() {
  if (calculatedcom_ != NULL) calculatedcom_->::naothmessages::DoubleVector3::Clear();
  clear_has_calculatedcom();
}
inline const ::naothmessages::DoubleVector3& bodyAwareness::calculatedcom() const {
  const ::naothmessages::DoubleVector3* p = calculatedcom_;
  // @@protoc_insertion_point(field_get:naothmessages.bodyAwareness.calculatedCoM)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* bodyAwareness::mutable_calculatedcom() {
  set_has_calculatedcom();
  if (calculatedcom_ == NULL) {
    calculatedcom_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.bodyAwareness.calculatedCoM)
  return calculatedcom_;
}
inline ::naothmessages::DoubleVector3* bodyAwareness::release_calculatedcom() {
  // @@protoc_insertion_point(field_release:naothmessages.bodyAwareness.calculatedCoM)
  clear_has_calculatedcom();
  ::naothmessages::DoubleVector3* temp = calculatedcom_;
  calculatedcom_ = NULL;
  return temp;
}
inline void bodyAwareness::set_allocated_calculatedcom(::naothmessages::DoubleVector3* calculatedcom) {
  delete calculatedcom_;
  calculatedcom_ = calculatedcom;
  if (calculatedcom) {
    set_has_calculatedcom();
  } else {
    clear_has_calculatedcom();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.bodyAwareness.calculatedCoM)
}

// optional .naothmessages.DoubleVector3 currentCoMError = 3;
inline bool bodyAwareness::has_currentcomerror() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bodyAwareness::set_has_currentcomerror() {
  _has_bits_[0] |= 0x00000002u;
}
inline void bodyAwareness::clear_has_currentcomerror() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void bodyAwareness::clear_currentcomerror() {
  if (currentcomerror_ != NULL) currentcomerror_->::naothmessages::DoubleVector3::Clear();
  clear_has_currentcomerror();
}
inline const ::naothmessages::DoubleVector3& bodyAwareness::currentcomerror() const {
  const ::naothmessages::DoubleVector3* p = currentcomerror_;
  // @@protoc_insertion_point(field_get:naothmessages.bodyAwareness.currentCoMError)
  return p != NULL ? *p : *reinterpret_cast<const ::naothmessages::DoubleVector3*>(
      &::naothmessages::_DoubleVector3_default_instance_);
}
inline ::naothmessages::DoubleVector3* bodyAwareness::mutable_currentcomerror() {
  set_has_currentcomerror();
  if (currentcomerror_ == NULL) {
    currentcomerror_ = new ::naothmessages::DoubleVector3;
  }
  // @@protoc_insertion_point(field_mutable:naothmessages.bodyAwareness.currentCoMError)
  return currentcomerror_;
}
inline ::naothmessages::DoubleVector3* bodyAwareness::release_currentcomerror() {
  // @@protoc_insertion_point(field_release:naothmessages.bodyAwareness.currentCoMError)
  clear_has_currentcomerror();
  ::naothmessages::DoubleVector3* temp = currentcomerror_;
  currentcomerror_ = NULL;
  return temp;
}
inline void bodyAwareness::set_allocated_currentcomerror(::naothmessages::DoubleVector3* currentcomerror) {
  delete currentcomerror_;
  currentcomerror_ = currentcomerror;
  if (currentcomerror) {
    set_has_currentcomerror();
  } else {
    clear_has_currentcomerror();
  }
  // @@protoc_insertion_point(field_set_allocated:naothmessages.bodyAwareness.currentCoMError)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace naothmessages

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::naothmessages::GoalPercept_GoalPost_PostType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::GoalPercept_GoalPost_PostType>() {
  return ::naothmessages::GoalPercept_GoalPost_PostType_descriptor();
}
template <> struct is_proto_enum< ::naothmessages::StepControlRequest_StepType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::StepControlRequest_StepType>() {
  return ::naothmessages::StepControlRequest_StepType_descriptor();
}
template <> struct is_proto_enum< ::naothmessages::StepControlRequest_RestrictionMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::StepControlRequest_RestrictionMode>() {
  return ::naothmessages::StepControlRequest_RestrictionMode_descriptor();
}
template <> struct is_proto_enum< ::naothmessages::LinePercept_Intersection_IntersectionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::LinePercept_Intersection_IntersectionType>() {
  return ::naothmessages::LinePercept_Intersection_IntersectionType_descriptor();
}
template <> struct is_proto_enum< ::naothmessages::BallCandidates_Patch_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::BallCandidates_Patch_Type>() {
  return ::naothmessages::BallCandidates_Patch_Type_descriptor();
}
template <> struct is_proto_enum< ::naothmessages::RemoteControlCommand_ControlMode> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::RemoteControlCommand_ControlMode>() {
  return ::naothmessages::RemoteControlCommand_ControlMode_descriptor();
}
template <> struct is_proto_enum< ::naothmessages::RemoteControlCommand_ActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::RemoteControlCommand_ActionType>() {
  return ::naothmessages::RemoteControlCommand_ActionType_descriptor();
}
template <> struct is_proto_enum< ::naothmessages::RemoteControlCommand_SecondActionType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::RemoteControlCommand_SecondActionType>() {
  return ::naothmessages::RemoteControlCommand_SecondActionType_descriptor();
}
template <> struct is_proto_enum< ::naothmessages::GroundContactModel_Foot> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::naothmessages::GroundContactModel_Foot>() {
  return ::naothmessages::GroundContactModel_Foot_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Representations_2eproto__INCLUDED
