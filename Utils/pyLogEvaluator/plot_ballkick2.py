import sys
import math
import matplotlib
from matplotlib import pyplot as plt 
from matplotlib import rcParams
from matplotlib import gridspec
import cPickle
import argparse
import scipy.stats
import scipy.odr

import math2d as m2d
from parse_behavior import BehaviorData, WorldState, Ball, Kick

import numpy as np


def getBall(s):
  return s.odometry*s.ball.percept

if __name__ == "__main__":
  rcParams["font.family"] = "serif"
  rcParams["xtick.labelsize"] = 8
  rcParams["ytick.labelsize"] = 8
  rcParams["axes.labelsize"] = 8
  rcParams["axes.titlesize"] = 8
  
  argparser = argparse.ArgumentParser(description="plot pickle files generated by parse_behavior")
  argparser.add_argument("filenames", help="locations of pickle files)", nargs="+")
  
  args = argparser.parse_args()

  trajectories = {}
  for filename in args.filenames:
    print filename
    data = None 
    with open(filename, "r") as inFile:
      data = cPickle.load(inFile)

    origin = m2d.Pose2D()

    for kick in data.kicks.values():
      if not kick.name in trajectories:
        trajectories[kick.name] = []
      
      trajectory = []
      for bp in data.state:
        if bp.frame == kick.frame:
          origin = ~(bp.odometry)
        if bp.frame >= kick.frame: # frame number
          ballpos = origin*getBall(bp)
          if len(trajectory) == 0:
            trajectory.append(ballpos)
          else:
            if bp.frame < kick.frame + 120:
              trajectory.append(ballpos)
            else:
              break
      trajectories[kick.name].append(trajectory)

  marker = {}
  marker["do_kick_with_left_foot"] = "bv"
  marker["do_kick_with_right_foot"] = "bv"
  marker["attack_with_left_foot"] = "co"
  marker["attack_with_right_foot"] = "co"
  marker["sidekick_to_right"] = 'r*'
  marker["sidekick_to_left"] = 'gs'

  speeds = [[],[]]
  for k in trajectories.keys():
    directions = []
    for trajectory in trajectories[k]:
      # original data
      x = [b.x for b in trajectory]
      y = [b.y for b in trajectory]
      # fit line
      # initial guess with ordinary least squares (doesn't take errors in x into account)
      p = np.polyfit(x, y, 1)
      # now construct odr fit from initial guess (takes into account errors in x AND y)
      line = scipy.odr.Model(lambda b, a: b[0]*a + b[1]) # (beta, x) -> y
      data = scipy.odr.Data(x, y)
      odr = scipy.odr.ODR(data, line, beta0=p)
      output = odr.run()
      beta = output.beta
      # calc fit
      xx = np.linspace(min(x), max(x), 100)
      yy = beta[0]*xx + beta[1]
      # direction
      dx = xx[-1]-xx[0]
      dy = yy[-1]-yy[0]
      directions.append(math.atan2(dy, dx))
      # calculate speed
      v = np.hypot(np.diff(x), np.diff(y))
      speeds[0].extend(range(len(v)))
      speeds[1].extend(v)
      # plot
      plt.clf()
      plt.title(k)
      plt.plot(x, y, marker[k], mew=0)
      plt.plot(xx, yy, "k-", lw=1)
      plt.show()
