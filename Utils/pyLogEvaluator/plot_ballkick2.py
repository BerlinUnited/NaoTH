import sys
import math
import matplotlib
from matplotlib import pyplot as plt 
from matplotlib import rcParams
from matplotlib import gridspec
from sklearn.decomposition import PCA
import cPickle
import argparse
import scipy.stats
import scipy.odr

import math2d as m2d
from parse_behavior import BehaviorData, WorldState, Ball, Kick

import numpy as np

def getBall(s):
  return s.odometry*s.ball.percept

if __name__ == "__main__":
  rcParams["font.family"] = "serif"
  rcParams["xtick.labelsize"] = 8
  rcParams["ytick.labelsize"] = 8
  rcParams["axes.labelsize"] = 8
  rcParams["axes.titlesize"] = 8
  
  argparser = argparse.ArgumentParser(description="plot pickle files generated by parse_behavior")
  argparser.add_argument("filenames", help="locations of pickle files)", nargs="+")
  
  args = argparser.parse_args()

  allkicks = {}
  trajectories = {}
  for filename in args.filenames:
    print filename
    data = None 
    with open(filename, "r") as inFile:
      data = cPickle.load(inFile)

    origin = m2d.Pose2D()

    for kick in data.kicks.values():
      k = kick.name
      if "do_kick" in k:
        k = "do_kick"
      elif "attack" in k:
        k = "attack"
      if k not in trajectories:
        trajectories[k] = []
      if k not in allkicks.keys():
        allkicks[k] = 0
      allkicks[k] = allkicks[k] + 1
      
      trajectory = []
      for bp in data.state:
        if bp.frame == kick.frame:
          origin = ~(bp.odometry)
        if bp.frame >= kick.frame: # frame number
          ballpos = origin*getBall(bp)
          # trajectory[0] is the "point of kick decision"
          if len(trajectory) == 0:
            trajectory.append(ballpos)
          else:
            # only take points, where the ball has moved at least 50mm to take into account the kick preparation
            if math.hypot(trajectory[0].x-ballpos.x, trajectory[0].y-ballpos.y) > 50:
              trajectory.append(ballpos)
              # a minimum amount of data is needed to do the fitting
              if len(trajectory) > 5:
                x = [b.x for b in trajectory]
                y = [b.y for b in trajectory]
                # initial guess with ordinary least squares (doesn't take errors in x into account)
                p = np.polyfit(x, y, 1)
                # now construct odr fit from initial guess (takes into account errors in x AND y)
                line = scipy.odr.Model(lambda b, a: b[0]*a + b[1]) # (beta, x) -> y
                mydata = scipy.odr.Data(x, y)
                odr = scipy.odr.ODR(mydata, line, beta0=p)
                output = odr.run()
                # break if the std deviation of the residuals becomes too large (empirical)
                # this happens either after long runs (doesn't happen in practice)
                # or if the trajectory is not a line any more (second kick etc.)
                if math.sqrt(output.res_var) > 10.0:
                  break
              # break after 5 secs 
              if bp.frame > kick.frame + 150:
                break
              # break is there are too large jumps in the data
              if math.hypot(trajectory[-1].x-ballpos.x, trajectory[-1].y-ballpos.y) > 100:
                break
      # check if enough data points are left
      if len(trajectory) > 10:
        # check if data is line shaped via PCA 
        # (probably overkill but that easily finds too "circular" point clouds as opposed to line segements)
        xy = [[b.x, b.y] for b in trajectory]
        pca = PCA()
        pca.fit(xy)
        lineness = pca.explained_variance_ratio_[1] / pca.explained_variance_ratio_[0]
        # and check if data covers enough space
        x = [b.x for b in trajectory]
        y = [b.x for b in trajectory]
        length = math.hypot(max(x)-min(x), max(y)-min(y))
        # actual check
        if lineness < 0.1 and length > 100:
          trajectories[k].append(trajectory)

  marker = {}
  marker["do_kick"] = "bv"
  marker["attack"] = "co"
  marker["sidekick_to_right"] = 'r*'
  marker["sidekick_to_left"] = 'gs'

  n = 0
  speeds = {}
  directions = {}
  for k in trajectories.keys():
    if k not in directions.keys():
      directions[k] = []
    if k not in speeds.keys():
      speeds[k] = []
    for trajectory in trajectories[k]:
      # original data
      x = [b.x for b in trajectory]
      y = [b.y for b in trajectory]
      # fit line
      # initial guess with ordinary least squares (doesn't take errors in x into account)
      p = np.polyfit(x, y, 1)
      # now construct odr fit from initial guess (takes into account errors in x AND y)
      line = scipy.odr.Model(lambda b, a: b[0]*a + b[1]) # (beta, x) -> y
      data = scipy.odr.Data(x, y)
      odr = scipy.odr.ODR(data, line, beta0=p)
      output = odr.run()
      beta = output.beta
      # calc fit
      xx = np.linspace(x[0], x[-1], 100)
      yy = beta[0]*xx + beta[1]
      # direction
      dx = xx[-1]-xx[0]
      dy = yy[-1]-yy[0]
      directions[k].append(math.atan2(dy, dx))
      # calculate speed
      fmax = min(10, len(x))
      v = np.mean(np.hypot(np.diff(x[1:fmax+1]), np.diff(y[1:fmax+1])))
      speeds[k].append(v)
      # plot
      plt.clf()
      plt.title(k+" "+ str(math.sqrt(output.res_var)))
      plt.plot(x, y, marker[k]+"-", mew=0)
      plt.plot(trajectory[0].x, trajectory[0].y, "ko")
      plt.plot(xx, yy, "k-", lw=1)
      plt.gca().set_aspect("equal", "datalim")
      plt.savefig("kick"+str(n).zfill(6)+".png", dpi=200)
      n = n + 1
  
  # plot directions histograms
  n = 1
  plt.clf()
  for k in directions.keys():
    plt.subplot(len(directions.keys()), 2, 2*n-1)
    plt.title(k + " with " + str(len(directions[k]))+"/"+str(allkicks[k]) + " kicks")
    plt.hist(directions[k], bins=36, range=(-math.pi, math.pi))
    plt.gca().set_xlim((-math.pi, math.pi))
    plt.subplot(len(directions.keys()), 2, 2*n)
    plt.title(k + ", mean speed = " + str(np.mean(speeds[k])))
    plt.hist(speeds[k], bins=50, range=(0, 100))
    plt.gca().set_xlim((0, 100))
    n = n + 1
  plt.gcf().set_size_inches((8, len(directions.keys())*3))
  plt.savefig("directions.pdf", dpi=200)
